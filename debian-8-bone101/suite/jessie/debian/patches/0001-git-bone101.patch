From 28d0810b72d26affaf503d46ed7dd339387afacf Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 15 Nov 2016 13:57:27 -0600
Subject: [PATCH] git bone101

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 Support/bone101/UI/README.md      |  186 +-
 Support/bone101/UI/bbui.js        | 1063 ++++++--
 Support/bone101/UI/fsm/fsmsave.js |    1 +
 Support/bone101/UI/fsm/index.html |  111 +
 Support/script/beagle-ui.js       |   78 +-
 _includes/side_menu.html          |    2 +-
 static/fsm.js                     | 1114 ++++++++
 static/jquery.terminal.css        |  247 +-
 static/jquery.terminal.js         | 5212 ++++++++++++++++++++++++++++++++++++-
 9 files changed, 7703 insertions(+), 311 deletions(-)
 create mode 100644 Support/bone101/UI/fsm/fsmsave.js
 create mode 100755 Support/bone101/UI/fsm/index.html
 create mode 100644 static/fsm.js

diff --git a/Support/bone101/UI/README.md b/Support/bone101/UI/README.md
index c4dfe7e..9a9e03a 100644
--- a/Support/bone101/UI/README.md
+++ b/Support/bone101/UI/README.md
@@ -1,26 +1,40 @@
-BeagleBone User Interface
-=========================
-
+# BeagleBone User Interface
 This is a UI that allows a user to interact with a BeagleBone with minimal to no coding experience. This allows a user to communicate to the board and use the ADC pins, digital (inputs, outputs, pwms) pins, and the user LEDs located at the top of the board. The only requirement is that the desired circuit is correct for the code to function properly. The code assumes that the BoneScript server using socket.io is running on the target board on the default port (80). The main example index.html file contains the user interface and interactions from the user are sent to the js file, which uses socket.io to communicate to the board.
 
-Served locally
---------------
-The UI runs on http://yourbeagleboneip/bone101/Support/UI/ as long as this version of the bone101 library is installed to /var/lib/clou9 and the BoneScript server is running. Changes can be made to the file locations and filenames at the top of the js file.
+## Served locally
+The UI runs on http://yourbeagleboneip/bone101/Support/UI/ as long as this version of the bone101 library is installed to /var/lib/cloud9 and the BoneScript server is running. Changes can be made to the file locations and filenames at the top of the js file.
+
+## Served on Github Pages
+This UI can be run by visiting http://beagleboard.github.io/bone101/Support/bone101/UI/ with a BeagleBone connected locally via USB or on the network. If the board is not automatically discovered, you'll need to type in the IP address of the board.
 
-Served on Github Pages
-----------------------
-This UI can be run by visiting http://beagleboard.github.io/bone101/Support/bone101/UI/ with a BeagleBone connected locally via USB or on the network. If the board is not automatically discovered, you'll need to type in the IP address of the board
+## BBUI Code Guide
 
-bbui.js
-=======
+  1. [BBUI](#bbui)
+  1. [IIFE](#iife)
+  1. [Canvas](#canvas)
+  1. [Hardware](#hardware)
+  1. [UI](#ui)
+  1. [Events](#events)
+  
+## BBUI
 This script renders the UI, reacts to user input and calls the BoneScript functions for hardware interaction. Including this script exposes 1 initialization function called 'bbui' and is built as 4 classes:
-* Canvas: fetches the canvas elements from the HTML page and expose them to the rest of BBUI.
-* Hardware: modifies, fetches and exposes the hardware status using BoneScript calls.
-* UI: renders the user interface and provides methods for updating the rendering.
-* Events: reponds to input provided by the user and calls UI methods for updating the display.
+ * Canvas: fetches the canvas elements from the HTML page and expose them to the rest of BBUI.
+ * Hardware: modifies, fetches and exposes the hardware status using BoneScript calls.
+ * UI: renders the user interface and provides methods for updating the rendering.
+ * Events: reponds to input provided by the user and calls UI methods for updating the display.
+
+## IIFE
+  - BBUI components is wraped in an Immediately Invoked Function Expression (IIFE).
+  
+  *Why?* : An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.
+
+  *Why?* : The code is minified and bundled into a single file for convienient access. An IIFE protects BBUI components against collisions of variables and many global variables by providing variable scope for each class.
+
+<p align="center">
+  <img src="http://i1064.photobucket.com/albums/u367/Amr_Ragaey/iiefe2_zps1nkgcl5e.png?raw=true" alt="IIEFE Style in BBUI"/>
+</p>
 
-Canvas
-------
+## Canvas
 The Canvas class grabs 9 HTML canvas elements each rendered at 1224x600 pixels on top of each other.
 * Base: is the canvas with BeagleBone and other unchanging elements and is rendered at z-index 1 (background).
 * BTN: is the canvas that draws buttons and corresponding elements and is rendered at z-index 2 (just above the background).
@@ -29,6 +43,140 @@ The Canvas class grabs 9 HTML canvas elements each rendered at 1224x600 pixels o
 * Bar: is the canvas for slider bars and is rendered at z-index 8.
 * Graph: is the canvas for the graph controls and is rendered at z-index 9.
 
-Each canvas exposes and element (e) and a context (ctx).
+```javascript
+• function init()
+```
+initializes different canvas layers of bbui, and returns the canvas object. Each canvas exposes and element (e) and a context (ctx).
+
+- use `var canvas = Canvas.get();` to fetch the canvas.
+- use `canvas[layer].e` to get a layer element.
+- use `canvas[layer].ctx` is used to get a layer context
+
+
+```javascript
+• function add(id, zIndex)
+```
+It is used to add additional canvases beyond the initial 9 with new z-index value. It is used to add probes and graphs as will be described in the UI class. The created canvas is attached to the html div element of id = 'canvasdiv'.
+
+**arguments**:
+
+- id:  element id that creates the canvas.
+- z-index: normally uses value 10, or above.
+
+_example_: Canvas.add(pin.id + ' Graph', 10); 'creates a canvas for specific pin'
+
+## UI
+
+The UI provides the user interface drawing and interaction logic, and initializes global positions of BBUI elements. Each element position is related mainly to two variables **`BBposX`** and **`BBposY`**.
+
+```javascript
+• function init()
+```
+The init function defines all the methods used to draw different elements/objects in the Bonecard. Each method is an IIEFE, we will go for each one explaining its functionality and sub-methods.
+
+- use `var ui = UI.get();` to fetch the user interface object.
+
+```javascript
+ ui.button = (function() {
+    var button = {};
+    /* 
+     * button objects
+     * are defined here
+    */
+  })
+```
+`ui.button`, an IIFE provides major buttons used in BBUI with different attributes; starting and ending position of the button, the color, the text on the button, the offColor, the graph line colors, and the category of each group of buttons. The major buttons objects are: analog, digital, ground, power, led, input, output, pwm, onOff, plus, minus, stop, play, exit, digitalMenu. `ui.button` wraps the functions used to draw and interact with buttons.
+
+```javascript
+○ button.test = function(event)
+```
+Use this method to return button object name.
+
+```javascript
+○ button.highlight = function(highlightButton)
+```
+Use to highlight analog, digital, power, ground, led buttons.
+if you want to keep the button highlighted, set `highlightButton = true`.
+
+```javascript
+○ button.highlightDigital = function(highlightButton)
+```
+Use to highlight digital menu buttons (input, output, pwm).
+if you want to keep the button highlighted, set highlightButton = true.
+
+```javascript
+○ button.highlightPlus = function()
+```
+Use to highlight the zoom-in button, color will change to red.
+
+```javascript
+○ button.highlightMinus = function()
+```
+Use to highlight the zoom-out button, color will change to red.
+```javascript
+○ button.highlightStop = function()
+```
+Use to highlight the stop button, color will change to red.
+```javascript
+○ button.highlightPlay = function()
+```
+Use to highlight the play button, color will change to red.
+```javascript
+○ button.draw = function(b, context, highlight, x, y)
+```
+Use the draw function to draw the main buttons and probes. make `highlight = true` when dragging a button into graph otherwise the highlight is false.
+
+**arguments**:
+
+- b: button object name.
+- context: the drawing context, use `BTN` for probes, `Active` for dragging and highlighting, and `Graph` for (plus, minus, stop, play)
+- highlight: true for highlighting (using `offColor`).
+- x,y: only defined for custom buttons positions.
+
+
+_PS. each of the following two functions draws a layer, one for the on switch and another for off switch. The two layers overlap each other to make the on/off switch._
+
+```javascript
+○ button.on = function(probe)
+```
+Use button.on to draw on-switch, takes probe as an argument to match probe position and colors.
+
+```javascript
+○ button.off = function(probe)
+```
+Use button.off to draw off-switch, takes probe as an argument to match probe position and colors.
+
+```javascript
+○ button.createOutput = function()
+```
+createOutput is used to create output button for input probe, when user drags an input button into graph and selects a pin, this output button is created.
+
+```javascript
+○ button.drawGraphbtn = function(b, context)
+```
+Use drawGraphbtn to draw the buttons of graph; play, stop, zooming buttons.
+
+**arguments**:
+- b: the graph button name.
+- context: use `Active` context.
+
+```javascript
+○ button.push = function(b, output)
+```
+The function initially creates a new button object referenced by **`probeIndex`**; a local variable initially set to zero and incremented after each push. The push function sets properties to the new object; object name, x&y position of button, and button status. Status property is set to `probe` to uniquefies the button in buttons object in looping.
+
+**arguments**:
+- b: button object name.
+- output: is set to `true` only for the output button created from input probe. It sets unique position for this output.
+
+```javascript
+○ button.pop = function()
+```
+Use this method to delete the latest button added in buttons object.
+the method returns the deleted button object.
+
+```javascript
+○   button.get = function()
+```
+Use this method to return buttons object.
 
-Additional canvases beyond the initial 9 are added using the Canvas 'add' method. It is used to add probes and graphs as will be described in the UI class. The 'add' method takes in z-index as an argument, but today they are all added at z-index 10.
diff --git a/Support/bone101/UI/bbui.js b/Support/bone101/UI/bbui.js
index 8a41ff0..54b8cc8 100644
--- a/Support/bone101/UI/bbui.js
+++ b/Support/bone101/UI/bbui.js
@@ -108,8 +108,8 @@ var UI = (function() {
         // positions
         var BBposX = 283;
         var BBposY = 120;
-        var axisStartY = BBposY + 40;
-        var axisStartX = BBposX + 375;
+        var axisStartY = BBposY + 65;
+        var axisStartX = BBposX + 240;
         var rect = {
             x: 0,
             y: BBposY - 70,
@@ -122,10 +122,16 @@ var UI = (function() {
             w: 420,
             h: 510
         };
+        //the position of the probe inside the graph
         var snapProbe = {
-            x: rect.x + 35,
+            x: rect.x + 28,
             y: rect.y + 25
         };
+        //the position of colored lines of each probe beside axis
+        var graphLinePos = BBposY - 60;
+
+        // mousedown on a button state
+        ui.down = false;
 
         // major buttons
         ui.button = (function() {
@@ -143,7 +149,7 @@ var UI = (function() {
                     endY: btnY + 15,
                     color: 'rgb(51,153,255)',
                     text: "analog",
-                    s: 13,
+                    s: 19,
                     offColor: 'rgb(0,51,102)',
                     article: "an analog pin",
                     graphColors: ['rgb(0,0,255)', 'rgb(0,01,53)', 'rgb(0,102,204)', 'rgb(0,51,102)'],
@@ -156,7 +162,7 @@ var UI = (function() {
                     endY: btnY + 15,
                     color: 'rgb(102,204,51)',
                     text: "digital",
-                    s: 10,
+                    s: 19,
                     category: "main"
                 },
                 ground: {
@@ -166,7 +172,7 @@ var UI = (function() {
                     endY: btnY + 15,
                     color: 'rgb(64,64,64)',
                     text: "ground",
-                    s: 12,
+                    s: 19,
                     category: "main"
                 },
                 power: {
@@ -176,7 +182,7 @@ var UI = (function() {
                     endY: btnY + 15,
                     color: 'rgb(255,51,51)',
                     text: "power",
-                    s: 17,
+                    s: 19,
                     category: "main"
                 },
                 led: {
@@ -186,7 +192,7 @@ var UI = (function() {
                     endY: btnY + 15,
                     color: 'rgb(255,153,51)',
                     text: "usr leds",
-                    s: 7,
+                    s: 15,
                     offColor: 'rgb(102,0,0)',
                     barColor: 'rgb(255,204,153)',
                     article: "a user led",
@@ -200,7 +206,7 @@ var UI = (function() {
                     endY: btnY + 35,
                     color: 'rgb(0,153,0)',
                     text: "input",
-                    s: 17,
+                    s: 22,
                     offColor: 'rgb(0,81,36)',
                     article: "a digital pin",
                     graphColors: ['rgb(0,51,0)', 'rgb(0,204,0)', 'rgb(51,102,0)', 'rgb(0,255,0)', 'rgb(128,255,0)'],
@@ -213,7 +219,7 @@ var UI = (function() {
                     endY: btnY + 55,
                     color: 'rgb(0,153,153)',
                     text: "output",
-                    s: 13,
+                    s: 19,
                     offColor: 'rgb(0,85,85)',
                     barColor: 'rgb(153,255,255)',
                     article: "a digital pin",
@@ -227,46 +233,60 @@ var UI = (function() {
                     endY: btnY + 75,
                     color: 'rgb(153,0,153)',
                     text: "pwm",
-                    s: 25,
+                    s: 23,
                     offColor: 'rgb(51,0,102)',
                     barColor: 'rgb(229,204,255)',
                     article: "a pwm pin",
                     graphColors: ['rgb(102,0,102)', 'rgb(204,0,204)', 'rgb(255,102,255)', 'rgb(51,0,51)'],
                     category: "digital"
                 },
+                onOff: {
+                    x: snapProbe.x + 85,
+                    y: snapProbe.y,
+                    endX: snapProbe.x + 135,
+                    endY: snapProbe.y + 15,
+                    s: 6,
+                    e: 28
+                },
                 plus: {
-                    x: axisStartX + 10,
-                    y: axisStartY + 451,
-                    endX: axisStartX + 25,
-                    endY: axisStartY + 451,
+                    x: axisStartX + 54,
+                    y: axisStartY + 240,
+                    endX: axisStartX + 66,
+                    endY: axisStartY + 252 + 2,
+                    text: "+",
                     category: "graph"
                 },
                 minus: {
-                    x: axisStartX - 10,
-                    y: axisStartY + 453,
-                    endX: axisStartX + 5,
-                    endY: axisStartY + 451,
+                    x: axisStartX + 36,
+                    y: axisStartY + 240,
+                    endX: axisStartX + 48,
+                    endY: axisStartY + 252 + 3,
+                    text: "-",
                     category: "graph"
                 },
                 stop: {
-                    x: axisStartX - 29,
-                    y: axisStartY + 437,
-                    endX: axisStartX - 17,
-                    endY: axisStartY + 451,
+                    x: axisStartX + 18,
+                    y: axisStartY + 240,
+                    endX: axisStartX + 30,
+                    endY: axisStartY + 252,
+                    status: "none",
+                    text:"stop",
                     category: "graph"
                 },
                 play: {
-                    x: axisStartX - 48,
-                    y: axisStartY + 436,
-                    endX: axisStartX - 34,
-                    endY: axisStartY + 451,
+                    x: axisStartX,
+                    y: axisStartY + 240,
+                    endX: axisStartX + 12,
+                    endY: axisStartY + 252,
+                    status: "none",
+                    text: "play",
                     category: "graph"
                 },
                 exit: {
-                    x: canvas.Base.e.width * 6 / 8 + 52.5,
-                    y: canvas.Base.e.height / 4 + 8,
-                    endX: canvas.Base.e.width * 6 / 8 + 60.5,
-                    endY: canvas.Base.e.height / 4 + 20,
+                    x: canvas.Base.e.width / 2 + 250,
+                    y: canvas.Base.e.height / 4 + 13,
+                    endX: canvas.Base.e.width / 2 + 258,
+                    endY: canvas.Base.e.height / 4 + 25,
                     category: "welcome"
                 },
                 digitalMenu: {
@@ -283,6 +303,7 @@ var UI = (function() {
                 var coords = Position(event);
                 var x = coords[0];
                 var y = coords[1];
+                //console.log("x: " + x , ", y: " + y );
 
                 for (var b in buttons) {
                     var minX = buttons[b].x;
@@ -291,13 +312,14 @@ var UI = (function() {
                     var maxY = buttons[b].endY;
                     if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                         //console.log("button = " + b);
-                        return (b);
+                        return b;
                     }
                 }
                 //console.log("button = none");
                 return ("none");
             };
 
+            //highlight analog, digital, power, ground, led buttons
             button.highlight = function(highlightButton) {
                 canvas.Active.ctx.fillStyle = 'rgba(255,255,255,0.7)';
                 for (var b in buttons) {
@@ -307,6 +329,7 @@ var UI = (function() {
                 }
             };
 
+            //highlight input, output, pwm buttons
             button.highlightDigital = function(highlightButton) {
                 canvas.Active.ctx.fillStyle = 'rgba(255,255,255,0.7)';
                 for (var b in buttons) {
@@ -318,14 +341,14 @@ var UI = (function() {
 
             button.highlightPlus = function() {
                 canvas.Graph.ctx.fillStyle = "#FF4500";
-                canvas.Graph.ctx.font = '20pt Lucinda Grande';
-                canvas.Graph.ctx.fillText("+", buttons.plus.x, buttons.plus.y);
+                canvas.Graph.ctx.font = 'bold 20pt Lucinda Grande';
+                canvas.Graph.ctx.fillText("+", buttons.plus.x, buttons.plus.endY);
             };
 
             button.highlightMinus = function() {
                 canvas.Graph.ctx.fillStyle = "#FF4500";
                 canvas.Graph.ctx.font = '30pt Lucinda Grande';
-                canvas.Graph.ctx.fillText("-", buttons.minus.x, buttons.minus.y);
+                canvas.Graph.ctx.fillText("-", buttons.minus.x, buttons.minus.endY);
             };
 
             button.highlightStop = function() {
@@ -338,7 +361,7 @@ var UI = (function() {
                 canvas.Graph.ctx.fill();
             };
 
-            button.highlightStop = function() {
+            button.highlightPlay = function() {
                 canvas.Graph.ctx.fillStyle = "#FF4500";
                 canvas.Graph.ctx.beginPath();
                 canvas.Graph.ctx.moveTo(buttons.play.x, buttons.play.y);
@@ -347,6 +370,10 @@ var UI = (function() {
                 canvas.Graph.ctx.fill();
             };
 
+            /*
+            the draw function is used to draw the main buttons and probes.
+            use highlight = true when dragging a button into graph otherwise the highlight is false.
+            */
             button.draw = function(b, context, highlight, x, y) {
                 var radius = 1;
                 var btn = buttons[b];
@@ -391,42 +418,431 @@ var UI = (function() {
                 context.fillText(text, x + s, y + 12);
             };
 
-            var probeIndex = 0;
-            button.push = function(b, x, y) {
+            // on switch
+            button.on = function(probe) {
+                var btn = buttons['onOff'];
+                var x = probe.x + 85;
+                var y = probe.y;
+                var color = probe.color;
+                var offColor = probe.offColor;
+                var s = btn.s; var e = btn.e;
+                var w = 50; var h = 15;
+                var r = probe.endX + 60;
+                var b = probe.endY;
+                var radius = 1;
+
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.lineWidth="1";
+                canvas.BTN.ctx.moveTo(x+radius, y);
+                canvas.BTN.ctx.lineTo(r-radius, y);
+                canvas.BTN.ctx.quadraticCurveTo(r, y, r, y+radius);
+                canvas.BTN.ctx.lineTo(r, y+h-radius);
+                canvas.BTN.ctx.quadraticCurveTo(r, b, r-radius, b);
+                canvas.BTN.ctx.lineTo(x+radius, b);
+                canvas.BTN.ctx.quadraticCurveTo(x, b, x, b-radius);
+                canvas.BTN.ctx.lineTo(x, y+radius);
+                canvas.BTN.ctx.quadraticCurveTo(x, y, x+radius, y);
+                canvas.BTN.ctx.strokeStyle = color; 
+                canvas.BTN.ctx.stroke();
+                canvas.BTN.ctx.fillStyle = color; 
+                canvas.BTN.ctx.fill()
+                canvas.BTN.ctx.fillStyle= 'white';
+                canvas.BTN.ctx.font = '10pt Andale Mono';
+                canvas.BTN.ctx.fillText('on', x + s, y+12);
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(x+w/2, y);
+                canvas.BTN.ctx.lineTo(r-radius, y);
+                canvas.BTN.ctx.quadraticCurveTo(r, y, r, y+radius);
+                canvas.BTN.ctx.lineTo(r, y+h-radius);
+                canvas.BTN.ctx.quadraticCurveTo(r, b, r-radius, b);
+                canvas.BTN.ctx.lineTo(x+w/2, b);
+                canvas.BTN.ctx.fillStyle = offColor; 
+                canvas.BTN.ctx.fill()
+                canvas.BTN.ctx.fillStyle= 'black';
+                canvas.BTN.ctx.font = '10pt Andale Mono';
+                canvas.BTN.ctx.fillText('off', x + e, y+12);
+            };
+
+            // off switch
+            button.off = function(probe){
+                var btn = buttons['onOff'];
+                var x = probe.x + 85;
+                var y = probe.y;
+                var color = probe.color;
+                var offColor = probe.offColor;
+                var s = btn.s; var s = btn.s; var e = btn.e;
+                var w = 50; var h = 15;
+                var r = probe.endX + 60;
+                var b = probe.endY;
+                var radius = 1;
+
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.lineWidth="1";
+                canvas.BTN.ctx.moveTo(x+radius, y);
+                canvas.BTN.ctx.lineTo(r-radius, y);
+                canvas.BTN.ctx.quadraticCurveTo(r, y, r, y+radius);
+                canvas.BTN.ctx.lineTo(r, y+h-radius);
+                canvas.BTN.ctx.quadraticCurveTo(r, b, r-radius, b);
+                canvas.BTN.ctx.lineTo(x+radius, b);
+                canvas.BTN.ctx.quadraticCurveTo(x, b, x, b-radius);
+                canvas.BTN.ctx.lineTo(x, y+radius);
+                canvas.BTN.ctx.quadraticCurveTo(x, y, x+radius, y);
+                canvas.BTN.ctx.strokeStyle = color; 
+                canvas.BTN.ctx.stroke();
+                canvas.BTN.ctx.fillStyle = color; 
+                canvas.BTN.ctx.fill()
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(x+w/2, b);
+                canvas.BTN.ctx.lineTo(x+radius, b);
+                canvas.BTN.ctx.quadraticCurveTo(x, b, x, b-radius);
+                canvas.BTN.ctx.lineTo(x, y+radius);
+                canvas.BTN.ctx.quadraticCurveTo(x, y, x+radius, y);
+                canvas.BTN.ctx.lineTo(x+w/2, y);
+                canvas.BTN.ctx.fillStyle = offColor; 
+                canvas.BTN.ctx.fill();
+                canvas.BTN.ctx.fillStyle= 'black';
+                canvas.BTN.ctx.font = '10pt Andale Mono';
+                canvas.BTN.ctx.fillText('on', x + s, y+12);
+                canvas.BTN.ctx.fillStyle= 'white';
+                canvas.BTN.ctx.font = '10pt Andale Mono';
+                canvas.BTN.ctx.fillText('off', x + e, y+12);
+            };
+
+            button.createOutput = function(){
+                button.push('output',true);
+                var probes = Object.keys(buttons);
+                probeName = probes[probes.length-16];
+                probe = buttons[probeName];
+                probe2 = buttons[probes[probes.length-17]]
+                ui.wire.link(probe2,probe);
+                probe.input = "on";
+                canvas.Active.ctx.fillStyle= 'red';
+                canvas.Active.ctx.font = '12pt Andale Mono';
+                canvas.Active.ctx.fillText("select " + probe.article, BBposX + 10, BBposY-25);
+            };
+
+            //draw play, stop, zooming buttons
+            button.drawGraphbtn = function(b, context) {
+                var btn = buttons[b];
+                // zoom in
+                if (btn.text == "+") {
+                    context.font = 'bold 20pt Lucinda Grande';
+                    context.fillText(btn.text, btn.x, btn.endY);
+                    context.save();
+                }
+                
+                // zoom out
+                else if (btn.text == "-") {
+                    context.font = '30pt Lucinda Grande';
+                    context.fillText(btn.text, btn.x, btn.endY);
+                    context.save();
+                }
+                
+                // play button
+                else if (btn.text == "play") 
+                {
+                    context.beginPath();
+                    context.moveTo(btn.x, btn.y);
+                    context.lineTo(btn.x + 10, btn.y + 7);
+                    context.lineTo(btn.x, btn.y + 14);
+                    context.fill();
+                    context.restore();
+                    context.save();
+                }
+
+                // stop button
+                else {
+                    context.beginPath();
+                    context.moveTo(btn.x, btn.y);
+                    context.lineTo(btn.x + 12, btn.y);
+                    context.lineTo(btn.x + 12, btn.y + 12);
+                    context.lineTo(btn.x, btn.y + 12);
+                    context.fill();
+                    context.restore();
+                }
+            };
+
+            var probeIndex = 0
+            button.push = function(b, output) {
                 buttons[probeIndex] = {};
                 for (var prop in buttons[b]) {
                     if (buttons[b].hasOwnProperty(prop)) {
                         buttons[probeIndex][prop] = buttons[b][prop];
                     }
                 }
+                buttons[probeIndex].name = b;
                 buttons[probeIndex].x = snapProbe.x;
                 buttons[probeIndex].y = snapProbe.y;
                 buttons[probeIndex].endX = snapProbe.x + 75;
                 buttons[probeIndex].endY = snapProbe.y + 15;
-                buttons[probeIndex].category = "probe";
-                button.draw(probeIndex, canvas.Base.ctx, false);
+                buttons[probeIndex].status = "probe";
+
+                //ui.probe.push(buttons[probeIndex]);
+
+                //output is true if the input button selected.
+                if (output === true) {
+                    buttons[probeIndex].x = snapProbe.x+75;
+                    buttons[probeIndex].endX = snapProbe.x + 150;
+                    button.draw(probeIndex, canvas.Base.ctx, false, snapProbe.x+75, snapProbe.y);
+                }
+                else {
+                    button.draw(probeIndex, canvas.Base.ctx, false);
+                }
                 snapProbe.y += 22;
                 probeIndex++;
             };
 
+            //removing a button and resetting snapProbe position.
             button.pop = function() {
+                snapProbe.y -= 22;
                 probeIndex--;
+                var button = buttons[probeIndex];
                 delete buttons[probeIndex];
+                return button;
             };
 
             button.get = function() {
                 return buttons;
             }
 
+            //draw initial buttons to the canvas
             for (var b in buttons) {
                 if (buttons[b].category == "main") {
                     button.draw(b, canvas.Base.ctx, false);
+                } else if (buttons[b].category == "graph") {
+                    button.drawGraphbtn(b, canvas.Graph.ctx);
                 }
             }
 
             return button;
         })();
 
+        ui.bar = (function() {
+            var bar = {};
+            var bars = [];
+
+            // slider bar properties, not necessarily connected to led
+            bar.create = function(probe, pin) {
+                var bar = {
+                    color: probe.color,
+                    outline: probe.color,
+                    height: 15,
+                    length: 70,
+                    locX: probe.endX + 70,
+                    locY: probe.y,
+                    btn: probe,
+                    move: "off",
+                    pin: pin,
+                    sliderX: 0,
+                    sliderY: 0,
+                    frequency: 0,
+                    setSliderX: function(){this.sliderX = this.locX + 2;},
+                    setSliderY: function(){this.sliderY = this.locY + 2;},
+                    setFrequency: function(){this.frequency = this.sliderX - this.locX - 2;},
+                    text: "0 s",
+                    type: probe.name
+                };
+
+                bar.setSliderX();
+                bar.setSliderY();
+                bar.setFrequency();
+
+                if (probe.name === "pwm") {
+                    bar.text = bar.frequency.toString();
+                }
+                else {
+                    bar.text = (bar.frequency.toString() + ' s');
+                };
+
+                bars.push(bar);
+                return bars;
+            };
+
+            bar.draw = function(){
+                var len = bars.length;
+                //canvas.Bar.ctx.clearRect(0,0,canvas.Bar.e.width,canvas.Bar.e.height);
+                canvas.Bar.ctx.fillStyle= 'rgb(205,205,205)';
+                canvas.Bar.ctx.fillRect(bars[len-1].locX,bars[len-1].locY, bars[len-1].length, bars[len-1].height);
+                canvas.Bar.ctx.fillStyle= bars[len-1].barColor;
+                canvas.Bar.ctx.fillRect(bars[len-1].locX,bars[len-1].locY, bars[len-1].sliderX - bars[len-1].locX, 15);
+                canvas.Bar.ctx.fillStyle= 'rgb(30,30,30)';
+                canvas.Bar.ctx.fillRect(bars[len-1].sliderX-2,bars[len-1].sliderY-2,14,15); //width and height of slider
+                canvas.Bar.ctx.strokeStyle= bars[len-1].outline;
+                canvas.Bar.ctx.lineWidth = 2;
+                canvas.Bar.ctx.strokeRect(bars[len-1].locX,bars[len-1].locY, bars[len-1].length, bars[len-1].height);
+                canvas.Bar.ctx.fillStyle= 'black';
+                canvas.Bar.ctx.strokeStyle = 'rgb(225,225,225)';
+                canvas.Bar.ctx.lineWidth = 6;
+                canvas.Bar.ctx.font = '12pt Andale Mono';
+                canvas.Bar.ctx.strokeText(bars[len-1].text, bars[len-1].length + bars[len-1].locX + 5, 
+                bars[len-1].height + bars[len-1].locY -2);  
+                canvas.Bar.ctx.fillText(bars[len-1].text, bars[len-1].length + bars[len-1].locX + 5, 
+                bars[len-1].height + bars[len-1].locY -2);
+            };
+
+            bar.move = function(event) {
+                var coord = Position(event);
+                var x = coord[0];
+                var y = coord[1];
+                var i;
+                var len = bars.length;
+                for (i = 0; i<len; i++){
+                    if (bars[i].move === 'on'){
+                        bars[i].sliderX = x-5;
+                        if(bars[i].sliderX < bars[i].locX+2){ 
+                            bars[i].sliderX = bars[i].locX+2;
+                            bars[i].frequency = 0;
+                    }
+                    else if (bars[i].sliderX > bars[i].length + bars[i].locX-12){
+                            bars[i].sliderX = bars[i].length + bars[i].locX - 12;
+                        if (bars[i].type === "pwm"){
+                            bars[i].frequency = 1;
+                        }
+                        else {
+                            bars[i].frequency = 10;
+                        }
+                    }
+                    else { 
+                        if (bars[i].type === "pwm"){
+                            bars[i].frequency = ((bars[i].sliderX - bars[i].locX -2)/140).toPrecision(2);}
+                        else {
+                            bars[i].frequency = ((bars[i].sliderX - bars[i].locX -2)/14).toPrecision(2);}
+                        }
+                        if (bars[i].type === "pwm"){
+                            bars[i].pin.freq = bars[i].frequency;
+                            bars[i].text = bars[i].frequency.toString();
+                        }
+                        else {
+                            bars[i].pin.freq = bars[i].frequency*1000;
+                            bars[i].text = bars[i].frequency.toString() + ' s';
+                        }
+                        bar.draw();
+                        if (bars[i].pin.freq != 0 && bars[i].pin.power === 'on'){
+                            //blink(bars[i].pin[bars[i].bars[i].pin]);
+                        } 
+                        //calling socket; this should be done with Hardware object.
+                        else if (bars[i].pin.power === 'on'){
+                            // drawLED(pin[bars[i].pin]);
+                            // var data = {freq: pin.freq, power: pin.power, 
+                            // id: pin.id, num: pin[bars[i].pin].num, state: pin[bars[i].pin].HIGH,
+                            // output: pin[bars[i].pin].output, type: pin[bars[i].pin].type,
+                            // subType: pin[bars[i].pin].subType};
+                        // call socket; turn on with no blinking
+                        }
+                    }
+                }
+            };
+
+            bar.off = function() {
+                var len = bars.length;
+                for (i = 0; i<len; i++) {
+                    if (bars[i].move === 'on'){ bars[i].move = 'off'; }
+                }
+            };
+
+            //returns the black square slider in slider bar.
+            bar.sliderTest = function(event) {
+                var coord = Position(event);
+                var x = coord[0];
+                var y = coord[1];
+                var i;
+                var len = bars.length;
+                for (i = 0; i<len; i++){
+                    if (x <= (bars[i].sliderX + 12) && x >= bars[i].sliderX-2 && y >= bars[i].sliderY-2 && y<= (bars[i].sliderY +13)){
+                        bars[i].move = 'on';
+                        return "slider";
+                    }
+                }
+            };
+
+            //returns the whole slider bar.
+            bar.test = function(event) {
+                var coords = Position(event);
+                var x = coords[0];
+                var y = coords[1];
+                for (var i = 0; i<bars.length; i++) {
+                    var minX = bars[i].locX;
+                    var minY = bars[i].locY;
+                    var maxX = minX + bars[i].length;
+                    var maxY = minY + bars[i].height;
+                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
+                        console.log("bar = " + bars[i]);
+                        return "slider";
+                    }
+                }
+                //console.log("button = none");
+                return ("none");
+            };
+
+            return bar;
+        })();
+
+        //wire object is responsible for drawing all wires in graph
+        // wires are drawn in BTN canvas
+        ui.wire = (function() {
+            var wire = {};
+            var btnHeight = 15;
+
+            wire.led = function(pin, probe){
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(probe.x + 75, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 143, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 143, rect.y + 10);
+                canvas.BTN.ctx.lineTo(pin.x + pin.w/2 , rect.y + 10);
+                canvas.BTN.ctx.lineTo(pin.x + pin.w/2 , pin.y);
+                canvas.BTN.ctx.strokeStyle = pin.color;
+                canvas.BTN.ctx.lineWidth = 2;
+                canvas.BTN.ctx.stroke();
+            };
+
+            wire.analog = function(pin, probe){
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(probe.x + 75, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 140, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 140, pin.y + pin.h/2);
+                canvas.BTN.ctx.lineTo(pin.x + pin.w/2, pin.y + pin.h/2);
+                canvas.BTN.ctx.lineWidth = 2;
+                canvas.BTN.ctx.strokeStyle = pin.color;
+                canvas.BTN.ctx.stroke();
+            };
+
+            wire.digital = function(pin, probe){
+                canvas.BTN.ctx.beginPath();
+                if (pin.subType == "input") { var s = -2; }
+                else if (pin.subType == "output") { var s = -6; }
+                else { var s = -4; }
+                canvas.BTN.ctx.strokeStyle = pin.color;
+                canvas.BTN.ctx.moveTo(probe.x + 75, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 141 + s, probe.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(rectInner.w - 141 + s, pin.y + pin.h/2);
+                canvas.BTN.ctx.lineTo(pin.x + pin.w/2, pin.y + pin.h/2);
+                canvas.BTN.ctx.lineWidth = 2;
+                canvas.BTN.ctx.stroke();
+            };
+
+            wire.link = function(btn1,btn2){
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(btn1.endX/2 + 15, btn1.y + btnHeight);
+                canvas.BTN.ctx.lineTo(btn1.endX/2 + 15, btn2.y + btnHeight*0.5);
+                canvas.BTN.ctx.lineTo(btn2.x, btn2.y + btnHeight*0.5);
+                canvas.BTN.ctx.strokeStyle = 'rgb(0,153,110)';
+                canvas.BTN.ctx.lineWidth = 2;
+                canvas.BTN.ctx.stroke();
+            };
+
+            wire.drawToGraph = function(pin){
+                canvas.BTN.ctx.beginPath();
+                canvas.BTN.ctx.moveTo(rectInner.w + 40, graphLinePos);
+                canvas.BTN.ctx.lineTo(rectInner.w + 70, graphLinePos);
+                canvas.BTN.ctx.strokeStyle = pin.color;
+                canvas.BTN.ctx.lineWidth = 2;
+                canvas.BTN.ctx.stroke();
+                graphLinePos += 4;
+            };
+
+            return wire;
+        })();
+
         ui.pin = (function() {
             var pin = {};
             var pins = [
@@ -754,6 +1170,7 @@ var UI = (function() {
                 pins[i].w = 5;
                 pins[i].h = 5;
                 pins[i].s = 18;
+                pins[i].select = "off";
             }
             for (var i = 92; i < 96; i++) {
                 // var LEDpositions = [230.5, 241.75, 253, 264.25];
@@ -763,24 +1180,55 @@ var UI = (function() {
                 pins[i].w = 5;
                 pins[i].h = 10;
                 pins[i].s = 18;
+                pins[i].select = "off";
             }
 
-            pin.highlight = function(button) {
+            pin.highlight = function(button, digitalHighlight) {
+                //the related pins for digital buttons is true by Default, except for hoverButton event.
+                if (digitalHighlight == undefined){
+                    digitalHighlight = true;
+                }
                 if (button == "none") return;
+
                 var category = button;
                 var pwm = false;
-                if (category == "input") category = "digital";
-                if (category == "output") category = "digital";
+                if (category == "input" && digitalHighlight == true) category = "digital";
+                if (category == "output" && digitalHighlight == true) category = "digital";
+                
                 for (var i = 0; i < 96; i++) {
-                    if (category == "pwm") pwm = pins[i].PWM;
+                    if (category == "pwm" && digitalHighlight == true) pwm = pins[i].PWM;
                     if (category == pins[i].category || pwm) {
                         var p = pins[i];
-                        canvas.Active.ctx.fillStyle = 'RGBA(255,255,255,0.5)';
-                        canvas.Active.ctx.fillRect(p.x, p.y, p.w, p.h);
+                        if (p.select !== "on") {
+                            canvas.Active.ctx.fillStyle = 'RGBA(255,255,255,0.5)';
+                            canvas.Active.ctx.fillRect(p.x, p.y, p.w, p.h);
+                            canvas.Active.ctx.save();
+                        }
                     }
                 }
             };
 
+            //change the pin color to light grey on hivering
+            pin.hover = function(pin) {
+                Canvas.get().Active.ctx.fillStyle = 'RGBA(255,255,255,.5)';
+                Canvas.get().Active.ctx.fillRect(pin.x,pin.y,pin.w,pin.h);
+            }
+
+            pin.test = function(event) {
+                var coords = Position(event);
+                var x = coords[0];
+                var y = coords[1];
+
+                for (var p in pins) {
+                    if (x >= pins[p].x && x <= pins[p].x + pins[p].w && y >= pins[p].y && 
+                        y <= pins[p].y + pins[p].h) {
+                        //console.log("pin = " + pins[p].name);
+                        return pins[p];
+                    }
+                }
+                return ("none");
+            };
+
             return pin;
         })();
 
@@ -792,10 +1240,15 @@ var UI = (function() {
             var add = {};
             add.type = 'none';
 
+            probe.push = function(button) {
+                probes.push(button);
+            };
+
             probe.addStart = function(type) {
                 add.type = type;
             };
 
+            //add new probe not the button object
             probe.addTest = function(event) {
                 if (add.type == 'none') return ('none');
                 var coords = Position(event);
@@ -806,11 +1259,10 @@ var UI = (function() {
                     return ('cancelled');
                 }
                 ui.button.push(add.type);
-                ui.button.draw(add.type, canvas.Active.ctx, true);
-                add.type = 'none';
-                return ('selectPin');
+                return ('hoverPin');
             };
 
+            //draw a button while dragging, and keep it highlighted.
             probe.dragButton = function(event) {
                 ui.loop.clear();
                 var coords = Position(event);
@@ -820,15 +1272,51 @@ var UI = (function() {
                 ui.pin.highlight(add.type);
             };
 
+            //clears the duplicate button after dragging button to graph.
+            probe.clearDrag = function(event) {
+                var coords = Position(event);
+                var x = coords[0] - 50;
+                var y = coords[1] - 7.5;
+                canvas.Active.ctx.clearRect(x-1,y-1,ui.button.get()[add.type].endX,ui.button.get()[add.type].endY);
+                canvas.Active.ctx.save();
+            };
+
+            probe.selectText = function(){
+                canvas.Active.ctx.fillStyle= 'red';
+                canvas.Active.ctx.font = '12pt Andale Mono';
+                canvas.Active.ctx.fillText("select " + ui.button.get()[add.type].article, BBposX + 10, BBposY-25);
+                canvas.Active.ctx.save();
+
+                add.type = 'none';
+            };
+
             probe.add = function(pin) {
-                canvas.add(pin.id, 10);
-                ui.graph.add(pin.id, 10);
+                ui.graph.add(pin.name);
             };
 
             probe.onOffTest = function(event) {
 
             };
 
+            probe.test = function(event) {
+                var coords = Position(event);
+                var x = coords[0];
+                var y = coords[1];
+                var buttons = ui.button.get();
+
+                for (var b in buttons) {
+                    var minX = buttons[b].x;
+                    var minY = buttons[b].y;
+                    var maxX = buttons[b].endX;
+                    var maxY = buttons[b].endY;
+                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
+                        return buttons[b].name;
+                    }
+                }
+
+                return ("none");
+            };
+
             return probe;
         })();
 
@@ -839,6 +1327,16 @@ var UI = (function() {
                 canvas.Active.ctx.clearRect(0, 0, canvas.Active.e.width, canvas.Active.e.height);
             };
 
+            //to remove probe if not connected to pin.
+            loop.clearProbe = function() {
+                var btn = ui.button.pop();
+                canvas.Base.ctx.clearRect(btn.x-1, btn.y-1, btn.endX, btn.endY);
+            };
+
+            loop.clearBB = function() {
+                canvas.Active.ctx.clearRect(283, 120, canvas.Active.e.width, canvas.Active.e.height);
+            };
+
             loop.welcome = function(button) {
                 var color = (button == 'exit') ? 'black' : 'white';
                 var ctx = canvas.Active.ctx;
@@ -847,22 +1345,22 @@ var UI = (function() {
                 ctx.fillStyle = 'rgba(255,255,255,0.5)';
                 ctx.fillRect(0, 0, width, height);
                 ctx.fillStyle = 'rgba(0,102,204,0.85)';
-                ctx.fillRect(width / 6, height / 4, width / 1.5, height / 2);
+                ctx.fillRect(width / 3.75, height / 4, width / 1.8, height / 2.85);
                 ctx.fillStyle = color;
-                ctx.font = '12pt Andale Mono';
-                ctx.fillText('X', width * 6 / 7.2 - 20, height / 4 + 20);
+                ctx.font = '12pt Arial';
+                ctx.fillText('X', width / 2 + 250, height / 4 + 25);
                 ctx.fillStyle = 'white';
-                ctx.font = '13pt Andale Mono';
-                ctx.fillText('Welcome to the beaglebone user interface!', width / 6 + 20, height / 4 + 25);
-                ctx.font = '10pt Andale Mono';
-                ctx.fillText('This interface allows you to play with analog to digital converters,', width / 6 + 25, height / 4 + 55);
-                ctx.fillText('digital pins (including inputs, outputs, and pwms), and the user leds', width / 6 + 25, height / 4 + 70);
-                ctx.fillText('located at the top of the board. Hovering over the buttons indicates', width / 6 + 25, height / 4 + 85);
-                ctx.fillText('which pins correspond to what type. Click and drag the button within', width / 6 + 25, height / 4 + 100);
-                ctx.fillText('the white rectangle and select a pin. The input button requires both an', width / 6 + 25, height / 4 + 115);
-                ctx.fillText('input and an output. The graph to the right will display the voltage', width / 6 + 25, height / 4 + 130);
-                ctx.fillText('of the corresponding pin. Use the zoom in or zoom out to alter the graph,', width / 6 + 25, height / 4 + 145);
-                ctx.fillText('stop to stop recording voltages, and play again to reset. Enjoy!', width / 6 + 25, height / 4 + 160);
+                ctx.font = '14pt Arial';
+                ctx.fillText('Welcome to the beaglebone user interface!', width / 3.75 + 20, height / 4 + 30);
+                ctx.font = '10pt Arial';
+                ctx.fillText('This interface allows you to play with analog to digital converters,', width / 3.75 + 25, height / 4 + 55);
+                ctx.fillText('digital pins (including inputs, outputs, and pwms), and the user leds', width / 3.75 + 25, height / 4 + 70);
+                ctx.fillText('located at the top of the board. Hovering over the buttons indicates', width / 3.75 + 25, height / 4 + 85);
+                ctx.fillText('which pins correspond to what type. Click and drag the button within', width / 3.75 + 25, height / 4 + 100);
+                ctx.fillText('the white rectangle and select a pin. The input button requires both an', width / 3.75 + 25, height / 4 + 115);
+                ctx.fillText('input and an output. The graph to the right will display the voltage', width / 3.75 + 25, height / 4 + 130);
+                ctx.fillText('of the corresponding pin. Use the zoom in or zoom out to alter the graph,', width / 3.75 + 25, height / 4 + 145);
+                ctx.fillText('stop to stop recording voltages, and play again to reset. Enjoy!', width / 3.75 + 25, height / 4 + 160);
             };
 
             loop.clear();
@@ -877,7 +1375,6 @@ var UI = (function() {
             beagleBone.src = base_url + '/static/images/beaglebone.png';
             beagleBone.onload = function() {
                 canvas.Base.ctx.drawImage(beagleBone, BBposX, BBposY, beagleBone.width * 0.65, beagleBone.height * 0.65);
-
             };
 
             return base;
@@ -902,13 +1399,132 @@ var UI = (function() {
             //drawButtons(canvas, uiElements);
 
             graph.add = function(pin) {
-                canvas.add(pin.id + 'Graph', 10);
+                Canvas.add(pin + ' Graph', 10);
 
             };
 
             return graph;
         })();
 
+        // time & volt axis
+        ui.xyAxis = (function() {
+            var xyAxis = {};
+
+            //all graph properties
+            var graph = {
+                xWidth: 360,
+                yWidth: 250,
+                zeroX: axisStartX,
+                zeroY: axisStartY + 160,
+                interval: 0,
+                zoomVal: [.125, .25, .5, 1],
+                zoomIndex: 3,
+                zoom: function() {
+                    return this.zoomVal[this.zoomIndex];
+                }
+            }
+
+            // time-x axis
+            canvas.Graph.ctx.beginPath();
+            canvas.Graph.ctx.moveTo(graph.zeroX, graph.zeroY);
+            canvas.Graph.ctx.lineTo(graph.zeroX + graph.xWidth, graph.zeroY);
+            canvas.Graph.ctx.strokeStyle = "#354b60";
+            canvas.Graph.ctx.lineWidth = 2;
+            canvas.Graph.ctx.stroke();
+            canvas.Graph.ctx.strokeStyle = "black";
+            canvas.Graph.ctx.font = '10pt Lucinda Grande';
+            canvas.Graph.ctx.fillText('Time [s]', axisStartX + 130, graph.zeroY + 50);
+            canvas.Graph.ctx.save();
+
+            // voltage-y axis
+            canvas.Graph.ctx.beginPath();
+            canvas.Graph.ctx.moveTo(graph.zeroX, graph.zeroY + 5);
+            canvas.Graph.ctx.lineTo(graph.zeroX, graph.zeroY - graph.yWidth -10);
+            canvas.Graph.ctx.strokeStyle = "black";
+            canvas.Graph.ctx.lineWidth = 2;
+            canvas.Graph.ctx.stroke();
+            canvas.Graph.ctx.save();
+
+            canvas.Graph.ctx.strokeStyle = "black";
+            canvas.Graph.ctx.font = '10pt Lucinda Grande';
+            canvas.Graph.ctx.fillText('Voltage [v]', graph.zeroX - 30, graph.zeroY - graph.yWidth - 20);
+            
+            //x ticks
+            var x = 0;
+            var countX = 0;
+            var xnum = 95;
+            var time = 1;
+            var prec = Math.ceil(Math.log(Math.abs(graph.interval) / 100 + 1.1) / Math.LN10) + 1;
+            canvas.Graph.ctx.strokeStyle = "black";
+            while (x <= graph.xWidth + graph.interval) {
+                if (graph.zeroX + x - graph.interval >= graph.zeroX) {
+                    if (countX % 10 === 0) {
+                        canvas.Graph.ctx.beginPath();
+                        canvas.Graph.ctx.moveTo(graph.zeroX + x - graph.interval, graph.zeroY - 5);
+                        canvas.Graph.ctx.lineTo(graph.zeroX + x - graph.interval, graph.zeroY + 10);
+                        canvas.Graph.ctx.lineWidth = 2;
+                        canvas.Graph.ctx.stroke();
+                    } else {
+                        canvas.Graph.ctx.beginPath();
+                        canvas.Graph.ctx.moveTo(graph.zeroX + x - graph.interval, graph.zeroY - 5);
+                        canvas.Graph.ctx.lineTo(graph.zeroX + x - graph.interval, graph.zeroY + 5);
+                        canvas.Graph.ctx.lineWidth = 2;
+                        canvas.Graph.ctx.stroke();
+                    }
+                }
+                x += 10;
+                countX += 1;
+            }
+            canvas.Graph.ctx.fillStyle = "black";
+            canvas.Graph.ctx.font = '8pt Lucinda Grande';
+            while (xnum <=  graph.xWidth + graph.interval) {
+                if (axisStartX + xnum - graph.interval >= graph.zeroX) {
+                    canvas.Graph.ctx.fillText(time.toPrecision(prec).toString(),
+                        axisStartX + xnum - graph.interval, graph.zeroY + 20);
+                }
+                xnum += 100;
+                time = (xnum + 3) / 100;
+
+            }
+
+            //y ticks
+            var y = 0;
+            var countY = 5;
+            var ynum = 0;
+            var volt = 5;
+            var text;
+            while (y <= graph.yWidth) {
+                if (countY % 5 === 0) {
+                    canvas.Graph.ctx.beginPath();
+                    canvas.Graph.ctx.moveTo(graph.zeroX - 10, graph.zeroY - y);
+                    canvas.Graph.ctx.lineTo(graph.zeroX + 5, graph.zeroY - y);
+                    canvas.Graph.ctx.lineWidth = 2;
+                    canvas.Graph.ctx.stroke();
+                } else {
+                    canvas.Graph.ctx.beginPath();
+                    canvas.Graph.ctx.moveTo(graph.zeroX - 5, graph.zeroY - y);
+                    canvas.Graph.ctx.lineTo(graph.zeroX + 5, graph.zeroY - y);
+                    canvas.Graph.ctx.lineWidth = 2;
+                    canvas.Graph.ctx.stroke();
+                }
+                y += 10;
+                countY += 1;
+            };
+            canvas.Graph.ctx.fillStyle = "black";
+            canvas.Graph.ctx.font = '8pt Lucinda Grande';
+            while (ynum <= graph.yWidth && volt >= 0) {
+                text = (volt * graph.zoom()).toFixed(1).toString();
+                if (text == "0.0") {
+                    canvas.Graph.ctx.fillText(text.toString(), graph.zeroX - 20, graph.zeroY - graph.yWidth + ynum + 15);
+                } else {
+                    canvas.Graph.ctx.fillText(text.toString(), graph.zeroX - 30, graph.zeroY - graph.yWidth + ynum +2);
+                }
+                ynum += 50;
+                volt -= 1;
+            };
+            return xyAxis;
+        })();
+
         function Position(event) {
             var rect = canvas.Base.e.getBoundingClientRect();
             var coords = [];
@@ -927,7 +1543,7 @@ var UI = (function() {
             coords[1] -= rect.top;
 
             return (coords);
-        }
+        };
 
         return ui;
     } // end of ui's init()
@@ -943,16 +1559,25 @@ var UI = (function() {
     };
 })();
 
+
+/* Events draw in a bit of logic to enable/disable event listeners, so it is stateful.
+*
+* Use 'e.ui' to fetch UI objects
+* New events should be defined with a type and function in events variable
+* refer to state diagram for event sequence at http://jadonk.github.io/bone101/Support/bone101/UI/fsm/
+*
+*/
 var Events = (function() {
     var e;
 
+    //to use any object method inside events
     function init() {
         e = {};
         e.ui = UI.get();
         e.listeners = {};
         e.start = function() {
-            listen(true, 'exit');
-            listen(true, 'exitHover');
+            listen(true, 'clickExit');
+            listen(true, 'hoverExit');
         };
         e.start();
         return e;
@@ -960,33 +1585,33 @@ var Events = (function() {
 
     function listen(enable, description) {
         var events = {
-            'exit': {
+            'clickExit': {
                 event: 'click',
-                func: exit
+                func: clickExit
             },
-            'exitHover': {
+            'hoverExit': {
                 event: 'mousemove',
-                func: exitHover
+                func: hoverExit
             },
-            'activateProbe': {
+            'hoverAddProbe': {
                 event: 'mousemove',
-                func: activateProbe
+                func: hoverAddProbe
             },
-            'digitalMenu': {
+            'hoverDigital': {
                 event: 'mousemove',
-                func: digitalMenu
+                func: hoverDigital
             },
-            'btnInfo': {
+            'hoverButton': {
                 event: 'mousemove',
-                func: btnInfo
+                func: hoverButton
             },
-            'selectPin': {
+            'hoverPin': {
                 event: 'mousemove',
-                func: selectPin
+                func: hoverPin
             },
-            'clicked': {
+            'clickPin': {
                 event: 'click',
-                func: clicked
+                func: clickPin
             },
             'clickDown': {
                 event: 'mousedown',
@@ -996,25 +1621,9 @@ var Events = (function() {
                 event: 'mousedown',
                 func: clickDownDigital
             },
-            'slideBar': {
+            'hoverSlider': {
                 event: 'mousemove',
-                func: slideBar
-            },
-            'zooming': {
-                event: 'mouseup',
-                func: zooming
-            },
-            'stop': {
-                event: 'mouseup',
-                func: stop
-            },
-            'record': {
-                event: 'mouseup',
-                func: record
-            },
-            'pinSelected': {
-                event: 'click',
-                func: pinSelected
+                func: hoverSlider
             },
             'release': {
                 event: 'mouseup',
@@ -1045,99 +1654,98 @@ var Events = (function() {
         else document.removeEventListener(ev, func, false);
     }
 
-    function exit(event) {
+    function clickExit(event) {
         var button = e.ui.button.test(event);
         if (button == "exit") {
             e.ui.loop.clear();
-            listen(false, 'exit');
-            listen(false, 'exitHover');
+            listen(false, 'clickExit');
+            listen(false, 'hoverExit');
             listen(true, 'clickDown');
             listen(true, 'release');
-            listen(true, 'clicked');
-            listen(true, 'btnInfo');
+            listen(true, 'hoverButton');
         }
     }
 
-    function exitHover(event) {
+    function hoverExit(event) {
         var button = e.ui.button.test(event);
-        //console.log("exitHover: button = " + button);
+        //console.log("hoverExit: button = " + button);
         e.ui.loop.clear();
         e.ui.loop.welcome(button);
     }
 
-    function btnInfo(event) {
+    //on button hover, highlight button and coressponding pins.
+    function hoverButton(event) {
         e.ui.loop.clear();
+        //e.ui.pin.test(event);
         var button = e.ui.button.test(event);
         e.ui.button.highlight(button);
-        e.ui.pin.highlight(button);
+        e.ui.pin.highlight(button, false);
         switch (button) {
             case "digital":
-                listen(true, 'digitalMenu');
+                listen(true, 'hoverDigital');
+                listen(true, 'clickDownDigital');
                 break;
             default:
                 break;
         }
     }
 
-    function digitalMenu(event) {
+    function hoverDigital(event) {
         var button = e.ui.button.test(event);
         e.ui.button.highlightDigital(button);
+        e.ui.pin.highlight(button);
         switch (button) {
             case "digital":
             case "input":
             case "output":
             case "pwm":
-                listen(true, 'clickDownDigital');
-                break;
             case "digitalMenu":
                 break;
             default:
-                listen(false, 'digitalMenu');
+                listen(false, 'hoverDigital');
                 listen(false, 'clickDownDigital');
                 break;
         }
     }
 
-    // if click on/off button or pin while active
-    function clicked(event) {
-        //e.ui.probe.addTest(event); ???
-        e.ui.probe.onOffTest(event);
-    }
-
-    // if clicked on global button, slider, or graph button    
+    // if clicked on global button, slider, graph, or probe-on/off button
     function clickDown(event) {
         var button = e.ui.button.test(event);
-        if (button == "none") button = e.ui.probe.sliderTest(event);
+        //if (button == "none") button = e.ui.probe.onOffTest(event);
+        if (button == "none") button = e.ui.bar.sliderTest(event);
         if (button == "none") button = e.ui.graph.test(event);
         switch (button) {
             case "analog":
             case "led":
                 e.ui.probe.addStart(button);
-                listen(true, 'activateProbe');
-                listen(false, 'btnInfo');
+                listen(true, 'hoverAddProbe');
+                listen(false, 'hoverButton');
                 listen(false, 'clickDownDigital');
                 listen(false, 'clickDown');
                 break;
             case "plus":
-                listen(true, 'zooming');
-                e.ui.graph.zoomChange("in");
+                e.ui.state.down = "zooming";
+                //e.ui.graph.zoomChange("in");
                 e.ui.button.highlightPlus();
                 break;
             case "minus":
-                listen(true, 'zooming');
-                e.ui.graph.zoomChange("out");
+                e.ui.state.down = "zooming";
+                //e.ui.graph.zoomChange("out");
                 e.ui.button.highlightMinus();
                 break;
             case "stop":
-                listen(true, 'stop');
+                e.ui.state.down = "stop";
                 e.ui.button.highlightStop();
                 break;
             case "play":
-                listen(true, 'record');
+                e.ui.state.down = "play";
                 e.ui.button.highlightPlay();
                 break;
             case "slider":
-                listen(true, 'slideBar');
+                //e.ui.state.down = "slider";
+                listen(true, 'hoverSlider');
+                break;
+            case "onOff":
                 break;
             default:
                 break;
@@ -1151,56 +1759,193 @@ var Events = (function() {
             case "output":
             case "pwm":
                 e.ui.probe.addStart(button);
-                listen(true, 'activateProbe');
-                listen(false, 'btnInfo');
+                listen(true, 'hoverAddProbe');
+                listen(false, 'hoverButton');
                 listen(false, 'clickDownDigital');
                 listen(false, 'clickDown');
                 break;
             default:
                 break;
         }
-        listen(false, 'digitalMenu');
+        listen(false, 'hoverDigital');
     }
 
-    function activateProbe(event) {
+    //drawing a button instance while dragging it to the graph
+    function hoverAddProbe(event) {
         e.ui.probe.dragButton(event);
     }
 
-    function slideBar(event) {
+    function release(event) {
+        var probeMode = e.ui.probe.addTest(event);
 
-    }
+        if (probeMode == 'hoverPin') {
+            e.ui.probe.clearDrag(event);
+            listen(false, 'hoverAddProbe');
+            listen(true, 'hoverPin');
+            e.ui.probe.selectText();
+            var probe = e.ui.probe.test(event);
+            e.ui.pin.highlight(probe);
+            listen(true, 'clickDown');
+        } else if (probeMode == 'cancelled') {
+            listen(false, 'hoverAddProbe');
+            listen(true, 'hoverButton');
+            listen(true, 'clickDown');
+        }
 
-    function zooming(event) {
+        //e.ui.bar.off();
+        listen(false, 'hoverSlider');
+    }
 
+    function hoverPin(event) {
+        e.ui.loop.clearBB();
+        listen(true, 'clickPin');
+        pin = e.ui.pin.test(event);
+        var probes = Object.keys(e.ui.button.get());
+        probeName = probes[probes.length-16];
+        probe = e.ui.button.get()[probeName];
+        e.ui.pin.highlight(probe.name);
+        probe.category = probe.name;
+        if (probe.name == 'input' || probe.name == 'output') {
+            probe.category = 'digital';
+        }
+        pwm = false;
+        if (probe.name == "pwm") pwm = pin.PWM;
+        if ((pin.category == probe.category || pwm) && pin.select == 'off') {
+            probe.text = pin.name;
+            e.ui.button.draw(probeName, Canvas.get().Active.ctx, false);
+            e.ui.pin.hover(pin);
+        } else {
+            Canvas.get().Active.ctx.clearRect(probe.x, probe.y, probe.endX, probe.endY);
+        }
     }
 
-    function stop(event) {
+    function clickPin(event) {
+        listen(false, 'hoverPin');
+        listen(false, 'clickPin');
+
+        var probes = Object.keys(e.ui.button.get());
+        probeName = probes[probes.length-16];
+        probe = e.ui.button.get()[probeName];
+
+        pin = e.ui.pin.test(event);
+
+        //if pin isn't selected -> clear probe and activate menus
+        if (pin.name === undefined) {
+            if (probe.input !== "on") {
+                e.ui.loop.clearProbe();
+                listen(true, 'hoverButton');
+            }
+            else {
+                listen(true, 'hoverPin');
+                listen(true, 'clickPin');
+            }
+        }
+        //check probe type and draw corresponding objects and wires.
+        else {
+            if (probe.name == "pwm") pwm = pin.PWM;
+            if ((pin.category == probe.category || pwm) && pin.select == 'off') {
+                e.ui.loop.clear();
+                probe.text = pin.name;
+                e.ui.button.draw(probeName, Canvas.get().BTN.ctx, false);
+                e.ui.pin.hover(pin);
+                pin.select = 'on';
+                e.ui.probe.add(pin);
+                probe.pinNum = pin;
+
+                //LEDs
+                if (probe.name === "led" && pin.select == 'on'){
+                    pin.color = probe.graphColors[0];
+                    probe.graphColors.splice(0,1);
+                    e.ui.wire.led(pin, probe); 
+                    e.ui.button.on(probe);
+                    //e.ui.button.off(probe);
+                    e.ui.bar.create(probe, pin);
+                    e.ui.bar.draw();
+                    listen(true, 'hoverButton');
+                }
 
+                //Analog
+                else if (probe.name === "analog" && pin.select == 'on'){
+                    pin.color = probe.graphColors[0];
+                    probe.graphColors.splice(0,1);
+                    e.ui.wire.analog(pin, probe); 
+                    e.ui.button.on(probe);
+                    //e.ui.button.off(probe);
+                    listen(true, 'hoverButton');
+                }
+
+                //Digital
+                else { 
+                    pin.subType = probe.name;
+                    if (probe.name === "input"){
+                        pin.color = probe.graphColors[0];
+                        probe.graphColors.splice(0,1);
+                        e.ui.wire.digital(pin, probe);
+                        e.ui.button.on(probe);
+                        //e.ui.button.off(probe);
+                        e.ui.button.createOutput();
+                        listen(true, 'hoverPin');
+                        listen(true, 'clickPin');
+                    }
+                    else if (probe.name === "output"){
+                        pin.color = probe.graphColors[0];
+                        probe.graphColors.splice(0,1);
+                        e.ui.wire.digital(pin, probe);
+                        //output button for input probe.
+                        if (probe.input === "on"){
+                            listen(true, 'hoverButton');
+                        }
+                        //output probe.
+                        else {
+                            e.ui.button.on(probe); 
+                            pin.input = "none";
+                            e.ui.bar.create(probe, pin);
+                            e.ui.bar.draw();
+                            listen(true, 'hoverButton');
+                        }
+                    }
+                    else {
+                        pin.color = probe.graphColors[0];
+                        probe.graphColors.splice(0,1);
+                        e.ui.wire.digital(pin, probe); 
+                        e.ui.button.on(probe);
+                        //e.ui.button.off(probe);
+                        e.ui.bar.create(probe, pin);
+                        e.ui.bar.draw();
+                        listen(true, 'hoverButton');
+                    }
+                }
+
+                //draw wire line of current probe beside axis graph
+                e.ui.wire.drawToGraph(pin);
+            }
+            //if user select a pin not related to the probe
+            else {
+                if (probe.input !== "on") {
+                    e.ui.loop.clearProbe();
+                    listen(true, 'hoverButton');
+                }
+                else {
+                    listen(true, 'hoverPin');
+                } 
+            }
+        }
     }
 
-    function record(event) {
+    function hoverSlider(event) {
+        e.ui.bar.move(event);
+    }
+
+    function zooming(event) {
 
     }
 
-    function selectPin(event) {}
+    function stop(event) {
 
-    function pinSelected(event) {
-        listen(false, 'selectPin');
-        listen(true, 'btnInfo');
     }
 
-    function release(event) {
-        var probeMode = e.ui.probe.addTest(event);
-        if (probeMode == 'selectPin') {
-            listen(false, 'activateProbe');
-            listen(true, 'selectPin');
-            listen(true, 'pinSelected');
-            listen(true, 'clickDown');
-        } else if (probeMode == 'cancelled') {
-            listen(false, 'activateProbe');
-            listen(true, 'btnInfo');
-            listen(true, 'clickDown');
-        }
+    function record(event) {
+
     }
 
     return {
@@ -1215,4 +1960,4 @@ var Events = (function() {
 
 function bbui() {
     Events.get();
-}
\ No newline at end of file
+}
diff --git a/Support/bone101/UI/fsm/fsmsave.js b/Support/bone101/UI/fsm/fsmsave.js
new file mode 100644
index 0000000..ccdee9e
--- /dev/null
+++ b/Support/bone101/UI/fsm/fsmsave.js
@@ -0,0 +1 @@
+fsmsave={"nodes":[{"x":257,"y":50,"text":"INIT","isAcceptState":false},{"x":315,"y":175,"text":"IDLE","isAcceptState":false},{"x":257,"y":448,"text":"ADD","isAcceptState":false},{"x":529,"y":475,"text":"SEL","isAcceptState":false},{"x":93,"y":255,"text":"DM","isAcceptState":false},{"x":81,"y":87,"text":"","isAcceptState":false},{"x":644,"y":311,"text":"OUT","isAcceptState":false},{"x":359,"y":377,"text":"","isAcceptState":false},{"x":184,"y":671,"text":"cd","isAcceptState":false},{"x":385,"y":671,"text":"SLID","isAcceptState":false},{"x":296,"y":808,"text":"","isAcceptState":false},{"x":179,"y":943,"text":"cd","isAcceptState":false},{"x":103,"y":537,"text":"cd","isAcceptState":false},{"x":395,"y":943,"text":"ZOOM","isAcceptState":false},{"x":293,"y":1044,"text":"","isAcceptState":false},{"x":192,"y":1133,"text":"cd","isAcceptState":false},{"x":398,"y":1134,"text":"STOP","isAcceptState":false},{"x":293,"y":1244,"text":"","isAcceptState":false},{"x":208,"y":1369,"text":"cd","isAcceptState":false},{"x":400,"y":1370,"text":"PLAY","isAcceptState":false},{"x":315,"y":1482,"text":"","isAcceptState":false}],"links":[{"type":"Link","nodeA":0,"nodeB":1,"text":"c(e)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":1,"nodeB":2,"text":"cd(l,a)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"SelfLink","node":1,"text":"h(l,a,p,g)","anchorAngle":-0.8124186125847132},{"type":"Link","nodeA":4,"nodeB":2,"text":"cd(l,a|d)","lineAngleAdjust":0,"parallelPart":0.6085634735495523,"perpendicularPart":0},{"type":"SelfLink","node":0,"text":"h(e)","anchorAngle":0},{"type":"Link","nodeA":1,"nodeB":4,"text":"h(d)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":4,"nodeB":5,"text":"!h(dm)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":5,"nodeB":1,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":2,"nodeB":3,"text":"r(active)","lineAngleAdjust":0,"parallelPart":0.4332137049290642,"perpendicularPart":0},{"type":"Link","nodeA":3,"nodeB":6,"text":"c(pin) & in","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":3,"nodeB":1,"text":"c(pin) & !in","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":6,"nodeB":1,"text":"c(pin)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":2,"nodeB":7,"text":"!r(active)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":7,"nodeB":1,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"SelfLink","node":3,"text":"h(pin)","anchorAngle":0.8478169733934057},{"type":"SelfLink","node":6,"text":"h(pin)","anchorAngle":-1.2847016081485365},{"type":"Link","nodeA":8,"nodeB":9,"text":"cd(slider)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":9,"nodeB":10,"text":"r","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":10,"nodeB":8,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"SelfLink","node":9,"text":"h(slider)","anchorAngle":-0.30923527323084515},{"type":"SelfLink","node":12,"text":"cd(onOff)","anchorAngle":0},{"type":"Link","nodeA":11,"nodeB":13,"text":"cd(in,out)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":13,"nodeB":14,"text":"r","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":14,"nodeB":11,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":15,"nodeB":16,"text":"cd(stop)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":16,"nodeB":17,"text":"r","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":17,"nodeB":15,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":18,"nodeB":19,"text":"cd(play)","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":19,"nodeB":20,"text":"r","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0},{"type":"Link","nodeA":20,"nodeB":18,"text":"","lineAngleAdjust":0,"parallelPart":0.5,"perpendicularPart":0}]};
\ No newline at end of file
diff --git a/Support/bone101/UI/fsm/index.html b/Support/bone101/UI/fsm/index.html
new file mode 100755
index 0000000..1b119de
--- /dev/null
+++ b/Support/bone101/UI/fsm/index.html
@@ -0,0 +1,111 @@
+---
+layout: index
+title: Finite State Machine Designer - by Evan Wallace
+scripts: [ '/static/fsm.js', '/Support/bone101/UI/fsm/fsmsave.js' ]
+style: |
+  div#fsmwrap {
+  	text-align: center;
+  	background: white;
+  	margin: 10px 30px 100px 30px;
+  	font: 14px/18px 'Lucida Grande', 'Segoe UI', sans-serif;
+  }
+  canvas#fsmcanvas {
+  	display: block;
+  	max-width: 750px;
+  	background: white;
+  	border-radius: 20px;
+  	border-style: solid;
+  	border-color: black;
+  	border-width: 3px;
+  	-moz-border-radius: 20px;
+  	margin: 10px auto;
+  }
+  a.fsm {
+  	color: black;
+  }
+  div#fsmdiv {
+  	margin: 30px auto;
+  	text-align: left;
+  	max-width: 800px;
+  }
+  .error {
+  	display: block;
+  	color: red;
+  	font-size: 28px;
+  	line-height: 30px;
+  	padding: 30px;
+  }
+  p {
+  	margin: 30px 0;
+  	line-height: 20px;
+  }
+  .center {
+  	text-align: center;
+  }
+  textarea {
+  	display: none;
+  	width: 75%;
+  	height: 400px;
+  	margin: 0 auto;
+  }
+---
+<script>
+/*
+ * base64.js - Base64 encoding and decoding functions
+ *
+ * See: http://developer.mozilla.org/en/docs/DOM:window.btoa
+ *      http://developer.mozilla.org/en/docs/DOM:window.atob
+ *
+ * Copyright (c) 2007, David Lindquist <david.lindquist@gmail.com>
+ * Released under the MIT license
+ */
+
+if (typeof btoa == 'undefined') {
+    function btoa(str) {
+        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
+        var encoded = [];
+        var c = 0;
+        while (c < str.length) {
+            var b0 = str.charCodeAt(c++);
+            var b1 = str.charCodeAt(c++);
+            var b2 = str.charCodeAt(c++);
+            var buf = (b0 << 16) + ((b1 || 0) << 8) + (b2 || 0);
+            var i0 = (buf & (63 << 18)) >> 18;
+            var i1 = (buf & (63 << 12)) >> 12;
+            var i2 = isNaN(b1) ? 64 : (buf & (63 << 6)) >> 6;
+            var i3 = isNaN(b2) ? 64 : (buf & 63);
+            encoded[encoded.length] = chars.charAt(i0);
+            encoded[encoded.length] = chars.charAt(i1);
+            encoded[encoded.length] = chars.charAt(i2);
+            encoded[encoded.length] = chars.charAt(i3);
+        }
+        return encoded.join('');
+    }
+}
+</script>
+<div id="fsmwrap">
+	<h1>Finite State Machine Designer</h1>
+	<canvas id="fsmcanvas" width="750" height="2000">
+		<span class="error">Your browser does not support<br>the HTML5 &lt;canvas&gt; element</span>
+	</canvas>
+	<div id="fsmdiv">
+		<p class="center">Export as: <a class="fsm" href="javascript:saveAsPNG()">PNG</a> | <a class="fsm" href="javascript:saveAsSVG()">SVG</a> | <a class="fsm" href="javascript:saveAsLaTeX()">LaTeX</a> | <a class="fsm" id="fsmjson" href="#" download="fsmsave.js">JS</a></p>
+		<textarea id="output"></textarea>
+		<p>The big white box above is the FSM designer.&nbsp; Here's how to use it:</p>
+		<ul>
+			<li><b>Add a state:</b> double-click on the canvas</li>
+			<li><b>Add an arrow:</b> shift-drag on the canvas</li>
+			<li><b>Move something:</b> drag it around</li>
+			<li><b>Delete something:</b> click it and press the delete key (not the backspace key)</li>
+		</ul><ul>
+			<li><b>Make accept state:</b> double-click on an existing state</li>
+			<li><b>Type numeric subscript:</b> put an underscore before the number (like "S_0")</li>
+			<li><b>Type greek letter:</b> put a backslash before it (like "\beta")</li>
+		</ul>
+		<p>This was made in HTML5 and JavaScript using the canvas element.</p>
+	</div>
+	<p>Created by <a class="fsm" href="http://madebyevan.com/">Evan Wallace</a> in 2010</p>
+</div>
+<script>
+fsmload();
+</script>
diff --git a/Support/script/beagle-ui.js b/Support/script/beagle-ui.js
index 35de54c..608bd3b 100644
--- a/Support/script/beagle-ui.js
+++ b/Support/script/beagle-ui.js
@@ -1,4 +1,5 @@
 serverBasePath = typeof serverBasePath == 'undefined' ? '/bone101/' : serverBasePath;
+var beagleboneIP = window.location.host;
 var name = "#floatMenu";  
 var menuYloc = null;
 var connectState = 'init';
@@ -15,7 +16,7 @@ var ace_editor_id = -1;
 var statusConnected = '' +
     '<div id="connect-status">' +
     '    <div class="browser-connected">' +
-    '        <img alt="Connected" src="' + serverBasePath + 'static/images/green_check.png" border="0">' +
+    '        <img alt="Connected" src="' + serverBasePath + 'static/images/green_check.png" border="0" width="41px" height="41px">' +
     '        <div id="browser-content"><strong>Your board is connected!</strong><br>' +
     '            <div id="board-info"></div> <button onclick="run(ace_editor_id);">Run</button>' +
     '            <button onclick="disconnect();">Disconnect</button>' +
@@ -26,7 +27,7 @@ var handlers = {};
 function oninput(e) {
     if(e.which == 10 || e.which == 13) {
         var givenAddress = $('#connect-ip').val();
-        setTargetAddress(givenAddress, handlers);
+        connectTarget(givenAddress, handlers);
     }
 }
 
@@ -47,11 +48,17 @@ $(document).ready(function(){
     }
 });  
 
-$(document).ready(function(){
+function updateURLs() {
     $('.cloud9-url').each(function() {
-        this.href = 'http://' + window.location.host + ':3000';
+        this.href = 'http://' + beagleboneIP + ':3000';
     });
-});
+
+    $('.node-red-url').each(function() {
+        this.href = 'http://' + beagleboneIP + ':1880';
+    });
+}
+
+$(document).ready(updateURLs);
 
 $(function() {
     if($('#accordian').length) {
@@ -79,7 +86,7 @@ $(document).ready(function(){
         $('#connect-status').replaceWith(statusDisconnected);
         $('#connect-ip').keypress(oninput);
 
-	// note, due to a bug in Firefox, the call is moved below
+    // note, due to a bug in Firefox, the call is moved below
 
         function testForConnection() {
             handlers.callback = callback;
@@ -91,24 +98,24 @@ $(document).ready(function(){
             handlers.connect = connected;
             handlers.reconnect = connected;
             handlers.reconnecting = connected;
-            
+
             setTimeout(tryWindowHost, 5);
             setTimeout(try192, 5);
             setTimeout(tryLocal, 5);
-            
+
             function tryWindowHost() {
-                setTargetAddress(window.location.host, handlers);
+                connectTarget(window.location.host, handlers);
             }
             function try192() {
-                setTargetAddress('192.168.7.2', handlers);
+                connectTarget('192.168.7.2', handlers);
             }
             function tryLocal() {
-                setTargetAddress('beaglebone.local', handlers);
+                connectTarget('beaglebone.local', handlers);
             }
 
             function callback() {
             }
-            
+
             function connected() {
                 if(connectState == 'disconnected') {
                     console.log('Bonescript: connected');
@@ -119,6 +126,8 @@ $(document).ready(function(){
                 console.log('Bonescript: initialized');
                 $('#connect-status').replaceWith(statusConnected);
                 updateBoardInfo();
+                beagleboneIP = _bonescript.address;
+                updateURLs();
                 if(typeof onbonescriptinit == 'function') onbonescriptinit();
                 connectState = 'connected';
             }
@@ -248,7 +257,48 @@ function _onSocketIOLoaded_workaround() {
             socket.emit('shell', command);
         }
         
-	// Call-back initialized function
-	_bonescript.on.initialized();
+    // Call-back initialized function
+    _bonescript.on.initialized();
+    }
+}
+
+function connectTarget(address, handlers, onerror) {
+    var url = address;
+    url = url.replace(/^(http:\/\/|https:\/\/)*/, 'http://');
+    url = url.replace(/(\/)*$/, '/bonescript.js');
+    loadScript(url, addHandlers);
+    function loadScript(url, onload) {
+        try {
+            var head = document.getElementsByTagName('head')[0];
+            var script = document.createElement('script');
+            script.type = 'text/javascript';
+            script.src = url;
+            script.charset = 'UTF-8';
+            var scriptObj = head.appendChild(script);
+            if(onerror) {
+                scriptObj.addEventListener('error', onerror);
+            }
+            scriptObj.onload = onload;
+        } catch(ex) {
+            if(onerror) onerror(ex);
+        }
+    }
+    function addHandlers() {
+        if(typeof handlers == 'function') {
+            handlers();
+            return;
+        }
+        if(typeof _bonescript != 'undefined') {
+            _bonescript.address = address;
+            if(handlers.initialized) _bonescript.on.initialized = handlers.initialized;
+            if(handlers.connect) _bonescript.on.connect = handlers.connect;
+            if(handlers.connecting) _bonescript.on.connecting = handlers.connecting;
+            if(handlers.disconnect) _bonescript.on.disconnect = handlers.disconnect;
+            if(handlers.connect_failed) _bonescript.on.connect_failed = handlers.connect_failed;
+            if(handlers.reconnect_failed) _bonescript.on.reconnect_failed = handlers.reconnect_failed;
+            if(handlers.reconnect) _bonescript.on.reconnect = handlers.reconnect;
+            if(handlers.reconnecting) _bonescript.on.reconnecting = handlers.reconnecting;
+        }
+        if(typeof handlers.callback == 'function') handlers.callback();
     }
 }
diff --git a/_includes/side_menu.html b/_includes/side_menu.html
index 6c90406..a8ffa69 100644
--- a/_includes/side_menu.html
+++ b/_includes/side_menu.html
@@ -1,6 +1,6 @@
 <h2>{{ include.title }}</h2>
 <div id='side-menu' class="t3_sidebar">
     <ul class="left-menu"><strong>Navigation</strong>
-        <li>Menu contents</li>
+        <li><a href="{{ site.baseurl }}/Support/BoneScript/menu/index.html">Menu contents</a></li>
     </ul>
 </div>
diff --git a/static/fsm.js b/static/fsm.js
new file mode 100644
index 0000000..91c64fb
--- /dev/null
+++ b/static/fsm.js
@@ -0,0 +1,1114 @@
+/*
+ Finite State Machine Designer (http://madebyevan.com/fsm/)
+ License: MIT License (see below)
+
+ Copyright (c) 2010 Evan Wallace
+
+ Permission is hereby granted, free of charge, to any person
+ obtaining a copy of this software and associated documentation
+ files (the "Software"), to deal in the Software without
+ restriction, including without limitation the rights to use,
+ copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the
+ Software is furnished to do so, subject to the following
+ conditions:
+
+ The above copyright notice and this permission notice shall be
+ included in all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+function Link(a, b) {
+	this.nodeA = a;
+	this.nodeB = b;
+	this.text = '';
+	this.lineAngleAdjust = 0; // value to add to textAngle when link is straight line
+
+	// make anchor point relative to the locations of nodeA and nodeB
+	this.parallelPart = 0.5; // percentage from nodeA to nodeB
+	this.perpendicularPart = 0; // pixels from line between nodeA and nodeB
+}
+
+Link.prototype.getAnchorPoint = function() {
+	var dx = this.nodeB.x - this.nodeA.x;
+	var dy = this.nodeB.y - this.nodeA.y;
+	var scale = Math.sqrt(dx * dx + dy * dy);
+	return {
+		'x': this.nodeA.x + dx * this.parallelPart - dy * this.perpendicularPart / scale,
+		'y': this.nodeA.y + dy * this.parallelPart + dx * this.perpendicularPart / scale
+	};
+};
+
+Link.prototype.setAnchorPoint = function(x, y) {
+	var dx = this.nodeB.x - this.nodeA.x;
+	var dy = this.nodeB.y - this.nodeA.y;
+	var scale = Math.sqrt(dx * dx + dy * dy);
+	this.parallelPart = (dx * (x - this.nodeA.x) + dy * (y - this.nodeA.y)) / (scale * scale);
+	this.perpendicularPart = (dx * (y - this.nodeA.y) - dy * (x - this.nodeA.x)) / scale;
+	// snap to a straight line
+	if(this.parallelPart > 0 && this.parallelPart < 1 && Math.abs(this.perpendicularPart) < snapToPadding) {
+		this.lineAngleAdjust = (this.perpendicularPart < 0) * Math.PI;
+		this.perpendicularPart = 0;
+	}
+};
+
+Link.prototype.getEndPointsAndCircle = function() {
+	if(this.perpendicularPart == 0) {
+		var midX = (this.nodeA.x + this.nodeB.x) / 2;
+		var midY = (this.nodeA.y + this.nodeB.y) / 2;
+		var start = this.nodeA.closestPointOnCircle(midX, midY);
+		var end = this.nodeB.closestPointOnCircle(midX, midY);
+		return {
+			'hasCircle': false,
+			'startX': start.x,
+			'startY': start.y,
+			'endX': end.x,
+			'endY': end.y,
+		};
+	}
+	var anchor = this.getAnchorPoint();
+	var circle = circleFromThreePoints(this.nodeA.x, this.nodeA.y, this.nodeB.x, this.nodeB.y, anchor.x, anchor.y);
+	var isReversed = (this.perpendicularPart > 0);
+	var reverseScale = isReversed ? 1 : -1;
+	var startAngle = Math.atan2(this.nodeA.y - circle.y, this.nodeA.x - circle.x) - reverseScale * nodeRadius / circle.radius;
+	var endAngle = Math.atan2(this.nodeB.y - circle.y, this.nodeB.x - circle.x) + reverseScale * nodeRadius / circle.radius;
+	var startX = circle.x + circle.radius * Math.cos(startAngle);
+	var startY = circle.y + circle.radius * Math.sin(startAngle);
+	var endX = circle.x + circle.radius * Math.cos(endAngle);
+	var endY = circle.y + circle.radius * Math.sin(endAngle);
+	return {
+		'hasCircle': true,
+		'startX': startX,
+		'startY': startY,
+		'endX': endX,
+		'endY': endY,
+		'startAngle': startAngle,
+		'endAngle': endAngle,
+		'circleX': circle.x,
+		'circleY': circle.y,
+		'circleRadius': circle.radius,
+		'reverseScale': reverseScale,
+		'isReversed': isReversed,
+	};
+};
+
+Link.prototype.draw = function(c) {
+	var stuff = this.getEndPointsAndCircle();
+	// draw arc
+	c.beginPath();
+	if(stuff.hasCircle) {
+		c.arc(stuff.circleX, stuff.circleY, stuff.circleRadius, stuff.startAngle, stuff.endAngle, stuff.isReversed);
+	} else {
+		c.moveTo(stuff.startX, stuff.startY);
+		c.lineTo(stuff.endX, stuff.endY);
+	}
+	c.stroke();
+	// draw the head of the arrow
+	if(stuff.hasCircle) {
+		drawArrow(c, stuff.endX, stuff.endY, stuff.endAngle - stuff.reverseScale * (Math.PI / 2));
+	} else {
+		drawArrow(c, stuff.endX, stuff.endY, Math.atan2(stuff.endY - stuff.startY, stuff.endX - stuff.startX));
+	}
+	// draw the text
+	if(stuff.hasCircle) {
+		var startAngle = stuff.startAngle;
+		var endAngle = stuff.endAngle;
+		if(endAngle < startAngle) {
+			endAngle += Math.PI * 2;
+		}
+		var textAngle = (startAngle + endAngle) / 2 + stuff.isReversed * Math.PI;
+		var textX = stuff.circleX + stuff.circleRadius * Math.cos(textAngle);
+		var textY = stuff.circleY + stuff.circleRadius * Math.sin(textAngle);
+		drawText(c, this.text, textX, textY, textAngle, selectedObject == this);
+	} else {
+		var textX = (stuff.startX + stuff.endX) / 2;
+		var textY = (stuff.startY + stuff.endY) / 2;
+		var textAngle = Math.atan2(stuff.endX - stuff.startX, stuff.startY - stuff.endY);
+		drawText(c, this.text, textX, textY, textAngle + this.lineAngleAdjust, selectedObject == this);
+	}
+};
+
+Link.prototype.containsPoint = function(x, y) {
+	var stuff = this.getEndPointsAndCircle();
+	if(stuff.hasCircle) {
+		var dx = x - stuff.circleX;
+		var dy = y - stuff.circleY;
+		var distance = Math.sqrt(dx*dx + dy*dy) - stuff.circleRadius;
+		if(Math.abs(distance) < hitTargetPadding) {
+			var angle = Math.atan2(dy, dx);
+			var startAngle = stuff.startAngle;
+			var endAngle = stuff.endAngle;
+			if(stuff.isReversed) {
+				var temp = startAngle;
+				startAngle = endAngle;
+				endAngle = temp;
+			}
+			if(endAngle < startAngle) {
+				endAngle += Math.PI * 2;
+			}
+			if(angle < startAngle) {
+				angle += Math.PI * 2;
+			} else if(angle > endAngle) {
+				angle -= Math.PI * 2;
+			}
+			return (angle > startAngle && angle < endAngle);
+		}
+	} else {
+		var dx = stuff.endX - stuff.startX;
+		var dy = stuff.endY - stuff.startY;
+		var length = Math.sqrt(dx*dx + dy*dy);
+		var percent = (dx * (x - stuff.startX) + dy * (y - stuff.startY)) / (length * length);
+		var distance = (dx * (y - stuff.startY) - dy * (x - stuff.startX)) / length;
+		return (percent > 0 && percent < 1 && Math.abs(distance) < hitTargetPadding);
+	}
+	return false;
+};
+
+function Node(x, y) {
+	this.x = x;
+	this.y = y;
+	this.mouseOffsetX = 0;
+	this.mouseOffsetY = 0;
+	this.isAcceptState = false;
+	this.text = '';
+}
+
+Node.prototype.setMouseStart = function(x, y) {
+	this.mouseOffsetX = this.x - x;
+	this.mouseOffsetY = this.y - y;
+};
+
+Node.prototype.setAnchorPoint = function(x, y) {
+	this.x = x + this.mouseOffsetX;
+	this.y = y + this.mouseOffsetY;
+};
+
+Node.prototype.draw = function(c) {
+	// draw the circle
+	c.beginPath();
+	c.arc(this.x, this.y, nodeRadius, 0, 2 * Math.PI, false);
+	c.stroke();
+
+	// draw the text
+	drawText(c, this.text, this.x, this.y, null, selectedObject == this);
+
+	// draw a double circle for an accept state
+	if(this.isAcceptState) {
+		c.beginPath();
+		c.arc(this.x, this.y, nodeRadius - 6, 0, 2 * Math.PI, false);
+		c.stroke();
+	}
+};
+
+Node.prototype.closestPointOnCircle = function(x, y) {
+	var dx = x - this.x;
+	var dy = y - this.y;
+	var scale = Math.sqrt(dx * dx + dy * dy);
+	return {
+		'x': this.x + dx * nodeRadius / scale,
+		'y': this.y + dy * nodeRadius / scale,
+	};
+};
+
+Node.prototype.containsPoint = function(x, y) {
+	return (x - this.x)*(x - this.x) + (y - this.y)*(y - this.y) < nodeRadius*nodeRadius;
+};
+
+function SelfLink(node, mouse) {
+	this.node = node;
+	this.anchorAngle = 0;
+	this.mouseOffsetAngle = 0;
+	this.text = '';
+
+	if(mouse) {
+		this.setAnchorPoint(mouse.x, mouse.y);
+	}
+}
+
+SelfLink.prototype.setMouseStart = function(x, y) {
+	this.mouseOffsetAngle = this.anchorAngle - Math.atan2(y - this.node.y, x - this.node.x);
+};
+
+SelfLink.prototype.setAnchorPoint = function(x, y) {
+	this.anchorAngle = Math.atan2(y - this.node.y, x - this.node.x) + this.mouseOffsetAngle;
+	// snap to 90 degrees
+	var snap = Math.round(this.anchorAngle / (Math.PI / 2)) * (Math.PI / 2);
+	if(Math.abs(this.anchorAngle - snap) < 0.1) this.anchorAngle = snap;
+	// keep in the range -pi to pi so our containsPoint() function always works
+	if(this.anchorAngle < -Math.PI) this.anchorAngle += 2 * Math.PI;
+	if(this.anchorAngle > Math.PI) this.anchorAngle -= 2 * Math.PI;
+};
+
+SelfLink.prototype.getEndPointsAndCircle = function() {
+	var circleX = this.node.x + 1.5 * nodeRadius * Math.cos(this.anchorAngle);
+	var circleY = this.node.y + 1.5 * nodeRadius * Math.sin(this.anchorAngle);
+	var circleRadius = 0.75 * nodeRadius;
+	var startAngle = this.anchorAngle - Math.PI * 0.8;
+	var endAngle = this.anchorAngle + Math.PI * 0.8;
+	var startX = circleX + circleRadius * Math.cos(startAngle);
+	var startY = circleY + circleRadius * Math.sin(startAngle);
+	var endX = circleX + circleRadius * Math.cos(endAngle);
+	var endY = circleY + circleRadius * Math.sin(endAngle);
+	return {
+		'hasCircle': true,
+		'startX': startX,
+		'startY': startY,
+		'endX': endX,
+		'endY': endY,
+		'startAngle': startAngle,
+		'endAngle': endAngle,
+		'circleX': circleX,
+		'circleY': circleY,
+		'circleRadius': circleRadius
+	};
+};
+
+SelfLink.prototype.draw = function(c) {
+	var stuff = this.getEndPointsAndCircle();
+	// draw arc
+	c.beginPath();
+	c.arc(stuff.circleX, stuff.circleY, stuff.circleRadius, stuff.startAngle, stuff.endAngle, false);
+	c.stroke();
+	// draw the text on the loop farthest from the node
+	var textX = stuff.circleX + stuff.circleRadius * Math.cos(this.anchorAngle);
+	var textY = stuff.circleY + stuff.circleRadius * Math.sin(this.anchorAngle);
+	drawText(c, this.text, textX, textY, this.anchorAngle, selectedObject == this);
+	// draw the head of the arrow
+	drawArrow(c, stuff.endX, stuff.endY, stuff.endAngle + Math.PI * 0.4);
+};
+
+SelfLink.prototype.containsPoint = function(x, y) {
+	var stuff = this.getEndPointsAndCircle();
+	var dx = x - stuff.circleX;
+	var dy = y - stuff.circleY;
+	var distance = Math.sqrt(dx*dx + dy*dy) - stuff.circleRadius;
+	return (Math.abs(distance) < hitTargetPadding);
+};
+
+function StartLink(node, start) {
+	this.node = node;
+	this.deltaX = 0;
+	this.deltaY = 0;
+	this.text = '';
+
+	if(start) {
+		this.setAnchorPoint(start.x, start.y);
+	}
+}
+
+StartLink.prototype.setAnchorPoint = function(x, y) {
+	this.deltaX = x - this.node.x;
+	this.deltaY = y - this.node.y;
+
+	if(Math.abs(this.deltaX) < snapToPadding) {
+		this.deltaX = 0;
+	}
+
+	if(Math.abs(this.deltaY) < snapToPadding) {
+		this.deltaY = 0;
+	}
+};
+
+StartLink.prototype.getEndPoints = function() {
+	var startX = this.node.x + this.deltaX;
+	var startY = this.node.y + this.deltaY;
+	var end = this.node.closestPointOnCircle(startX, startY);
+	return {
+		'startX': startX,
+		'startY': startY,
+		'endX': end.x,
+		'endY': end.y,
+	};
+};
+
+StartLink.prototype.draw = function(c) {
+	var stuff = this.getEndPoints();
+
+	// draw the line
+	c.beginPath();
+	c.moveTo(stuff.startX, stuff.startY);
+	c.lineTo(stuff.endX, stuff.endY);
+	c.stroke();
+
+	// draw the text at the end without the arrow
+	var textAngle = Math.atan2(stuff.startY - stuff.endY, stuff.startX - stuff.endX);
+	drawText(c, this.text, stuff.startX, stuff.startY, textAngle, selectedObject == this);
+
+	// draw the head of the arrow
+	drawArrow(c, stuff.endX, stuff.endY, Math.atan2(-this.deltaY, -this.deltaX));
+};
+
+StartLink.prototype.containsPoint = function(x, y) {
+	var stuff = this.getEndPoints();
+	var dx = stuff.endX - stuff.startX;
+	var dy = stuff.endY - stuff.startY;
+	var length = Math.sqrt(dx*dx + dy*dy);
+	var percent = (dx * (x - stuff.startX) + dy * (y - stuff.startY)) / (length * length);
+	var distance = (dx * (y - stuff.startY) - dy * (x - stuff.startX)) / length;
+	return (percent > 0 && percent < 1 && Math.abs(distance) < hitTargetPadding);
+};
+
+function TemporaryLink(from, to) {
+	this.from = from;
+	this.to = to;
+}
+
+TemporaryLink.prototype.draw = function(c) {
+	// draw the line
+	c.beginPath();
+	c.moveTo(this.to.x, this.to.y);
+	c.lineTo(this.from.x, this.from.y);
+	c.stroke();
+
+	// draw the head of the arrow
+	drawArrow(c, this.to.x, this.to.y, Math.atan2(this.to.y - this.from.y, this.to.x - this.from.x));
+};
+
+// draw using this instead of a canvas and call toLaTeX() afterward
+function ExportAsLaTeX() {
+	this._points = [];
+	this._texData = '';
+	this._scale = 0.1; // to convert pixels to document space (TikZ breaks if the numbers get too big, above 500?)
+
+	this.toLaTeX = function() {
+		return '\\documentclass[12pt]{article}\n' +
+			'\\usepackage{tikz}\n' +
+			'\n' +
+			'\\begin{document}\n' +
+			'\n' +
+			'\\begin{center}\n' +
+			'\\begin{tikzpicture}[scale=0.2]\n' +
+			'\\tikzstyle{every node}+=[inner sep=0pt]\n' +
+			this._texData +
+			'\\end{tikzpicture}\n' +
+			'\\end{center}\n' +
+			'\n' +
+			'\\end{document}\n';
+	};
+
+	this.beginPath = function() {
+		this._points = [];
+	};
+	this.arc = function(x, y, radius, startAngle, endAngle, isReversed) {
+		x *= this._scale;
+		y *= this._scale;
+		radius *= this._scale;
+		if(endAngle - startAngle == Math.PI * 2) {
+			this._texData += '\\draw [' + this.strokeStyle + '] (' + fixed(x, 3) + ',' + fixed(-y, 3) + ') circle (' + fixed(radius, 3) + ');\n';
+		} else {
+			if(isReversed) {
+				var temp = startAngle;
+				startAngle = endAngle;
+				endAngle = temp;
+			}
+			if(endAngle < startAngle) {
+				endAngle += Math.PI * 2;
+			}
+			// TikZ needs the angles to be in between -2pi and 2pi or it breaks
+			if(Math.min(startAngle, endAngle) < -2*Math.PI) {
+				startAngle += 2*Math.PI;
+				endAngle += 2*Math.PI;
+			} else if(Math.max(startAngle, endAngle) > 2*Math.PI) {
+				startAngle -= 2*Math.PI;
+				endAngle -= 2*Math.PI;
+			}
+			startAngle = -startAngle;
+			endAngle = -endAngle;
+			this._texData += '\\draw [' + this.strokeStyle + '] (' + fixed(x + radius * Math.cos(startAngle), 3) + ',' + fixed(-y + radius * Math.sin(startAngle), 3) + ') arc (' + fixed(startAngle * 180 / Math.PI, 5) + ':' + fixed(endAngle * 180 / Math.PI, 5) + ':' + fixed(radius, 3) + ');\n';
+		}
+	};
+	this.moveTo = this.lineTo = function(x, y) {
+		x *= this._scale;
+		y *= this._scale;
+		this._points.push({ 'x': x, 'y': y });
+	};
+	this.stroke = function() {
+		if(this._points.length == 0) return;
+		this._texData += '\\draw [' + this.strokeStyle + ']';
+		for(var i = 0; i < this._points.length; i++) {
+			var p = this._points[i];
+			this._texData += (i > 0 ? ' --' : '') + ' (' + fixed(p.x, 2) + ',' + fixed(-p.y, 2) + ')';
+		}
+		this._texData += ';\n';
+	};
+	this.fill = function() {
+		if(this._points.length == 0) return;
+		this._texData += '\\fill [' + this.strokeStyle + ']';
+		for(var i = 0; i < this._points.length; i++) {
+			var p = this._points[i];
+			this._texData += (i > 0 ? ' --' : '') + ' (' + fixed(p.x, 2) + ',' + fixed(-p.y, 2) + ')';
+		}
+		this._texData += ';\n';
+	};
+	this.measureText = function(text) {
+		var c = canvas.getContext('2d');
+		c.font = '20px "Times New Romain", serif';
+		return c.measureText(text);
+	};
+	this.advancedFillText = function(text, originalText, x, y, angleOrNull) {
+		if(text.replace(' ', '').length > 0) {
+			var nodeParams = '';
+			// x and y start off as the center of the text, but will be moved to one side of the box when angleOrNull != null
+			if(angleOrNull != null) {
+				var width = this.measureText(text).width;
+				var dx = Math.cos(angleOrNull);
+				var dy = Math.sin(angleOrNull);
+				if(Math.abs(dx) > Math.abs(dy)) {
+					if(dx > 0) nodeParams = '[right] ', x -= width / 2;
+					else nodeParams = '[left] ', x += width / 2;
+				} else {
+					if(dy > 0) nodeParams = '[below] ', y -= 10;
+					else nodeParams = '[above] ', y += 10;
+				}
+			}
+			x *= this._scale;
+			y *= this._scale;
+			this._texData += '\\draw (' + fixed(x, 2) + ',' + fixed(-y, 2) + ') node ' + nodeParams + '{$' + originalText.replace(/ /g, '\\mbox{ }') + '$};\n';
+		}
+	};
+
+	this.translate = this.save = this.restore = this.clearRect = function(){};
+}
+
+// draw using this instead of a canvas and call toSVG() afterward
+function ExportAsSVG() {
+	this.fillStyle = 'black';
+	this.strokeStyle = 'black';
+	this.lineWidth = 1;
+	this.font = '12px Arial, sans-serif';
+	this._points = [];
+	this._svgData = '';
+	this._transX = 0;
+	this._transY = 0;
+
+	this.toSVG = function() {
+		return '<?xml version="1.0" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n\n<svg width="800" height="600" version="1.1" xmlns="http://www.w3.org/2000/svg">\n' + this._svgData + '</svg>\n';
+	};
+
+	this.beginPath = function() {
+		this._points = [];
+	};
+	this.arc = function(x, y, radius, startAngle, endAngle, isReversed) {
+		x += this._transX;
+		y += this._transY;
+		var style = 'stroke="' + this.strokeStyle + '" stroke-width="' + this.lineWidth + '" fill="none"';
+
+		if(endAngle - startAngle == Math.PI * 2) {
+			this._svgData += '\t<ellipse ' + style + ' cx="' + fixed(x, 3) + '" cy="' + fixed(y, 3) + '" rx="' + fixed(radius, 3) + '" ry="' + fixed(radius, 3) + '"/>\n';
+		} else {
+			if(isReversed) {
+				var temp = startAngle;
+				startAngle = endAngle;
+				endAngle = temp;
+			}
+
+			if(endAngle < startAngle) {
+				endAngle += Math.PI * 2;
+			}
+
+			var startX = x + radius * Math.cos(startAngle);
+			var startY = y + radius * Math.sin(startAngle);
+			var endX = x + radius * Math.cos(endAngle);
+			var endY = y + radius * Math.sin(endAngle);
+			var useGreaterThan180 = (Math.abs(endAngle - startAngle) > Math.PI);
+			var goInPositiveDirection = 1;
+
+			this._svgData += '\t<path ' + style + ' d="';
+			this._svgData += 'M ' + fixed(startX, 3) + ',' + fixed(startY, 3) + ' '; // startPoint(startX, startY)
+			this._svgData += 'A ' + fixed(radius, 3) + ',' + fixed(radius, 3) + ' '; // radii(radius, radius)
+			this._svgData += '0 '; // value of 0 means perfect circle, others mean ellipse
+			this._svgData += +useGreaterThan180 + ' ';
+			this._svgData += +goInPositiveDirection + ' ';
+			this._svgData += fixed(endX, 3) + ',' + fixed(endY, 3); // endPoint(endX, endY)
+			this._svgData += '"/>\n';
+		}
+	};
+	this.moveTo = this.lineTo = function(x, y) {
+		x += this._transX;
+		y += this._transY;
+		this._points.push({ 'x': x, 'y': y });
+	};
+	this.stroke = function() {
+		if(this._points.length == 0) return;
+		this._svgData += '\t<polygon stroke="' + this.strokeStyle + '" stroke-width="' + this.lineWidth + '" points="';
+		for(var i = 0; i < this._points.length; i++) {
+			this._svgData += (i > 0 ? ' ' : '') + fixed(this._points[i].x, 3) + ',' + fixed(this._points[i].y, 3);
+		}
+		this._svgData += '"/>\n';
+	};
+	this.fill = function() {
+		if(this._points.length == 0) return;
+		this._svgData += '\t<polygon fill="' + this.fillStyle + '" stroke-width="' + this.lineWidth + '" points="';
+		for(var i = 0; i < this._points.length; i++) {
+			this._svgData += (i > 0 ? ' ' : '') + fixed(this._points[i].x, 3) + ',' + fixed(this._points[i].y, 3);
+		}
+		this._svgData += '"/>\n';
+	};
+	this.measureText = function(text) {
+		var c = canvas.getContext('2d');
+		c.font = '20px "Times New Romain", serif';
+		return c.measureText(text);
+	};
+	this.fillText = function(text, x, y) {
+		x += this._transX;
+		y += this._transY;
+		if(text.replace(' ', '').length > 0) {
+			this._svgData += '\t<text x="' + fixed(x, 3) + '" y="' + fixed(y, 3) + '" font-family="Times New Roman" font-size="20">' + textToXML(text) + '</text>\n';
+		}
+	};
+	this.translate = function(x, y) {
+		this._transX = x;
+		this._transY = y;
+	};
+
+	this.save = this.restore = this.clearRect = function(){};
+}
+
+var greekLetterNames = [ 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega' ];
+
+function convertLatexShortcuts(text) {
+	// html greek characters
+	for(var i = 0; i < greekLetterNames.length; i++) {
+		var name = greekLetterNames[i];
+		text = text.replace(new RegExp('\\\\' + name, 'g'), String.fromCharCode(913 + i + (i > 16)));
+		text = text.replace(new RegExp('\\\\' + name.toLowerCase(), 'g'), String.fromCharCode(945 + i + (i > 16)));
+	}
+
+	// subscripts
+	for(var i = 0; i < 10; i++) {
+		text = text.replace(new RegExp('_' + i, 'g'), String.fromCharCode(8320 + i));
+	}
+
+	return text;
+}
+
+function textToXML(text) {
+	text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
+	var result = '';
+	for(var i = 0; i < text.length; i++) {
+		var c = text.charCodeAt(i);
+		if(c >= 0x20 && c <= 0x7E) {
+			result += text[i];
+		} else {
+			result += '&#' + c + ';';
+		}
+	}
+	return result;
+}
+
+function drawArrow(c, x, y, angle) {
+	var dx = Math.cos(angle);
+	var dy = Math.sin(angle);
+	c.beginPath();
+	c.moveTo(x, y);
+	c.lineTo(x - 8 * dx + 5 * dy, y - 8 * dy - 5 * dx);
+	c.lineTo(x - 8 * dx - 5 * dy, y - 8 * dy + 5 * dx);
+	c.fill();
+}
+
+function canvasHasFocus() {
+	return (document.activeElement || document.body) == document.body;
+}
+
+function drawText(c, originalText, x, y, angleOrNull, isSelected) {
+	text = convertLatexShortcuts(originalText);
+	c.font = '20px "Times New Roman", serif';
+	var width = c.measureText(text).width;
+
+	// center the text
+	x -= width / 2;
+
+	// position the text intelligently if given an angle
+	if(angleOrNull != null) {
+		var cos = Math.cos(angleOrNull);
+		var sin = Math.sin(angleOrNull);
+		var cornerPointX = (width / 2 + 5) * (cos > 0 ? 1 : -1);
+		var cornerPointY = (10 + 5) * (sin > 0 ? 1 : -1);
+		var slide = sin * Math.pow(Math.abs(sin), 40) * cornerPointX - cos * Math.pow(Math.abs(cos), 10) * cornerPointY;
+		x += cornerPointX - sin * slide;
+		y += cornerPointY + cos * slide;
+	}
+
+	// draw text and caret (round the coordinates so the caret falls on a pixel)
+	if('advancedFillText' in c) {
+		c.advancedFillText(text, originalText, x + width / 2, y, angleOrNull);
+	} else {
+		x = Math.round(x);
+		y = Math.round(y);
+		c.fillText(text, x, y + 6);
+		if(isSelected && caretVisible && canvasHasFocus() && document.hasFocus()) {
+			x += width;
+			c.beginPath();
+			c.moveTo(x, y - 10);
+			c.lineTo(x, y + 10);
+			c.stroke();
+		}
+	}
+}
+
+var caretTimer;
+var caretVisible = true;
+
+function resetCaret() {
+	clearInterval(caretTimer);
+	caretTimer = setInterval('caretVisible = !caretVisible; draw()', 500);
+	caretVisible = true;
+}
+
+var canvas;
+var nodeRadius = 30;
+var nodes = [];
+var links = [];
+
+var cursorVisible = true;
+var snapToPadding = 6; // pixels
+var hitTargetPadding = 6; // pixels
+var selectedObject = null; // either a Link or a Node
+var currentLink = null; // a Link
+var movingObject = false;
+var originalClick;
+
+function drawUsing(c) {
+	c.clearRect(0, 0, canvas.width, canvas.height);
+	c.save();
+	c.translate(0.5, 0.5);
+
+	for(var i = 0; i < nodes.length; i++) {
+		c.lineWidth = 1;
+		c.fillStyle = c.strokeStyle = (nodes[i] == selectedObject) ? 'blue' : 'black';
+		nodes[i].draw(c);
+	}
+	for(var i = 0; i < links.length; i++) {
+		c.lineWidth = 1;
+		c.fillStyle = c.strokeStyle = (links[i] == selectedObject) ? 'blue' : 'black';
+		links[i].draw(c);
+	}
+	if(currentLink != null) {
+		c.lineWidth = 1;
+		c.fillStyle = c.strokeStyle = 'black';
+		currentLink.draw(c);
+	}
+
+	c.restore();
+}
+
+function draw() {
+	drawUsing(canvas.getContext('2d'));
+	saveBackup();
+}
+
+function selectObject(x, y) {
+	for(var i = 0; i < nodes.length; i++) {
+		if(nodes[i].containsPoint(x, y)) {
+			return nodes[i];
+		}
+	}
+	for(var i = 0; i < links.length; i++) {
+		if(links[i].containsPoint(x, y)) {
+			return links[i];
+		}
+	}
+	return null;
+}
+
+function snapNode(node) {
+	for(var i = 0; i < nodes.length; i++) {
+		if(nodes[i] == node) continue;
+
+		if(Math.abs(node.x - nodes[i].x) < snapToPadding) {
+			node.x = nodes[i].x;
+		}
+
+		if(Math.abs(node.y - nodes[i].y) < snapToPadding) {
+			node.y = nodes[i].y;
+		}
+	}
+}
+
+function fsmload() {
+	canvas = document.getElementById('fsmcanvas');
+	restoreBackup();
+	draw();
+
+	canvas.onmousedown = function(e) {
+		var mouse = crossBrowserRelativeMousePos(e);
+		selectedObject = selectObject(mouse.x, mouse.y);
+		movingObject = false;
+		originalClick = mouse;
+
+		if(selectedObject != null) {
+			if(shift && selectedObject instanceof Node) {
+				currentLink = new SelfLink(selectedObject, mouse);
+			} else {
+				movingObject = true;
+				deltaMouseX = deltaMouseY = 0;
+				if(selectedObject.setMouseStart) {
+					selectedObject.setMouseStart(mouse.x, mouse.y);
+				}
+			}
+			resetCaret();
+		} else if(shift) {
+			currentLink = new TemporaryLink(mouse, mouse);
+		}
+
+		draw();
+
+		if(canvasHasFocus()) {
+			// disable drag-and-drop only if the canvas is already focused
+			return false;
+		} else {
+			// otherwise, let the browser switch the focus away from wherever it was
+			resetCaret();
+			return true;
+		}
+	};
+
+	canvas.ondblclick = function(e) {
+		var mouse = crossBrowserRelativeMousePos(e);
+		selectedObject = selectObject(mouse.x, mouse.y);
+
+		if(selectedObject == null) {
+			selectedObject = new Node(mouse.x, mouse.y);
+			nodes.push(selectedObject);
+			resetCaret();
+			draw();
+		} else if(selectedObject instanceof Node) {
+			selectedObject.isAcceptState = !selectedObject.isAcceptState;
+			draw();
+		}
+	};
+
+	canvas.onmousemove = function(e) {
+		var mouse = crossBrowserRelativeMousePos(e);
+
+		if(currentLink != null) {
+			var targetNode = selectObject(mouse.x, mouse.y);
+			if(!(targetNode instanceof Node)) {
+				targetNode = null;
+			}
+
+			if(selectedObject == null) {
+				if(targetNode != null) {
+					currentLink = new StartLink(targetNode, originalClick);
+				} else {
+					currentLink = new TemporaryLink(originalClick, mouse);
+				}
+			} else {
+				if(targetNode == selectedObject) {
+					currentLink = new SelfLink(selectedObject, mouse);
+				} else if(targetNode != null) {
+					currentLink = new Link(selectedObject, targetNode);
+				} else {
+					currentLink = new TemporaryLink(selectedObject.closestPointOnCircle(mouse.x, mouse.y), mouse);
+				}
+			}
+			draw();
+		}
+
+		if(movingObject) {
+			selectedObject.setAnchorPoint(mouse.x, mouse.y);
+			if(selectedObject instanceof Node) {
+				snapNode(selectedObject);
+			}
+			draw();
+		}
+	};
+
+	canvas.onmouseup = function(e) {
+		movingObject = false;
+
+		if(currentLink != null) {
+			if(!(currentLink instanceof TemporaryLink)) {
+				selectedObject = currentLink;
+				links.push(currentLink);
+				resetCaret();
+			}
+			currentLink = null;
+			draw();
+		}
+	};
+}
+
+var shift = false;
+
+document.onkeydown = function(e) {
+	var key = crossBrowserKey(e);
+
+	if(key == 16) {
+		shift = true;
+	} else if(!canvasHasFocus()) {
+		// don't read keystrokes when other things have focus
+		return true;
+	} else if(key == 8) { // backspace key
+		if(selectedObject != null && 'text' in selectedObject) {
+			selectedObject.text = selectedObject.text.substr(0, selectedObject.text.length - 1);
+			resetCaret();
+			draw();
+		}
+
+		// backspace is a shortcut for the back button, but do NOT want to change pages
+		return false;
+	} else if(key == 46) { // delete key
+		if(selectedObject != null) {
+			for(var i = 0; i < nodes.length; i++) {
+				if(nodes[i] == selectedObject) {
+					nodes.splice(i--, 1);
+				}
+			}
+			for(var i = 0; i < links.length; i++) {
+				if(links[i] == selectedObject || links[i].node == selectedObject || links[i].nodeA == selectedObject || links[i].nodeB == selectedObject) {
+					links.splice(i--, 1);
+				}
+			}
+			selectedObject = null;
+			draw();
+		}
+	}
+};
+
+document.onkeyup = function(e) {
+	var key = crossBrowserKey(e);
+
+	if(key == 16) {
+		shift = false;
+	}
+};
+
+document.onkeypress = function(e) {
+	// don't read keystrokes when other things have focus
+	var key = crossBrowserKey(e);
+	if(!canvasHasFocus()) {
+		// don't read keystrokes when other things have focus
+		return true;
+	} else if(key >= 0x20 && key <= 0x7E && !e.metaKey && !e.altKey && !e.ctrlKey && selectedObject != null && 'text' in selectedObject) {
+		selectedObject.text += String.fromCharCode(key);
+		resetCaret();
+		draw();
+
+		// don't let keys do their actions (like space scrolls down the page)
+		return false;
+	} else if(key == 8) {
+		// backspace is a shortcut for the back button, but do NOT want to change pages
+		return false;
+	}
+};
+
+function crossBrowserKey(e) {
+	e = e || window.event;
+	return e.which || e.keyCode;
+}
+
+function crossBrowserElementPos(e) {
+	e = e || window.event;
+	var obj = e.target || e.srcElement;
+	var x = 0, y = 0;
+	while(obj.offsetParent) {
+		x += obj.offsetLeft;
+		y += obj.offsetTop;
+		obj = obj.offsetParent;
+	}
+	return { 'x': x, 'y': y };
+}
+
+function crossBrowserMousePos(e) {
+	e = e || window.event;
+	return {
+		'x': e.pageX || e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
+		'y': e.pageY || e.clientY + document.body.scrollTop + document.documentElement.scrollTop,
+	};
+}
+
+function crossBrowserRelativeMousePos(e) {
+	var element = crossBrowserElementPos(e);
+	var mouse = crossBrowserMousePos(e);
+	return {
+		'x': mouse.x - element.x,
+		'y': mouse.y - element.y
+	};
+}
+
+function output(text) {
+	var element = document.getElementById('output');
+	element.style.display = 'block';
+	element.value = text;
+}
+
+function saveAsPNG() {
+	var oldSelectedObject = selectedObject;
+	selectedObject = null;
+	drawUsing(canvas.getContext('2d'));
+	selectedObject = oldSelectedObject;
+	var pngData = canvas.toDataURL('image/png');
+	document.location.href = pngData;
+}
+
+function saveAsSVG() {
+	var exporter = new ExportAsSVG();
+	var oldSelectedObject = selectedObject;
+	selectedObject = null;
+	drawUsing(exporter);
+	selectedObject = oldSelectedObject;
+	var svgData = exporter.toSVG();
+	output(svgData);
+	// Chrome isn't ready for this yet, the 'Save As' menu item is disabled
+	// document.location.href = 'data:image/svg+xml;base64,' + btoa(svgData);
+}
+
+function saveAsLaTeX() {
+	var exporter = new ExportAsLaTeX();
+	var oldSelectedObject = selectedObject;
+	selectedObject = null;
+	drawUsing(exporter);
+	selectedObject = oldSelectedObject;
+	var texData = exporter.toLaTeX();
+	output(texData);
+}
+
+function det(a, b, c, d, e, f, g, h, i) {
+	return a*e*i + b*f*g + c*d*h - a*f*h - b*d*i - c*e*g;
+}
+
+function circleFromThreePoints(x1, y1, x2, y2, x3, y3) {
+	var a = det(x1, y1, 1, x2, y2, 1, x3, y3, 1);
+	var bx = -det(x1*x1 + y1*y1, y1, 1, x2*x2 + y2*y2, y2, 1, x3*x3 + y3*y3, y3, 1);
+	var by = det(x1*x1 + y1*y1, x1, 1, x2*x2 + y2*y2, x2, 1, x3*x3 + y3*y3, x3, 1);
+	var c = -det(x1*x1 + y1*y1, x1, y1, x2*x2 + y2*y2, x2, y2, x3*x3 + y3*y3, x3, y3);
+	return {
+		'x': -bx / (2*a),
+		'y': -by / (2*a),
+		'radius': Math.sqrt(bx*bx + by*by - 4*a*c) / (2*Math.abs(a))
+	};
+}
+
+function fixed(number, digits) {
+	return number.toFixed(digits).replace(/0+$/, '').replace(/\.$/, '');
+}
+
+function restoreBackup() {
+	var usedBackup = false;
+	if(localStorage && JSON) {
+		try {
+			var backup = JSON.parse(localStorage['fsm']);
+			usedBackup = restoreData(backup);
+		} catch(e) {
+			localStorage['fsm'] = '';
+		}
+	}
+
+	if(!usedBackup && fsmsave) {
+		restoreData(fsmsave);
+	}
+}
+
+function restoreData(backup) {
+	var usedBackup = false;
+	try {
+		for(var i = 0; i < backup.nodes.length; i++) {
+			usedBackup = true;
+			var backupNode = backup.nodes[i];
+			var node = new Node(backupNode.x, backupNode.y);
+			node.isAcceptState = backupNode.isAcceptState;
+			node.text = backupNode.text;
+			nodes.push(node);
+		}
+		for(var i = 0; i < backup.links.length; i++) {
+			usedBackup = true;
+			var backupLink = backup.links[i];
+			var link = null;
+			if(backupLink.type == 'SelfLink') {
+				link = new SelfLink(nodes[backupLink.node]);
+				link.anchorAngle = backupLink.anchorAngle;
+				link.text = backupLink.text;
+			} else if(backupLink.type == 'StartLink') {
+				link = new StartLink(nodes[backupLink.node]);
+				link.deltaX = backupLink.deltaX;
+				link.deltaY = backupLink.deltaY;
+				link.text = backupLink.text;
+			} else if(backupLink.type == 'Link') {
+				link = new Link(nodes[backupLink.nodeA], nodes[backupLink.nodeB]);
+				link.parallelPart = backupLink.parallelPart;
+				link.perpendicularPart = backupLink.perpendicularPart;
+				link.text = backupLink.text;
+				link.lineAngleAdjust = backupLink.lineAngleAdjust;
+			}
+			if(link != null) {
+				links.push(link);
+			}
+		}
+	} catch(e) {
+		return(false);
+	}
+	return(usedBackup);
+}
+
+function saveBackup() {
+	if(!localStorage || !JSON) {
+		return;
+	}
+
+	var backup = {
+		'nodes': [],
+		'links': [],
+	};
+	for(var i = 0; i < nodes.length; i++) {
+		var node = nodes[i];
+		var backupNode = {
+			'x': node.x,
+			'y': node.y,
+			'text': node.text,
+			'isAcceptState': node.isAcceptState,
+		};
+		backup.nodes.push(backupNode);
+	}
+	for(var i = 0; i < links.length; i++) {
+		var link = links[i];
+		var backupLink = null;
+		if(link instanceof SelfLink) {
+			backupLink = {
+				'type': 'SelfLink',
+				'node': nodes.indexOf(link.node),
+				'text': link.text,
+				'anchorAngle': link.anchorAngle,
+			};
+		} else if(link instanceof StartLink) {
+			backupLink = {
+				'type': 'StartLink',
+				'node': nodes.indexOf(link.node),
+				'text': link.text,
+				'deltaX': link.deltaX,
+				'deltaY': link.deltaY,
+			};
+		} else if(link instanceof Link) {
+			backupLink = {
+				'type': 'Link',
+				'nodeA': nodes.indexOf(link.nodeA),
+				'nodeB': nodes.indexOf(link.nodeB),
+				'text': link.text,
+				'lineAngleAdjust': link.lineAngleAdjust,
+				'parallelPart': link.parallelPart,
+				'perpendicularPart': link.perpendicularPart,
+			};
+		}
+		if(backupLink != null) {
+			backup.links.push(backupLink);
+		}
+	}
+
+	var fsmjson = JSON.stringify(backup);
+	localStorage['fsm'] = fsmjson;
+	var dataUri = 'data:application/javascript;charset=utf-8,fsmsave='+ encodeURIComponent(fsmjson) + ';';
+	var link = document.getElementById('fsmjson').href = dataUri;
+
+}
+
+function deleteBackup() {
+	localStorage['fsm'] = '';
+}
diff --git a/static/jquery.terminal.css b/static/jquery.terminal.css
index c213294..13eb21c 100644
--- a/static/jquery.terminal.css
+++ b/static/jquery.terminal.css
@@ -1,71 +1,232 @@
-.terminal .clipboard {
+/*!
+ *       __ _____                     ________                              __
+ *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /
+ *  __ / // // // // // _  // _// // / / // _  // _//     // //  \/ // _ \/ /
+ * /  / // // // // // ___// / / // / / // ___// / / / / // // /\  // // / /__
+ * \___//____ \\___//____//_/ _\_  / /_//____//_/ /_/ /_//_//_/ /_/ \__\_\___/
+ *           \/              /____/                              version 0.10.11
+ * http://terminal.jcubic.pl
+ *
+ * This file is part of jQuery Terminal.
+ *
+ * Copyright (c) 2011-2016 Jakub Jankiewicz <http://jcubic.pl>
+ * Released under the MIT license
+ *
+ * Date: Sun, 05 Jun 2016 20:11:03 +0000
+ */
+.terminal .terminal-output .format, .cmd .format,
+.cmd .prompt, .cmd .prompt div, .terminal .terminal-output div div{
+    display: inline-block;
+}
+.terminal h1, .terminal h2, .terminal h3, .terminal h4, .terminal h5, .terminal h6, .terminal pre, .cmd {
+    margin: 0;
+}
+.terminal h1, .terminal h2, .terminal h3, .terminal h4, .terminal h5, .terminal h6 {
+    line-height: 1.2em;
+}
+/*
+.cmd .mask {
+    width: 10px;
+    height: 11px;
+    background: black;
+    z-index: 100;
+}
+*/
+.cmd .clipboard {
     position: absolute;
-    bottom: 0;
-    left: 0;
+    height: 16px;
+    left: -6px;
+    /* this seems to work after all on Android */
+    /*left: -99999px;
+    clip: rect(1px,1px,1px,1px);
+    /* on desktop textarea appear when paste */
+    /*
     opacity: 0.01;
     filter: alpha(opacity = 0.01);
     filter: progid:DXImageTransform.Microsoft.Alpha(opacity=0.01);
-    width: 2px;
+    */
+    width: 5px; /* textarea need to have width or it will not work on Android */
+    background: transparent;
+    border: none;
+    color: transparent;
+    outline: none;
+    padding: 0;
+    resize: none;
+    z-index: 0;
+    overflow: hidden;
 }
-.cmd > .clipboard {
-    position: fixed;
+.terminal .error {
+    color: #f00;
 }
 .terminal {
     padding: 10px;
     position: relative;
-    overflow: hidden;
+    /*overflow: hidden;*/
+    overflow: auto;
 }
 .cmd {
     padding: 0;
-    margin: 0;
     height: 1.3em;
+    position: relative;
+    /*margin-top: 3px; */
+}
+.terminal .inverted, .cmd .inverted, .cmd .cursor.blink {
+    background-color: #aaa;
+    color: #000;
+}
+.cmd .cursor.blink {
+    -webkit-animation: terminal-blink 1s infinite steps(1, start);
+       -moz-animation: terminal-blink 1s infinite steps(1, start);
+        -ms-animation: terminal-blink 1s infinite steps(1, start);
+            animation: terminal-blink 1s infinite steps(1, start);
+}
+@-webkit-keyframes terminal-blink {
+  0%, 100% {
+      background-color: #000;
+      color: #aaa;
+  }
+  50% {
+      background-color: #bbb;
+      color: #000;
+  }
+}
+
+@-ms-keyframes terminal-blink {
+  0%, 100% {
+      background-color: #000;
+      color: #aaa;
+  }
+  50% {
+      background-color: #bbb;
+      color: #000;
+  }
+}
+
+@-moz-keyframes terminal-blink {
+  0%, 100% {
+      background-color: #000;
+      color: #aaa;
+  }
+  50% {
+      background-color: #bbb;
+      color: #000;
+  }
+}
+@keyframes terminal-blink {
+  0%, 100% {
+      background-color: #000;
+      color: #aaa;
+  }
+  50% {
+      background-color: #bbb; /* not #aaa because it's seems there is Google Chrome bug */
+      color: #000;
+  }
 }
-.terminal .terminal-output div {
+
+.terminal .terminal-output div div, .cmd .prompt {
     display: block;
+    line-height: 14px;
+    height: auto;
 }
-.terminal, .terminal .terminal-output, .terminal .terminal-output div,
-.terminal .terminal-output div div, .cmd, .terminal .cmd span, .terminal .cmd div {
+.cmd .prompt {
+    float: left;
+}
+.terminal, .cmd {
     font-family: monospace;
+    /*font-family: FreeMono, monospace; this don't work on Android */
     color: #aaa;
     background-color: #000;
     font-size: 12px;
+    line-height: 14px;
 }
-/* This works only in Safari and Google Chrome */
-@media screen and (-webkit-min-device-pixel-ratio:0) {
-    .terminal, .terminal .terminal-output, .terminal .terminal-output div,
-    .terminal .terminal-output div div, .cmd, .terminal .cmd span, .terminal .cmd div {
-        font-weight: bold;
-    }
-}  
-.terminal .cmd span {
+.terminal-output > div {
+    /*padding-top: 3px;*/
+    min-height: 14px;
+}
+.terminal .terminal-output div span {
+    display: inline-block;
+}
+.cmd span {
     float: left;
+    /*display: inline-block; */
+}
+/* fix double style of selecting text in terminal */
+.terminal-output span, .terminal-output a, .cmd div, .cmd span, .terminal td,
+.terminal pre, .terminal h1, .terminal h2, .terminal h3, .terminal h4,
+.terminal h5, .terminal h6 {
+    -webkit-touch-callout: initial;
+    -webkit-user-select: initial;
+    -khtml-user-select: initial;
+    -moz-user-select: initial;
+    -ms-user-select: initial;
+    user-select: initial;
+}
+.terminal, .terminal-output, .terminal-output div {
+    -webkit-touch-callout: none;
+    -webkit-user-select: none;
+    -khtml-user-select: none;
+    -moz-user-select: none;
+    -ms-user-select: none;
+    user-select: none;
+}
+/* firefox hack */
+@-moz-document url-prefix() {
+    .terminal, .terminal-output, .terminal-output div {
+        -webkit-touch-callout: initial;
+        -webkit-user-select: initial;
+        -khtml-user-select: initial;
+        -moz-user-select: initial;
+        -ms-user-select: initial;
+        user-select: initial;
+    }
+}
+.terminal table {
+    border-collapse: collapse;
 }
-.terminal .cmd span.inverted {
+.terminal td {
+    border: 1px solid #aaa;
+}
+.terminal h1::-moz-selection,
+.terminal h2::-moz-selection,
+.terminal h3::-moz-selection,
+.terminal h4::-moz-selection,
+.terminal h5::-moz-selection,
+.terminal h6::-moz-selection,
+.terminal pre::-moz-selection,
+.terminal td::-moz-selection,
+.terminal .terminal-output div div::-moz-selection,
+.terminal .terminal-output div span::-moz-selection,
+.terminal .terminal-output div div a::-moz-selection,
+.cmd div::-moz-selection,
+.cmd > span::-moz-selection,
+.cmd .prompt span::-moz-selection {
     background-color: #aaa;
     color: #000;
 }
-.terminal::-moz-selection {
-    background: rgba(170, 170, 170, 0.99);
-    color: #000;
-    text-shadow: none;
+/* this don't work in Chrome
+.terminal tr td::-moz-selection {
+    border-color: #000;
 }
-.terminal::-webkit-selection {
-    background: rgba(170, 170, 170, 0.99);
-    color: #000;
-    text-shadow: none;
+.terminal tr td::selection {
+    border-color: #000;
 }
-.terminal::selection {
-    background: rgba(170, 170, 170, 0.99);
+*/
+.terminal h1::selection,
+.terminal h2::selection,
+.terminal h3::selection,
+.terminal h4::selection,
+.terminal h5::selection,
+.terminal h6::selection,
+.terminal pre::selection,
+.terminal td::selection,
+.terminal .terminal-output div div::selection,
+.terminal .terminal-output div div a::selection,
+.terminal .terminal-output div span::selection,
+.cmd div::selection,
+.cmd > span::selection,
+.cmd .prompt span::selection {
+    background-color: #aaa;
     color: #000;
-    text-shadow: none;
-}
-/* chrome hack */
-@media screen and (-webkit-min-device-pixel-ratio:0) {
-    ::selection {
-        background: rgba(170, 170, 170, 0.99);
-        color: #000;
-        text-shadow: none;
-    }
 }
 .terminal .terminal-output div.error, .terminal .terminal-output div.error div {
     color: red;
@@ -79,4 +240,10 @@
 }
 .clear {
     clear: both;
-}  
+}
+.terminal a {
+    color: #0F60FF;
+}
+.terminal a:hover {
+    color: red;
+}
diff --git a/static/jquery.terminal.js b/static/jquery.terminal.js
index 8ad51b6..02b9936 100644
--- a/static/jquery.terminal.js
+++ b/static/jquery.terminal.js
@@ -1,78 +1,5134 @@
-/*
-
- |       __ _____                     ________                              __
- |      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /
- |  __ / // // // // // _  // _// // / / // _  // _//     // //  \/ // _ \/ /
- | /  / // // // // // ___// / / // / / // ___// / / / / // // /\  // // / /__
- | \___//____ \\___//____//_/ _\_  / /_//____//_/ /_/ /_//_//_/ /_/ \__\_\___/
- |           \/              /____/                              version 0.4.12
- http://terminal.jcubic.pl
-
- Licensed under GNU LGPL Version 3 license
- Copyright (c) 2011 Jakub Jankiewicz <http://jcubic.pl>
-
- Includes:
-
- Storage plugin Distributed under the MIT License
- Copyright (c) 2010 Dave Schindler
-
- LiveQuery plugin Dual MIT and GPL
- Copyright (c) 2008 Brandon Aaron (http://brandonaaron.net)
-
- jQuery Timers licenced with the WTFPL
- <http://jquery.offput.ca/every/>
-
- Date: Wed, 04 Apr 2012 16:30:49 +0000
-*/
-Array.prototype.has=function(g){for(var z=this.length;z--;)if(this[z]==g)return true;return false};function get_stack(g){return g?[g.toString().match(/.*\n.*\n/)].concat(get_stack(g.caller)):[]}
-(function(g,z){function ea(a,d){var e;if(typeof a==="string"&&typeof d==="string"){localStorage[a]=d;return true}else if(typeof a==="object"&&typeof d==="undefined"){for(e in a)if(a.hasOwnProperty(e))localStorage[e]=a[e];return true}return false}function $(a,d){var e,i;e=new Date;e.setTime(e.getTime()+31536E6);e="; expires="+e.toGMTString();if(typeof a==="string"&&typeof d==="string"){document.cookie=a+"="+d+e+"; path=/";return true}else if(typeof a==="object"&&typeof d==="undefined"){for(i in a)if(a.hasOwnProperty(i))document.cookie=
-i+"="+a[i]+e+"; path=/";return true}return false}function fa(a){return localStorage[a]}function ga(a){var d,e,i;a+="=";d=document.cookie.split(";");for(e=0;e<d.length;e++){for(i=d[e];i.charAt(0)===" ";)i=i.substring(1,i.length);if(i.indexOf(a)===0)return i.substring(a.length,i.length)}return null}function ha(a){return delete localStorage[a]}function ia(a){return $(a,"",-1)}function X(a,d){var e=[],i=a.length;if(i<d)return[a];for(var h=0;h<i;h+=d)e.push(a.substring(h,h+d));return e}function F(a){if(typeof a==
-"string"){a=a.replace(/&(?!#[0-9]+;|[a-zA-Z]+;)/g,"&amp;");a=a.replace(/</g,"&lt;").replace(/>/g,"&gt;");a=a.replace(/\n/g,"<br/>");a=a.replace(/ /g,"&nbsp;");a=a.replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;");var d=a.split(ja);if(d.length>1)a=g.map(d,function(e){return e===""?e:e[0]=="["?e.replace(Y,function(i,h,t,v,C){if(C==="")return"<span>&nbsp;</span>";i="";if(h.indexOf("b")!=-1)i+="font-weight:bold;";var L="text-decoration:";if(h.indexOf("u")!=-1)L+="underline ";if(h.indexOf("s")!=-1)L+="line-through";
-if(h.indexOf("s")!=-1||h.indexOf("u")!=-1)i+=L+";";if(h.indexOf("i")!=-1)i+="font-style:italic; ";if(t.match(aa))i+="color:"+t+";";if(v.match(aa))i+="background-color:"+v;return a='<span style="'+i+'">'+C+"</span>"}):"<span>"+e+"</span>"}).join("");return a}else return""}function ba(a){var d=a instanceof Array?a:a?[a]:[],e=0;g.extend(this,{left:function(){if(e===0)e=d.length-1;else--e;return d[e]},right:function(){if(e==d.length-1)e=0;else++e;return d[e]},current:function(){return d[e]},data:function(){return d},
-length:function(){return d.length},reset:function(){e=0},append:function(i){d.push(i);this.reset()}})}function ka(a){var d=a?[a]:[];g.extend(this,{size:function(){return d.length},pop:function(){if(d.length===0)return null;else{var e=d[d.length-1];d=d.slice(0,d.length-1);return e}},push:function(e){d=d.concat([e]);return e},top:function(){return d.length>0?d[d.length-1]:null}})}function la(a){var d=true;if(typeof a==="string"&&a!=="")a+="_";var e=g.Storage.get(a+"commands"),i=new ba(e?eval("("+e+
-")"):[""]);g.extend(this,{append:function(h){if(d&&i.current()!=h){i.append(h);g.Storage.set(a+"commands",g.json_stringify(i.data()))}},data:function(){return i.data()},next:function(){return i.right()},last:function(){i.reset()},previous:function(){return i.left()},clear:function(){i=new ba;g.Storage.remove(a+"commands")},enable:function(){d=true},disable:function(){d=false}})}g.extend(g.fn,{livequery:function(a,d,e){var i=this,h;if(g.isFunction(a)){e=d;d=a;a=z}g.each(g.livequery.queries,function(t,
-v){if(i.selector==v.selector&&i.context==v.context&&a==v.type&&(!d||d.$lqguid==v.fn.$lqguid)&&(!e||e.$lqguid==v.fn2.$lqguid))return(h=v)&&false});h=h||new g.livequery(this.selector,this.context,a,d,e);h.stopped=false;h.run();return this},expire:function(a,d,e){var i=this;if(g.isFunction(a)){e=d;d=a;a=z}g.each(g.livequery.queries,function(h,t){if(i.selector==t.selector&&i.context==t.context&&(!a||a==t.type)&&(!d||d.$lqguid==t.fn.$lqguid)&&(!e||e.$lqguid==t.fn2.$lqguid)&&!this.stopped)g.livequery.stop(t.id)});
-return this}});g.livequery=function(a,d,e,i,h){this.selector=a;this.context=d||document;this.type=e;this.fn=i;this.fn2=h;this.elements=[];this.stopped=false;this.id=g.livequery.queries.push(this)-1;i.$lqguid=i.$lqguid||g.livequery.guid++;if(h)h.$lqguid=h.$lqguid||g.livequery.guid++;return this};g.livequery.prototype={stop:function(){var a=this;if(this.type)this.elements.unbind(this.type,this.fn);else this.fn2&&this.elements.each(function(d,e){a.fn2.apply(e)});this.elements=[];this.stopped=true},run:function(){if(!this.stopped){var a=
-this,d=this.elements,e=g(this.selector,this.context),i=e.not(d);this.elements=e;if(this.type){i.bind(this.type,this.fn);d.length>0&&g.each(d,function(h,t){g.inArray(t,e)<0&&g.event.remove(t,a.type,a.fn)})}else{i.each(function(){a.fn.apply(this)});this.fn2&&d.length>0&&g.each(d,function(h,t){g.inArray(t,e)<0&&a.fn2.apply(t)})}}}};g.extend(g.livequery,{guid:0,queries:[],queue:[],running:false,timeout:null,checkQueue:function(){if(g.livequery.running&&g.livequery.queue.length)for(var a=g.livequery.queue.length;a--;)g.livequery.queries[g.livequery.queue.shift()].run()},
-pause:function(){g.livequery.running=false},play:function(){g.livequery.running=true;g.livequery.run()},registerPlugin:function(){g.each(arguments,function(a,d){if(g.fn[d]){var e=g.fn[d];g.fn[d]=function(){var i=e.apply(this,arguments);g.livequery.run();return i}}})},run:function(a){if(a!=z)g.inArray(a,g.livequery.queue)<0&&g.livequery.queue.push(a);else g.each(g.livequery.queries,function(d){g.inArray(d,g.livequery.queue)<0&&g.livequery.queue.push(d)});g.livequery.timeout&&clearTimeout(g.livequery.timeout);
-g.livequery.timeout=setTimeout(g.livequery.checkQueue,20)},stop:function(a){a!=z?g.livequery.queries[a].stop():g.each(g.livequery.queries,function(d){g.livequery.queries[d].stop()})}});g.livequery.registerPlugin("append","prepend","after","before","wrap","attr","removeAttr","addClass","removeClass","toggleClass","empty","remove");g(function(){g.livequery.play()});var ma=g.prototype.init;g.prototype.init=function(a,d){var e=ma.apply(this,arguments);if(a&&a.selector){e.context=a.context;e.selector=
-a.selector}if(typeof a=="string"){e.context=d||document;e.selector=a}return e};g.prototype.init.prototype=g.prototype;var U=typeof window.localStorage!=="undefined";g.extend({Storage:{set:U?ea:$,get:U?fa:ga,remove:U?ha:ia}});jQuery.fn.extend({everyTime:function(a,d,e,i,h){return this.each(function(){jQuery.timer.add(this,a,d,e,i,h)})},oneTime:function(a,d,e){return this.each(function(){jQuery.timer.add(this,a,d,e,1)})},stopTime:function(a,d){return this.each(function(){jQuery.timer.remove(this,a,
-d)})}});jQuery.extend({timer:{guid:1,global:{},regex:/^([0-9]+)\s*(.*s)?$/,powers:{ms:1,cs:10,ds:100,s:1E3,das:1E4,hs:1E5,ks:1E6},timeParse:function(a){if(a==z||a===null)return null;var d=this.regex.exec(jQuery.trim(a.toString()));return d[2]?parseInt(d[1],10)*(this.powers[d[2]]||1):a},add:function(a,d,e,i,h,t){var v=0;if(jQuery.isFunction(e)){h||(h=i);i=e;e=d}d=jQuery.timer.timeParse(d);if(!(typeof d!="number"||isNaN(d)||d<=0)){if(h&&h.constructor!=Number){t=!!h;h=0}h=h||0;t=t||false;if(!a.$timers)a.$timers=
-{};a.$timers[e]||(a.$timers[e]={});i.$timerID=i.$timerID||this.guid++;var C=function(){if(!(t&&this.inProgress)){this.inProgress=true;if(++v>h&&h!==0||i.call(a,v)===false)jQuery.timer.remove(a,e,i);this.inProgress=false}};C.$timerID=i.$timerID;a.$timers[e][i.$timerID]||(a.$timers[e][i.$timerID]=window.setInterval(C,d));this.global[e]||(this.global[e]=[]);this.global[e].push(a)}},remove:function(a,d,e){var i=a.$timers,h;if(i){if(d){if(i[d]){if(e){if(e.$timerID){window.clearInterval(i[d][e.$timerID]);
-delete i[d][e.$timerID]}}else for(e in i[d]){window.clearInterval(i[d][e]);delete i[d][e]}for(h in i[d])break;if(!h){h=null;delete i[d]}}}else for(d in i)this.remove(a,d,e);for(h in i)break;if(!h)a.$timers=null}}}});if(jQuery.browser.msie)jQuery(window).one("unload",function(){var a=jQuery.timer.global,d;for(d in a)for(var e=a[d],i=e.length;--i;)jQuery.timer.remove(e[i],d)});var ja=/(\[\[[bius]*;[^;]*;[^\]]*\][^\]\[]*\])/g,Y=/\[\[([bius]*);([^;]*);([^\]]*)\]([^\]\[]*)\]/g,aa=/#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})/;
-g.json_stringify=function(a,d){var e="",i;d=d===z?1:d;switch(typeof a){case "function":e+=a;break;case "boolean":e+=a?"true":"false";break;case "object":if(a===null)e+="null";else if(a instanceof Array){e+="[";var h=a.length;for(i=0;i<h-1;++i)e+=g.json_stringify(a[i],d+1);e+=g.json_stringify(a[h-1],d+1)+"]"}else{e+="{";for(h in a)if(a.hasOwnProperty(h))e+='"'+h+'":'+g.json_stringify(a[h],d+1);e+="}"}break;case "string":h=a;var t={"\\\\":"\\\\",'"':'\\"',"/":"\\/","\\n":"\\n","\\r":"\\r","\\t":"\\t"};
-for(i in t)if(t.hasOwnProperty(i))h=h.replace(RegExp(i,"g"),t[i]);e+='"'+h+'"';break;case "number":e+=String(a)}e+=d>1?",":"";if(d==1)e=e.replace(/,([\]}])/g,"$1");return e.replace(/([\[{]),/g,"$1")};g.fn.cmd=function(a){function d(){M.toggleClass("inverted")}function e(f){var q=f.substring(0,v-C-1);f=f.substring(v-C-1);return[q].concat(X(f,v))}function i(){t.focus();h.oneTime(1,function(){h.insert(t.val());t.blur().val("")})}var h=this;h.addClass("cmd");h.append('<span class="prompt"></span><span></span><span class="cursor">&nbsp;</span><span></span>');
-var t=g("<textarea/>").addClass("clipboard").appendTo(h);a.width&&h.width(a.width);var v,C,L=a.mask||false,m="",n=0,I,J=a.enabled,V,G,M=h.find(".cursor"),c=function(f){function q(r,u){if(u==r.length){D.html(F(r));M.html("&nbsp;");H.html("")}else if(u===0){D.html("");M.html(F(r.slice(0,1)));H.html(F(r.slice(1)))}else{var o=F(r.slice(0,u));D.html(o);o=r.slice(u,u+1);M.html(o==" "?"&nbsp;":F(o));u==r.lenght-1?H.html(""):H.html(F(r.slice(u+1)))}}function K(r){return"<div>"+F(r)+"</div>"}function Q(r){var u=
-H;g.each(r,function(o,y){u=g(K(y)).insertAfter(u).addClass("clear")})}function l(r){g.each(r,function(u,o){D.before(K(o))})}var D=M.prev(),H=M.next();return function(){var r=L?m.replace(/./g,"*"):m,u;f.find("div").remove();D.html("");if(r.length>v-C-1||r.match(/\n/)){var o,y=r.match(/\t/g),p=y?y.length*3:0;if(y)r=r.replace(/\t/g,"\u0000\u0000\u0000\u0000");if(r.match(/\n/)){var b=r.split("\n"),j=v-C-1;for(u=0;u<b.length-1;++u)b[u]+=" ";if(b[0].length>j){o=[b[0].substring(0,j)];o=o.concat(X(b[0].substring(j),
-v))}else o=[b[0]];for(u=1;u<b.length;++u)if(b[u].length>v)o=o.concat(X(b[u],v));else o.push(b[u])}else o=e(r);if(y)o=g.map(o,function(k){return k.replace(/\x00\x00\x00\x00/g,"\t")});j=o[0].length;if(n<j){q(o[0],n);Q(o.slice(1))}else if(n==j){D.before(K(o[0]));q(o[1],0);Q(o.slice(2))}else{u=o.length;if(n<j){q(o[0],n);Q(o.slice(1))}else if(n==j){D.before(K(o[0]));q(o[1],0);Q(o.slice(2))}else{y=o.slice(-1)[0];b=r.length-n;r=0;if(b<=y.length){l(o.slice(0,-1));r=y.length==b?0:y.length-b;q(y,r+p)}else if(u==
-3){D.before("<div>"+F(o[0])+"</div>");q(o[1],n-j-1);H.after('<div class="clear">'+F(o[2])+"</div>")}else{r=n;for(u=0;u<o.length;++u)if(r>o[u].length)r-=o[u].length;else break;p=o[u];j=u;if(r==p.length){r=0;p=o[++j]}q(p,r);l(o.slice(0,j));Q(o.slice(j+1))}}}}else if(r===""){D.html("");M.html("&nbsp;");H.html("")}else q(r,n)}}(h),N=function(){var f=h.find(".prompt");return function(){if(typeof I=="string"){C=I.replace(Y,"$4").length;f.html(F(I)+"&nbsp;")}else I(function(q){C=q.replace(Y,"$4").length;
-f.html(F(q)+"&nbsp;")})}}();g.extend(h,{name:function(f){if(f!==z){V=f;G=new la(f)}else return V},history:function(){return G},set:function(f,q){if(f!==z){m=f;if(!q)n=m.length;c();if(typeof a.onCommandChange=="function")a.onCommandChange(m)}},insert:function(f,q){if(n==m.length)m+=f;else m=n===0?f+m:m.slice(0,n)+f+m.slice(n);q||(n+=f.length);c();if(typeof a.onCommandChange=="function")a.onCommandChange(m)},get:function(){return m},commands:function(f){if(f)a.commands=f;else return f},destroy:function(){g(document.documentElement).unbind(".commandline");
-h.find(".prompt").remove()},prompt:function(f){if(f===z)return I;else{if(typeof f=="string"||typeof f=="function")I=f;else throw"prompt must be a function or string";N();c()}},position:function(f){if(typeof f=="number"){n=f<0?0:f>m.length?m.length:f;c()}else return n},show:function(){var f=h.show;return function(){f.apply(h,[]);c();N()}}(),resize:function(f){if(f)v=f;else{f=h.width();var q=M.innerWidth();v=Math.floor(f/q)}c()},enable:function(){if(!J){h.everyTime(500,"blink",d);J=true}},isenabled:function(){return J},
-disable:function(){if(J){h.stopTime("blink",d);h.find(".cursor").removeClass("inverted");J=false}},mask:function(f){if(typeof f=="boolean"){L=f;c()}else return L}});h.name(a.name||"");I=a.prompt||">";N();if(a.enabled===z||a.enabled===true)h.enable();g(g.browser.msie?document.documentElement:window).keypress(function(f){var q;if(f.ctrlKey&&f.which==99)return true;if(a.keypress)q=a.keypress(f);if(q===z||q){if(J)if([38,32,13,0,8].has(f.which)&&f.keyCode!=123&&!(f.which==38&&f.shiftKey))return false;
-else if(!f.ctrlKey&&!(f.altKey&&f.which==100)){h.insert(String.fromCharCode(f.which));return false}else f.altKey&&h.insert(String.fromCharCode(f.which))}else return q}).keydown(function(f){if(J){if(a.keydown&&a.keydown(f)===false)return false;var q;if(f.altKey){if(f.which==68){h.set(m.slice(0,n)+m.slice(n).replace(/[^ ]+ |[^ ]+$/,""),true);return false}return true}else if(f.keyCode==13){if(G&&m&&(a.historyFilter&&a.historyFilter(m)||!a.historyFilter))G.append(m);G.last();f=m;h.set("");a.commands&&
-a.commands(f);typeof I=="function"&&N()}else if(f.which==32)h.insert(" ");else if(f.which==8){if(m!==""&&n>0){m=m.slice(0,n-1)+m.slice(n,m.length);--n;c()}}else if(f.which==9&&!(f.ctrlKey||f.altKey))h.insert("\t");else if(f.which==46){if(m!==""&&n<m.length){m=m.slice(0,n)+m.slice(n+1,m.length);c()}return true}else if(G&&f.which==38||f.which==80&&f.ctrlKey)h.set(G.previous());else if(G&&f.which==40||f.which==78&&f.ctrlKey)h.set(G.next());else if(f.which==37||f.which==66&&f.ctrlKey)if(f.ctrlKey&&f.which!=
-66){q=n-1;f=0;for(m[q]==" "&&--q;q>0;--q)if(m[q]==" "&&m[q+1]!=" "){f=q+1;break}else if(m[q]=="\n"&&m[q+1]!="\n"){f=q;break}h.position(f)}else{if(n>0){--n;c()}}else if(f.which==39||f.which==70&&f.ctrlKey)if(f.ctrlKey&&f.which!=70){m[n]==" "&&++n;f=m.slice(n).match(/\S[\n\s]{2,}|[\n\s]+\S?/);if(!f||f[0].match(/^\s+$/))n=m.length;else if(f[0][0]!=" ")n+=f.index+1;else{n+=f.index+f[0].length-1;f[0][f[0].length-1]!=" "&&--n}c()}else{if(n<m.length){++n;c()}}else if(f.which==123)return true;else if(f.which==
-36)h.position(0);else if(f.which==35)h.position(m.length);else if(f.ctrlKey||f.metaKey)if(f.shiftKey){if(f.which==84)return true}else if(f.which==65)h.position(0);else if(f.which==69)h.position(m.length);else if(f.which==88||f.which==67||f.which==87||f.which==84)return true;else if(f.which==86){i();return true}else if(f.which==75)if(n===0)h.set("");else n!=m.length&&h.set(m.slice(0,n));else if(f.which==85){h.set(m.slice(n,m.length));h.position(0)}else{if(f.which==17)return true}else return true;return false}});
-return h};g.jrpc=function(a,d,e,i,h,t){d=g.json_stringify({jsonrpc:"2.0",method:e,params:i,id:d});return g.ajax({url:a,data:d,success:h,error:t,contentType:"application/json",dataType:"json",async:true,cache:false,type:"POST"})};U=/ {14}$/;var na=[["jQuery Terminal","(c) 2011 jcubic"],["JQuery Terminal Emulator v. 0.4.12","Copyright (c) 2011 Jakub Jankiewicz <http://jcubic.pl>".replace(/ *<.*>/,"")],["JQuery Terminal Emulator version version 0.4.12","Copyright (c) 2011 Jakub Jankiewicz <http://jcubic.pl>"],
-["      _______                 ________                        __","     / / _  /_ ____________ _/__  ___/______________  _____  / /"," __ / / // / // / _  / _/ // / / / _  / _/     / /  \\/ / _ \\/ /","/  / / // / // / ___/ // // / / / ___/ // / / / / /\\  / // / /__","\\___/____ \\\\__/____/_/ \\__ / /_/____/_//_/ /_/ /_/  \\/\\__\\_\\___/","         \\/          /____/                                   ".replace(U,"")+"version 0.4.12","Copyright (c) 2011 Jakub Jankiewicz <http://jcubic.pl>"],
-["      __ _____                     ________                              __","     / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /"," __ / // // // // // _  // _// // / / // _  // _//     // //  \\/ // _ \\/ /","/  / // // // // // ___// / / // / / // ___// / / / / // // /\\  // // / /__","\\___//____ \\\\___//____//_/ _\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\__\\_\\___/","          \\/              /____/                                          ".replace(U,"")+"version 0.4.12",
-"Copyright (c) 2011 Jakub Jankiewicz <http://jcubic.pl>"]],oa=[],O=new function(a){var d=a?[a]:[],e=0;g.extend(this,{rotate:function(){if(d.length==1)return d[0];else{if(e==d.length-1)e=0;else++e;return d[e]}},length:function(){return d.length},set:function(i){for(var h=d.length;h--;)if(d[h]===i){e=h;return}this.append(i)},front:function(){return d[e]},append:function(i){d.push(i)}})};g.fn.terminal=function(a,d){function e(){return c.get(0).scrollHeight>c.innerHeight()}function i(){var b=c.find(".cursor").width(),
-j=Math.floor(c.width()/b);if(e()){var k=c.innerWidth()-c.width();j-=Math.ceil((20-k/2)/(b-1))}return j}function h(b,j){c.error("&#91;"+j+"&#93;: "+(typeof b=="string"?b:b.fileName+": "+b.message));c.pause();typeof b.fileName=="string"&&g.get(b.fileName,function(k){c.resume();var w=b.lineNumber-1;(k=k.split("\n")[w])&&c.error("&#91;"+b.lineNumber+"&#93;: "+k)})}function t(b,j){try{if(typeof j=="function")j(function(){});else if(typeof j!="string")throw b+" must be string or function";}catch(k){h(k,
-b.toUpperCase());return false}return true}function v(){var b=c.prop?c.prop("scrollHeight"):c.attr("scrollHeight");c.scrollTop(b)}function C(b){b=typeof b=="string"?b:String(b);var j,k,w;if(b.length>K){j=K;k=b.split(/\n/g);w=/(\[\[[bius]*;[^;]*;[^\]]*\][^\]\[]*\]?)/g;var s=/(\[\[[bius]*;[^;]*;[^\]]*\])/,A=/\[\[[bius]*;?[^;]*;?[^\]]*\]?$/,x=false,E=false,B="";b=[];for(var T=0,pa=k.length;T<pa;++T){if(B!=="")if(k[T]===""){b.push(B+"]");continue}else{k[T]=B+k[T];B=""}else if(k[T]===""){b.push("");continue}for(var W=
-k[T],ca=0,Z=0,R=0,da=W.length;R<da;++R){if(W[R]=="["&&W[R+1]=="[")x=true;else if(x&&W[R]=="]")if(E)E=x=false;else E=true;else if(x&&E||!x)++Z;if(Z==j||R==da-1){var P=W.substring(ca,R+1);if(B){P=B+P;if(P.match("]"))B=""}ca=R+1;Z=0;var S=P.match(w);if(S){S=S[S.length-1];if(S[S.length-1]!="]"){B=S.match(s)[1];P+="]"}else if(P.match(A)){P=P.replace(A,"");B=S.match(s)[1]}}b.push(P)}}}j=g("<div></div>");k=0;for(w=b.length;k<w;++k)b[k]===""||b[k]=="\r"?j.append("<div>&nbsp;</div>"):g("<div/>").html(F(b[k])).appendTo(j)}else j=
-g("<div/>").html(F(b));f.append(j);j.width("100%");v();return j}function L(b,j){var k=1,w=function(s,A){j.pause();g.jrpc(b,k++,s,A,function(x){if(x.error)j.error("&#91;RPC&#93; "+x.error.message);else if(typeof x.result=="string")j.echo(x.result);else if(x.result instanceof Array)j.echo(x.result.join(" "));else if(typeof x.result=="object"){var E="",B;for(B in x.result)if(x.result.hasOwnProperty(B))E+=B+": "+x.result[B]+"\n";j.echo(E)}j.resume()},function(x,E){j.error("&#91;AJAX&#93; "+E+" - Server reponse is: \n"+
-x.responseText);j.resume()})};return function(s,A){if(s!==""){var x,E;if(s.match(/[^ ]* /)){s=s.split(/ +/);x=s[0];E=s.slice(1)}else{x=s;E=[]}if(!l.login||x=="help")w(x,E);else{var B=A.token();B?w(x,[B].concat(E)):A.error("&#91;AUTH&#93; Access denied (no token)")}}}}function m(b){var j=p.prompt();if(p.mask())b=b.replace(/./g,"*");typeof j=="function"?j(function(k){c.echo(k+" "+b)}):c.echo(j+" "+b)}function n(b){try{var j=y.top();if(b=="exit"&&l.exit)if(y.size()==1)l.login?J():c.echo("You can exit from main interpeter");
-else c.pop("exit");else{m(b);b=="clear"&&l.clear?c.clear():j.eval(b,c)}}catch(k){h(k,"USER");c.resume();throw k;}}function I(){var b=null;p.prompt("login:");l.history&&p.history().disable();p.commands(function(j){try{m(j);if(b){p.mask(false);c.pause();if(typeof l.login!="function")throw"Value of login property must be a function";l.login(b,j,function(w){if(w){var s=l.name;s=s?"_"+s:"";g.Storage.set("token"+s,w);g.Storage.set("login"+s,b);p.commands(n);G()}else{c.error("Wrong password try again");
-p.prompt("login:");b=null}c.resume();l.history&&p.history().enable()})}else{b=j;p.prompt("password:");p.mask(true)}}catch(k){h(k,"LOGIN",c);throw k;}})}function J(){var b=l.name;b=b?"_"+b:"";g.Storage.remove("token"+b,null);g.Storage.remove("login"+b,null);l.history&&p.history().disable();I()}function V(){var b=y.top(),j="";if(b.name!==z&&b.name!=="")j+=b.name+"_";j+=q;p.name(j);p.prompt(b.prompt);l.history&&p.history().enable();p.set("");if(typeof b.onStart=="function")b.onStart(c)}function G(){V();
-if(d.greetings===z)c.echo(c.signature);else d.greetings&&c.echo(d.greetings);if(typeof l.onInit=="function")l.onInit(c)}function M(b){c.oneTime(5,function(){if(r!=e()){c.resize();r=e()}});if(!c.paused()){if(l.keydown&&l.keydown(b,c)===false)return false;if(b.which!=9)H=0;if(b.which==68&&b.ctrlKey){if(l.exit)if(p.get()==="")if(y.size()>1||l.login!==z)c.pop("");else{c.resume();c.echo("")}else c.set_command("");b.preventDefault()}else if(l.tabcompletion&&b.which==9){++H;b=p.get();if(!b.match(" ")){for(var j=
-RegExp("^"+b),k=y.top().command_list,w=[],s=k.length;s--;)j.test(k[s])&&w.push(k[s]);if(w.length==1)c.set_command(w[0]);else if(w.length>1)if(H>=2){m(b);c.echo(w.join("\t"));H=0}}return false}else if(b.which==86&&b.ctrlKey){c.oneTime(1,function(){v()});return true}else if(b.which==9&&b.ctrlKey){O.length()>1&&c.focus(false);b.preventDefault()}else if(b.which==34)c.scroll(c.height());else b.which==33?c.scroll(-c.height()):c.attr({scrollTop:c.attr("scrollHeight")})}}var c=this,N=[],f,q=O.length(),K,
-Q=[],l={name:"",prompt:">",history:true,exit:true,clear:true,enabled:true,login:null,tabcompletion:false,onInit:null,onExit:null,keypress:null,keydown:null};if(d){d.width&&c.width(d.width);d.height&&c.height(d.height);g.extend(l,d)}var D=!l.enabled;if(c.length===0)throw'Sorry, but terminal said that "'+c.selector+'" is not valid selector!';c.ajaxSend(function(b,j){oa.push(j)});if(c.data("terminal"))return c.data("terminal");f=g("<div>").addClass("terminal-output").appendTo(c);c.addClass("terminal").append("<div/>");
-g.extend(c,{clear:function(){f.html("");p.set("");N=[];c.attr({scrollTop:0});return c},paused:function(){return D},pause:function(){if(p){c.disable();p.hide()}return c},resume:function(){if(p){c.enable();p.show();v()}return c},cols:function(){return K},rows:function(){return N.length},history:function(){return p.history()},next:function(){if(O.length()==1)return c;else{var b=c.offset().top;c.height();c.scrollTop();var j=c,k=g(window).scrollTop(),w=k+g(window).height(),s=g(j).offset().top;if(s+g(j).height()>=
-k&&s<=w){O.front().disable();b=O.rotate().enable();j=b.offset().top-50;g("html,body").animate({scrollTop:j},500);return b}else{c.enable();g("html,body").animate({scrollTop:b-50},500);return c}}},focus:function(b){c.oneTime(1,function(){if(O.length()==1)b===false?c.disable():c.enable();else if(b===false)c.next();else{O.front().disable();O.set(c);c.enable()}});return c},enable:function(){K===z&&c.resize();if(D)if(p){p.enable();D=false}return c},disable:function(){if(p){D=true;p.disable()}return c},
-enabled:function(){return D},signature:function(){var b=c.cols();b=b<15?null:b<35?0:b<55?1:b<64?2:b<75?3:4;return b!==null?na[b].join("\n")+"\n":""},version:function(){return"0.4.12"},get_command:function(){return p.get()},insert:function(b){p.insert(b);return c},set_prompt:function(b){t("prompt",b)&&p.prompt(b);return c},get_prompt:function(){return p.prompt()},set_command:function(b){p.set(b);return c},set_mask:function(b){p.mask(b);return c},get_output:function(){return g.map(N,function(b,j){return typeof j==
-"function"?j():j}).get().join("\n")},resize:function(b,j){if(b&&j){c.width(b);c.height(j)}K=i();p.resize(K);var k=f.detach();f.html("");g.each(N,function(w,s){C(typeof s=="function"?s():s)});c.prepend(k);v();return c},echo:function(b){N.push(b);return C(typeof b=="function"?b():b)},error:function(b){c.echo("[[;#f00;]"+b.replace(/\[/g,"&#91;").replace(/\]/g,"&#93;")+"]")},scroll:function(b){var j;if(c.prop){b>c.prop("scrollTop")&&b>0&&c.prop("scrollTop",0);j=c.prop("scrollTop");c.prop("scrollTop",
-j+b)}else{b>c.attr("scrollTop")&&b>0&&c.attr("scrollTop",0);j=c.attr("scrollTop");c.attr("scrollTop",j+b)}return c},logout:l.login?function(){for(;y.size()>1;)y.pop();J();return c}:function(){throw"You don't have login function";},token:l.login?function(){var b=l.name;return g.Storage.get("token"+(b?"_"+b:""))}:null,login_name:l.login?function(){var b=l.name;return g.Storage.get("login"+(b?"_"+b:""))}:null,name:function(){return l.name},push:function(b,j){if(!j.prompt||t("prompt",j.prompt)){if(typeof b==
-"string")b=L(j.eval,c);y.push(g.extend({eval:b},j));V()}return c},pop:function(b){b!==z&&m(b);if(y.top().name===l.name){if(l.login){J();if(typeof l.onExit=="function")l.onExit(c)}}else{b=y.pop();V();if(typeof b.onExit=="function")b.onExit(c)}return c}});var H=0,r=e(),u;if(l.login&&typeof l.onBeforeLogin=="function")l.onBeforeLogin(c);if(a.constructor==String){u=a;a=L(a,c)}else if(a.constructor==Array)throw"You can't use array as eval";else if(typeof a=="object"){for(var o in a)Q.push(o);a=function b(j){return function(k){if(k!==
-""){k=k.split(/ +/);var w=k[0],s=k.slice(1);k=j[w];var A=typeof k;if(A=="function")k.apply(c,s);else if(A=="object"||A=="string"){s=[];if(A=="object"){for(var x in k)s.push(x);k=b(k)}c.push(k,{prompt:w+">",name:w,command_list:s})}else c.error("Command '"+w+"' Not Found")}}}(a)}else if(typeof a!="function")throw'Unknow object "'+String(a)+'" passed as eval';if(u&&(typeof l.login=="string"||l.login))l.login=function(b){var j=1;return function(k,w,s){c.pause();g.jrpc(u,j++,b,[k,w],function(A){c.resume();
-!A.error&&A.result?s(A.result):s(null)},function(A,x){c.resume();c.error("&#91;AJAX&#92; Response: "+x+"\n"+A.responseText)})}}(typeof l.login=="boolean"?"login":l.login);if(t("prompt",l.prompt)){var y=new ka({name:l.name,eval:a,prompt:l.prompt,command_list:Q,greetings:l.greetings}),p=c.find(".terminal-output").next().cmd({prompt:l.prompt,history:l.history,width:"100%",keydown:M,keypress:l.keypress?function(b){return l.keypress(b,c)}:null,onCommandChange:function(b){if(typeof l.onCommandChange=="function")l.onCommandChange(b,
-c);v()},commands:n});c.livequery(function(){c.resize()});O.append(c);l.enabled===true?c.focus():c.disable();g(window).resize(c.resize);c.click(function(){c.focus()});c.token&&!c.token()&&c.login_name&&!c.login_name()?I():G();typeof g.fn.init.prototype.mousewheel==="function"&&c.mousewheel(function(b,j){j>0?c.scroll(-40):c.scroll(40);return false},true)}c.data("terminal",c);return c}})(jQuery);
+/**@license
+ *       __ _____                     ________                              __
+ *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /
+ *  __ / // // // // // _  // _// // / / // _  // _//     // //  \/ // _ \/ /
+ * /  / // // // // // ___// / / // / / // ___// / / / / // // /\  // // / /__
+ * \___//____ \\___//____//_/ _\_  / /_//____//_/ /_/ /_//_//_/ /_/ \__\_\___/
+ *           \/              /____/                              version 0.10.11
+ *
+ * This file is part of jQuery Terminal. http://terminal.jcubic.pl
+ *
+ * Copyright (c) 2010-2016 Jakub Jankiewicz <http://jcubic.pl>
+ * Released under the MIT license
+ *
+ * Contains:
+ *
+ * Storage plugin Distributed under the MIT License
+ * Copyright (c) 2010 Dave Schindler
+ *
+ * jQuery Timers licenced with the WTFPL
+ * <http://jquery.offput.ca/timers/>
+ *
+ * Cross-Browser Split 1.1.1
+ * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
+ * Available under the MIT License
+ *
+ * jQuery Caret
+ * Copyright (c) 2009, Gideon Sireling
+ * 3 clause BSD License
+ *
+ * sprintf.js
+ * Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro>
+ * licensed under 3 clause BSD license
+ *
+ * Date: Sun, 05 Jun 2016 20:11:00 +0000
+ */
+
+/* TODO:
+ *
+ * Debug interpreters names in LocalStorage
+ * onPositionChange event add to terminal ???
+ * different command line history for each login users (add login if present to
+ * localStorage key)
+ *
+ * TEST: login + promises/exec
+ *       json-rpc/object + promises
+ *
+ * NOTE: json-rpc don't need promises and delegate resume/pause because only
+ *       exec can call it and exec call interpreter that work with resume/pause
+ */
+
+/* jshint ignore:start */
+(function(ctx) {
+    var sprintf = function() {
+        if (!sprintf.cache.hasOwnProperty(arguments[0])) {
+            sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
+        }
+        return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
+    };
+
+    sprintf.format = function(parse_tree, argv) {
+        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
+        for (i = 0; i < tree_length; i++) {
+            node_type = get_type(parse_tree[i]);
+            if (node_type === 'string') {
+                output.push(parse_tree[i]);
+            }
+            else if (node_type === 'array') {
+                match = parse_tree[i]; // convenience purposes only
+                if (match[2]) { // keyword argument
+                    arg = argv[cursor];
+                    for (k = 0; k < match[2].length; k++) {
+                        if (!arg.hasOwnProperty(match[2][k])) {
+                            throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
+                        }
+                        arg = arg[match[2][k]];
+                    }
+                }
+                else if (match[1]) { // positional argument (explicit)
+                    arg = argv[match[1]];
+                }
+                else { // positional argument (implicit)
+                    arg = argv[cursor++];
+                }
+
+                if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
+                    throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
+                }
+                switch (match[8]) {
+                    case 'b': arg = arg.toString(2); break;
+                    case 'c': arg = String.fromCharCode(arg); break;
+                    case 'd': arg = parseInt(arg, 10); break;
+                    case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
+                    case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
+                    case 'o': arg = arg.toString(8); break;
+                    case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
+                    case 'u': arg = arg >>> 0; break;
+                    case 'x': arg = arg.toString(16); break;
+                    case 'X': arg = arg.toString(16).toUpperCase(); break;
+                }
+                arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
+                pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
+                pad_length = match[6] - String(arg).length;
+                pad = match[6] ? str_repeat(pad_character, pad_length) : '';
+                output.push(match[5] ? arg + pad : pad + arg);
+            }
+        }
+        return output.join('');
+    };
+
+    sprintf.cache = {};
+
+    sprintf.parse = function(fmt) {
+        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
+        while (_fmt) {
+            if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
+                parse_tree.push(match[0]);
+            }
+            else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
+                parse_tree.push('%');
+            }
+            else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
+                if (match[2]) {
+                    arg_names |= 1;
+                    var field_list = [], replacement_field = match[2], field_match = [];
+                    if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
+                        field_list.push(field_match[1]);
+                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
+                            if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
+                                field_list.push(field_match[1]);
+                            }
+                            else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
+                                field_list.push(field_match[1]);
+                            }
+                            else {
+                                throw('[sprintf] huh?');
+                            }
+                        }
+                    }
+                    else {
+                        throw('[sprintf] huh?');
+                    }
+                    match[2] = field_list;
+                }
+                else {
+                    arg_names |= 2;
+                }
+                if (arg_names === 3) {
+                    throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
+                }
+                parse_tree.push(match);
+            }
+            else {
+                throw('[sprintf] huh?');
+            }
+            _fmt = _fmt.substring(match[0].length);
+        }
+        return parse_tree;
+    };
+
+    var vsprintf = function(fmt, argv, _argv) {
+        _argv = argv.slice(0);
+        _argv.splice(0, 0, fmt);
+        return sprintf.apply(null, _argv);
+    };
+
+    /**
+     * helpers
+     */
+    function get_type(variable) {
+        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
+    }
+
+    function str_repeat(input, multiplier) {
+        for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
+        return output.join('');
+    }
+
+    /**
+     * export to either browser or node.js
+     */
+    ctx.sprintf = sprintf;
+    ctx.vsprintf = vsprintf;
+})(typeof global != "undefined" ? global : window);
+/* jshint ignore:end */
+(function($, undefined) {
+    "use strict";
+    // -----------------------------------------------------------------------
+    // :: map object to object
+    // -----------------------------------------------------------------------
+    $.omap = function(o, fn) {
+        var result = {};
+        $.each(o, function(k, v) {
+            result[k] = fn.call(o, k, v);
+        });
+        return result;
+    };
+    var Clone = {
+        clone_object: function(object) {
+            var tmp = {};
+            if (typeof object == 'object') {
+                if ($.isArray(object)) {
+                    return this.clone_array(object);
+                } else if (object === null) {
+                    return object;
+                } else {
+                    for (var key in object) {
+                        if ($.isArray(object[key])) {
+                            tmp[key] = this.clone_array(object[key]);
+                        } else if (typeof object[key] == 'object') {
+                            tmp[key] = this.clone_object(object[key]);
+                        } else {
+                            tmp[key] = object[key];
+                        }
+                    }
+                }
+            }
+            return tmp;
+        },
+        clone_array: function(array) {
+            if (!$.isFunction(Array.prototype.map)) {
+                throw new Error("You'r browser don't support ES5 array map " +
+                                "use es5-shim");
+            }
+            return array.slice(0).map(function(item) {
+                if (typeof item == 'object') {
+                    return this.clone_object(item);
+                } else {
+                    return item;
+                }
+            }.bind(this));
+        }
+    };
+    var clone = function(object) {
+        return Clone.clone_object(object);
+    };
+
+    var hasLS = function () {
+      var testKey = 'test', storage = window.localStorage;
+      try {
+        storage.setItem(testKey, '1');
+        storage.removeItem(testKey);
+        return true;
+      } catch (error) {
+        return false;
+      }
+    };
+
+    /* jshint ignore:start */
+    // -----------------------------------------------------------------------
+    // :: Storage plugin
+    // -----------------------------------------------------------------------
+    // Private data
+    var isLS = hasLS();
+    // Private functions
+    function wls(n, v) {
+        var c;
+        if (typeof n === 'string' && typeof v === 'string') {
+            localStorage[n] = v;
+            return true;
+        } else if (typeof n === 'object' && typeof v === 'undefined') {
+            for (c in n) {
+                if (n.hasOwnProperty(c)) {
+                    localStorage[c] = n[c];
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+    function wc(n, v) {
+        var dt, e, c;
+        dt = new Date();
+        dt.setTime(dt.getTime() + 31536000000);
+        e = '; expires=' + dt.toGMTString();
+        if (typeof n === 'string' && typeof v === 'string') {
+            document.cookie = n + '=' + v + e + '; path=/';
+            return true;
+        } else if (typeof n === 'object' && typeof v === 'undefined') {
+            for (c in n) {
+                if (n.hasOwnProperty(c)) {
+                    document.cookie = c + '=' + n[c] + e + '; path=/';
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+    function rls(n) {
+        return localStorage[n];
+    }
+    function rc(n) {
+        var nn, ca, i, c;
+        nn = n + '=';
+        ca = document.cookie.split(';');
+        for (i = 0; i < ca.length; i++) {
+            c = ca[i];
+            while (c.charAt(0) === ' ') {
+                c = c.substring(1, c.length);
+            }
+            if (c.indexOf(nn) === 0) {
+                return c.substring(nn.length, c.length);
+            }
+        }
+        return null;
+    }
+    function dls(n) {
+        return delete localStorage[n];
+    }
+    function dc(n) {
+        return wc(n, '', -1);
+    }
+    /**
+    * Public API
+    * $.Storage.set("name", "value")
+    * $.Storage.set({"name1":"value1", "name2":"value2", etc})
+    * $.Storage.get("name")
+    * $.Storage.remove("name")
+    */
+    $.extend({
+        Storage: {
+            set: isLS ? wls : wc,
+            get: isLS ? rls : rc,
+            remove: isLS ? dls : dc
+        }
+    });
+    // -----------------------------------------------------------------------
+    // :: jQuery Timers
+    // -----------------------------------------------------------------------
+    var jQuery = $;
+    jQuery.fn.extend({
+        everyTime: function(interval, label, fn, times, belay) {
+            return this.each(function() {
+                jQuery.timer.add(this, interval, label, fn, times, belay);
+            });
+        },
+        oneTime: function(interval, label, fn) {
+            return this.each(function() {
+                jQuery.timer.add(this, interval, label, fn, 1);
+            });
+        },
+        stopTime: function(label, fn) {
+            return this.each(function() {
+                jQuery.timer.remove(this, label, fn);
+            });
+        }
+    });
+
+    jQuery.extend({
+        timer: {
+            guid: 1,
+            global: {},
+            regex: /^([0-9]+)\s*(.*s)?$/,
+            powers: {
+                // Yeah this is major overkill...
+                'ms': 1,
+                'cs': 10,
+                'ds': 100,
+                's': 1000,
+                'das': 10000,
+                'hs': 100000,
+                'ks': 1000000
+            },
+            timeParse: function(value) {
+                if (value === undefined || value === null) {
+                    return null;
+                }
+                var result = this.regex.exec(jQuery.trim(value.toString()));
+                if (result[2]) {
+                    var num = parseInt(result[1], 10);
+                    var mult = this.powers[result[2]] || 1;
+                    return num * mult;
+                } else {
+                    return value;
+                }
+            },
+            add: function(element, interval, label, fn, times, belay) {
+                var counter = 0;
+
+                if (jQuery.isFunction(label)) {
+                    if (!times) {
+                        times = fn;
+                    }
+                    fn = label;
+                    label = interval;
+                }
+
+                interval = jQuery.timer.timeParse(interval);
+
+                if (typeof interval !== 'number' ||
+                    isNaN(interval) ||
+                    interval <= 0) {
+                    return;
+                }
+                if (times && times.constructor !== Number) {
+                    belay = !!times;
+                    times = 0;
+                }
+
+                times = times || 0;
+                belay = belay || false;
+
+                if (!element.$timers) {
+                    element.$timers = {};
+                }
+                if (!element.$timers[label]) {
+                    element.$timers[label] = {};
+                }
+                fn.$timerID = fn.$timerID || this.guid++;
+
+                var handler = function() {
+                    if (belay && handler.inProgress) {
+                        return;
+                    }
+                    handler.inProgress = true;
+                    if ((++counter > times && times !== 0) ||
+                        fn.call(element, counter) === false) {
+                        jQuery.timer.remove(element, label, fn);
+                    }
+                    handler.inProgress = false;
+                };
+
+                handler.$timerID = fn.$timerID;
+
+                if (!element.$timers[label][fn.$timerID]) {
+                    element.$timers[label][fn.$timerID] = window.setInterval(handler, interval);
+                }
+
+                if (!this.global[label]) {
+                    this.global[label] = [];
+                }
+                this.global[label].push(element);
+
+            },
+            remove: function(element, label, fn) {
+                var timers = element.$timers, ret;
+
+                if (timers) {
+
+                    if (!label) {
+                        for (var lab in timers) {
+                            if (timers.hasOwnProperty(lab)) {
+                                this.remove(element, lab, fn);
+                            }
+                        }
+                    } else if (timers[label]) {
+                        if (fn) {
+                            if (fn.$timerID) {
+                                window.clearInterval(timers[label][fn.$timerID]);
+                                delete timers[label][fn.$timerID];
+                            }
+                        } else {
+                            for (var _fn in timers[label]) {
+                                if (timers[label].hasOwnProperty(_fn)) {
+                                    window.clearInterval(timers[label][_fn]);
+                                    delete timers[label][_fn];
+                                }
+                            }
+                        }
+
+                        for (ret in timers[label]) {
+                            if (timers[label].hasOwnProperty(ret)) {
+                                break;
+                            }
+                        }
+                        if (!ret) {
+                            ret = null;
+                            delete timers[label];
+                        }
+                    }
+
+                    for (ret in timers) {
+                        if (timers.hasOwnProperty(ret)) {
+                            break;
+                        }
+                    }
+                    if (!ret) {
+                        element.$timers = null;
+                    }
+                }
+            }
+        }
+    });
+
+    if (/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase())) {
+        jQuery(window).one('unload', function() {
+            var global = jQuery.timer.global;
+            for (var label in global) {
+                if (global.hasOwnProperty(label)) {
+                    var els = global[label], i = els.length;
+                    while (--i) {
+                        jQuery.timer.remove(els[i], label);
+                    }
+                }
+            }
+        });
+    }
+    // -----------------------------------------------------------------------
+    // :: CROSS BROWSER SPLIT
+    // -----------------------------------------------------------------------
+    (function(undef) {
+
+        // prevent double include
+
+        if (!String.prototype.split.toString().match(/\[native/)) {
+            return;
+        }
+
+        var nativeSplit = String.prototype.split,
+        compliantExecNpcg = /()??/.exec("")[1] === undef, // NPCG: nonparticipating capturing group
+        self;
+
+        self = function (str, separator, limit) {
+            // If `separator` is not a regex, use `nativeSplit`
+            if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
+                return nativeSplit.call(str, separator, limit);
+            }
+            var output = [],
+            flags = (separator.ignoreCase ? "i" : "") +
+                (separator.multiline  ? "m" : "") +
+                (separator.extended   ? "x" : "") + // Proposed for ES6
+                (separator.sticky     ? "y" : ""), // Firefox 3+
+                lastLastIndex = 0,
+            // Make `global` and avoid `lastIndex` issues by working with a copy
+            separator2, match, lastIndex, lastLength;
+            separator = new RegExp(separator.source, flags + "g");
+            str += ""; // Type-convert
+            if (!compliantExecNpcg) {
+                // Doesn't need flags gy, but they don't hurt
+                separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
+            }
+            /* Values for `limit`, per the spec:
+             * If undefined: 4294967295 // Math.pow(2, 32) - 1
+             * If 0, Infinity, or NaN: 0
+             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
+             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
+             * If other: Type-convert, then use the above rules
+             */
+            // ? Math.pow(2, 32) - 1 : ToUint32(limit)
+            limit = limit === undef ? -1 >>> 0 : limit >>> 0;
+            while (match = separator.exec(str)) {
+                    // `separator.lastIndex` is not reliable cross-browser
+                    lastIndex = match.index + match[0].length;
+                    if (lastIndex > lastLastIndex) {
+                        output.push(str.slice(lastLastIndex, match.index));
+                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
+                        // nonparticipating capturing groups
+                        if (!compliantExecNpcg && match.length > 1) {
+                            match[0].replace(separator2, function () {
+                                for (var i = 1; i < arguments.length - 2; i++) {
+                                    if (arguments[i] === undef) {
+                                        match[i] = undef;
+                                    }
+                                }
+                            });
+                        }
+                        if (match.length > 1 && match.index < str.length) {
+                            Array.prototype.push.apply(output, match.slice(1));
+                        }
+                        lastLength = match[0].length;
+                        lastLastIndex = lastIndex;
+                        if (output.length >= limit) {
+                            break;
+                        }
+                    }
+                    if (separator.lastIndex === match.index) {
+                        separator.lastIndex++; // Avoid an infinite loop
+                    }
+                }
+            if (lastLastIndex === str.length) {
+                if (lastLength || !separator.test("")) {
+                    output.push("");
+                }
+            } else {
+                output.push(str.slice(lastLastIndex));
+            }
+            return output.length > limit ? output.slice(0, limit) : output;
+        };
+
+        // For convenience
+        String.prototype.split = function (separator, limit) {
+            return self(this, separator, limit);
+        };
+
+        return self;
+
+    })();
+    // -----------------------------------------------------------------------
+    // :: jQuery Caret
+    // -----------------------------------------------------------------------
+    $.fn.caret = function(pos) {
+        var target = this[0];
+        var isContentEditable = target.contentEditable === 'true';
+        //get
+        if (arguments.length == 0) {
+            //HTML5
+            if (window.getSelection) {
+                //contenteditable
+                if (isContentEditable) {
+                    target.focus();
+                    var range1 = window.getSelection().getRangeAt(0),
+                    range2 = range1.cloneRange();
+                    range2.selectNodeContents(target);
+                    range2.setEnd(range1.endContainer, range1.endOffset);
+                    return range2.toString().length;
+                }
+                //textarea
+                return target.selectionStart;
+            }
+            //IE<9
+            if (document.selection) {
+                target.focus();
+                //contenteditable
+                if (isContentEditable) {
+                    var range1 = document.selection.createRange(),
+                    range2 = document.body.createTextRange();
+                    range2.moveToElementText(target);
+                    range2.setEndPoint('EndToEnd', range1);
+                    return range2.text.length;
+                }
+                //textarea
+                var pos = 0,
+                range = target.createTextRange(),
+                range2 = document.selection.createRange().duplicate(),
+                bookmark = range2.getBookmark();
+                range.moveToBookmark(bookmark);
+                while (range.moveStart('character', -1) !== 0) pos++;
+                return pos;
+            }
+            //not supported
+            return 0;
+        }
+        //set
+        if (pos == -1)
+            pos = this[isContentEditable? 'text' : 'val']().length;
+        //HTML5
+        if (window.getSelection) {
+            //contenteditable
+            if (isContentEditable) {
+                target.focus();
+                window.getSelection().collapse(target.firstChild, pos);
+            }
+            //textarea
+            else
+                target.setSelectionRange(pos, pos);
+        }
+        //IE<9
+        else if (document.body.createTextRange) {
+            var range = document.body.createTextRange();
+            range.moveToElementText(target);
+            range.moveStart('character', pos);
+            range.collapse(true);
+            range.select();
+        }
+        if (!isContentEditable)
+            target.focus();
+        return pos;
+    };
+    /* jshint ignore:end */
+    // -----------------------------------------------------------------------
+    // :: Split string to array of strings with the same length
+    // -----------------------------------------------------------------------
+    function str_parts(str, length) {
+        var result = [];
+        var len = str.length;
+        if (len < length) {
+            return [str];
+        } else if (length < 0) {
+            throw new Error('str_parts: length can\'t be negative'); // '
+        }
+        for (var i = 0; i < len; i += length) {
+            result.push(str.substring(i, i + length));
+        }
+        return result;
+    }
+    // -----------------------------------------------------------------------
+    // :: CYCLE DATA STRUCTURE
+    // -----------------------------------------------------------------------
+    function Cycle(init) {
+        var data = init ? [init] : [];
+        var pos = 0;
+        $.extend(this, {
+            get: function() {
+                return data;
+            },
+            rotate: function() {
+                if (data.length === 1) {
+                    return data[0];
+                } else {
+                    if (pos === data.length - 1) {
+                        pos = 0;
+                    } else {
+                        ++pos;
+                    }
+                    if (data[pos]) {
+                        return data[pos];
+                    } else {
+                        this.rotate();
+                    }
+                }
+            },
+            length: function() {
+                return data.length;
+            },
+            remove: function(index) {
+                delete data[index];
+            },
+            set: function(item) {
+                for (var i = data.length; i--;) {
+                    if (data[i] === item) {
+                        pos = i;
+                        return;
+                    }
+                }
+                this.append(item);
+            },
+            front: function() {
+                if (data.length) {
+                    var index = pos;
+                    while(!data[index]) {
+                        index++;
+                    }
+                    return data[index];
+                }
+            },
+            append: function(item) {
+                data.push(item);
+            }
+        });
+    }
+    // -----------------------------------------------------------------------
+    // :: STACK DATA STRUCTURE
+    // -----------------------------------------------------------------------
+    function Stack(init) {
+        var data = init instanceof Array ? init : init ? [init] : [];
+        $.extend(this, {
+            map: function(fn) {
+                return $.map(data, fn);
+            },
+            size: function() {
+                return data.length;
+            },
+            pop: function() {
+                if (data.length === 0) {
+                    return null;
+                } else {
+                    var value = data[data.length - 1];
+                    data = data.slice(0, data.length - 1);
+                    return value;
+                }
+            },
+            push: function(value) {
+                data = data.concat([value]);
+                return value;
+            },
+            top: function() {
+                return data.length > 0 ? data[data.length - 1] : null;
+            },
+            clone: function() {
+                return new Stack(data.slice(0));
+            }
+        });
+    }
+    // -------------------------------------------------------------------------
+    // :: Serialize object myself (biwascheme or prototype library do something
+    // :: wicked with JSON serialization for Arrays)
+    // -------------------------------------------------------------------------
+    $.json_stringify = function(object, level) {
+        var result = '', i;
+        level = level === undefined ? 1 : level;
+        var type = typeof object;
+        switch (type) {
+            case 'function':
+                result += object;
+                break;
+            case 'boolean':
+                result += object ? 'true' : 'false';
+                break;
+            case 'object':
+                if (object === null) {
+                    result += 'null';
+                } else if (object instanceof Array) {
+                    result += '[';
+                    var len = object.length;
+                    for (i = 0; i < len - 1; ++i) {
+                        result += $.json_stringify(object[i], level + 1);
+                    }
+                    result += $.json_stringify(object[len - 1], level + 1) + ']';
+                } else {
+                    result += '{';
+                    for (var property in object) {
+                        if (object.hasOwnProperty(property)) {
+                            result += '"' + property + '":' +
+                                $.json_stringify(object[property], level + 1);
+                        }
+                    }
+                    result += '}';
+                }
+                break;
+            case 'string':
+                var str = object;
+                var repl = {
+                    '\\\\': '\\\\',
+                    '"': '\\"',
+                    '/': '\\/',
+                    '\\n': '\\n',
+                    '\\r': '\\r',
+                    '\\t': '\\t'};
+                for (i in repl) {
+                    if (repl.hasOwnProperty(i)) {
+                        str = str.replace(new RegExp(i, 'g'), repl[i]);
+                    }
+                }
+                result += '"' + str + '"';
+                break;
+            case 'number':
+                result += String(object);
+                break;
+        }
+        result += (level > 1 ? ',' : '');
+        // quick hacks below
+        if (level === 1) {
+            // fix last comma
+            result = result.replace(/,([\]}])/g, '$1');
+        }
+        // fix comma before array or object
+        return result.replace(/([\[{]),/g, '$1');
+    };
+    // -------------------------------------------------------------------------
+    // :: HISTORY CLASS
+    // -------------------------------------------------------------------------
+    function History(name, size) {
+        var enabled = true;
+        var storage_key = '';
+        if (typeof name === 'string' && name !== '') {
+            storage_key = name + '_';
+        }
+        storage_key += 'commands';
+        var data = $.Storage.get(storage_key);
+        data = data ? $.parseJSON(data) : [];
+        var pos = data.length-1;
+        $.extend(this, {
+            append: function(item) {
+                if (enabled) {
+                    if (data[data.length-1] !== item) {
+                        data.push(item);
+                        if (size && data.length > size) {
+                            data = data.slice(-size);
+                        }
+                        pos = data.length-1;
+                        $.Storage.set(storage_key, $.json_stringify(data));
+                    }
+                }
+            },
+            data: function() {
+                return data;
+            },
+            reset: function() {
+                pos = data.length-1;
+            },
+            last: function() {
+                return data[length-1];
+            },
+            end: function() {
+                return pos === data.length-1;
+            },
+            position: function() {
+                return pos;
+            },
+            current: function() {
+                return data[pos];
+            },
+            next: function() {
+                if (pos < data.length-1) {
+                    ++pos;
+                }
+                if (pos !== -1) {
+                    return data[pos];
+                }
+            },
+            previous: function() {
+                var old = pos;
+                if (pos > 0) {
+                    --pos;
+                }
+                if (old !== -1) {
+                    return data[pos];
+                }
+            },
+            clear: function() {
+                data = [];
+                this.purge();
+            },
+            enabled: function() {
+                return enabled;
+            },
+            enable: function() {
+                enabled = true;
+            },
+            purge: function() {
+                $.Storage.remove(storage_key);
+            },
+            disable: function() {
+                enabled = false;
+            }
+        });
+    }
+    // -----------------------------------------------------------------------
+    var is_paste_supported = (function() {
+        var el = document.createElement('div');
+        el.setAttribute('onpaste', 'return;');
+        return typeof el.onpaste == "function";
+    })();
+    var first_cmd = true;
+    // -------------------------------------------------------------------------
+    // :: COMMAND LINE PLUGIN
+    // -------------------------------------------------------------------------
+    $.fn.cmd = function(options) {
+        var self = this;
+        var maybe_data = self.data('cmd');
+        if (maybe_data) {
+            return maybe_data;
+        }
+        self.addClass('cmd');
+        self.append('<span class="prompt"></span><span></span>' +
+                    '<span class="cursor">&nbsp;</span><span></span>');
+        // on mobile the only way to hide textarea on desktop it's needed because
+        // textarea show up after focus
+        //self.append('<span class="mask"></mask>');
+        var clip = $('<textarea />').addClass('clipboard').appendTo(self);
+        if (options.width) {
+            self.width(options.width);
+        }
+        var num_chars; // calculated by draw_prompt
+        var prompt_len;
+        var prompt_node = self.find('.prompt');
+        var reverse_search = false;
+        var rev_search_str = '';
+        var reverse_search_position = null;
+        var backup_prompt;
+        var mask = options.mask || false;
+        var command = '';
+        var last_command;
+        // text from selection using CTRL+SHIFT+C (as in Xterm)
+        var selected_text = '';
+        var kill_text = ''; // text from command that kill part of the command
+        var position = 0;
+        var prompt;
+        var enabled;
+        var historySize = options.historySize || 60;
+        var name, history;
+        var cursor = self.find('.cursor');
+        var animation;
+        function mobile_focus() {
+            if (is_touch) {
+                var focus = clip.is(':focus');
+                if (enabled) {
+                    if (!focus) {
+                        clip.focus();
+                        self.oneTime(10, function() {
+                            clip.focus();
+                        });
+                    }
+                } else {
+                    if (focus) {
+                        clip.blur();
+                    }
+                }
+            }
+        }
+        // on mobile you can't delete character if input is empty (event
+        // will not fire) so we fake text entry, we could just put dummy
+        // data but we put real command and position
+        function fake_mobile_entry() {
+            if (is_touch) {
+                // delay worked while experimenting
+                self.oneTime(10, function() {
+                    clip.val(command);
+                    self.oneTime(10, function() {
+                        clip.caret(position);
+                    });
+                });
+            }
+        }
+        // terminal animation don't work on andorid because they animate
+        // 2 properties
+        if ((support_animations && !is_android)) {
+            animation = function(toggle) {
+                if (toggle) {
+                    cursor.addClass('blink');
+                } else {
+                    cursor.removeClass('blink');
+                }
+            };
+        } else {
+            var animating = false;
+            animation = function(toggle) {
+                if (toggle && !animating) {
+                    animating = true;
+                    cursor.addClass('inverted');
+                    self.everyTime(500, 'blink', blink);
+                } else if (animating && !toggle) {
+                    animating = false;
+                    self.stopTime('blink', blink);
+                    cursor.removeClass('inverted');
+                }
+            };
+        }
+        // ---------------------------------------------------------------------
+        // :: Blinking cursor function
+        // ---------------------------------------------------------------------
+        function blink(i) {
+            cursor.toggleClass('inverted');
+        }
+        // ---------------------------------------------------------------------
+        // :: Set prompt for reverse search
+        // ---------------------------------------------------------------------
+        function draw_reverse_prompt() {
+            prompt = "(reverse-i-search)`" + rev_search_str + "': ";
+            draw_prompt();
+        }
+        // ---------------------------------------------------------------------
+        // :: Disable reverse search
+        // ---------------------------------------------------------------------
+        function clear_reverse_state() {
+            prompt = backup_prompt;
+            reverse_search = false;
+            reverse_search_position = null;
+            rev_search_str = '';
+        }
+        // ---------------------------------------------------------------------
+        // :: Search through command line history. If next is not defined or
+        // :: false it searches for the first item from the end. If true it
+        // :: search for the next item
+        // ---------------------------------------------------------------------
+        function reverse_history_search(next) {
+            var history_data = history.data();
+            var regex, save_string;
+            var len = history_data.length;
+            if (next && reverse_search_position > 0) {
+                len -= reverse_search_position;
+            }
+            if (rev_search_str.length > 0) {
+                for (var j=rev_search_str.length; j>0; j--) {
+                    save_string = $.terminal.escape_regex(rev_search_str.substring(0, j));
+                    regex = new RegExp(save_string);
+                    for (var i=len; i--;) {
+                        if (regex.test(history_data[i])) {
+                            reverse_search_position = history_data.length - i;
+                            self.position(history_data[i].indexOf(save_string));
+                            self.set(history_data[i], true);
+                            redraw();
+                            if (rev_search_str.length !== j) {
+                                rev_search_str = rev_search_str.substring(0, j);
+                                draw_reverse_prompt();
+                            }
+                            return;
+                        }
+                    }
+                }
+            }
+            rev_search_str = ''; // clear if not found any
+        }
+        // ---------------------------------------------------------------------
+        // :: Recalculate number of characters in command line
+        // ---------------------------------------------------------------------
+        function change_num_chars() {
+            var W = self.width();
+            var w = cursor.width();
+            num_chars = Math.floor(W / w);
+        }
+        // ---------------------------------------------------------------------
+        // :: Split String that fit into command line where first line need to
+        // :: fit next to prompt (need to have less characters)
+        // ---------------------------------------------------------------------
+        function get_splited_command_line(string) {
+            var first = string.substring(0, num_chars - prompt_len);
+            var rest = string.substring(num_chars - prompt_len);
+            return [first].concat(str_parts(rest, num_chars));
+        }
+        // ---------------------------------------------------------------------
+        // :: Function that displays the command line. Split long lines and
+        // :: place cursor in the right place
+        // ---------------------------------------------------------------------
+        var redraw = (function(self) {
+            var before = cursor.prev();
+            var after = cursor.next();
+            // -----------------------------------------------------------------
+            // :: Draw line with the cursor
+            // -----------------------------------------------------------------
+            function draw_cursor_line(string, position) {
+                var len = string.length;
+                if (position === len) {
+                    before.html($.terminal.encode(string));
+                    cursor.html('&nbsp;');
+                    after.html('');
+                } else if (position === 0) {
+                    before.html('');
+                    //fix for tilda in IE
+                    cursor.html($.terminal.encode(string.slice(0, 1)));
+                    //cursor.html($.terminal.encode(string[0]));
+                    after.html($.terminal.encode(string.slice(1)));
+                } else {
+                    var before_str = string.slice(0, position);
+                    before.html($.terminal.encode(before_str));
+                    //fix for tilda in IE
+                    var c = string.slice(position, position + 1);
+                    //cursor.html(string[position]);
+                    cursor.html($.terminal.encode(c));
+                    if (position === string.length - 1) {
+                        after.html('');
+                    } else {
+                        after.html($.terminal.encode(string.slice(position + 1)));
+                    }
+                }
+            }
+            function div(string) {
+                return '<div>' + $.terminal.encode(string) + '</div>';
+            }
+            // -----------------------------------------------------------------
+            // :: Display lines after the cursor
+            // -----------------------------------------------------------------
+            function lines_after(lines) {
+                var last_ins = after;
+                $.each(lines, function(i, line) {
+                    last_ins = $(div(line)).insertAfter(last_ins).
+                        addClass('clear');
+                });
+            }
+            // -----------------------------------------------------------------
+            // :: Display lines before the cursor
+            // -----------------------------------------------------------------
+            function lines_before(lines) {
+                $.each(lines, function(i, line) {
+                    before.before(div(line));
+                });
+            }
+            var count = 0;
+            // -----------------------------------------------------------------
+            // :: Redraw function
+            // -----------------------------------------------------------------
+            return function() {
+                var string;
+                var str; // max 80 line helper
+                switch(typeof mask) {
+                    case 'boolean':
+                        string = mask ? command.replace(/./g, '*') : command;
+                        break;
+                    case 'string':
+                        string = command.replace(/./g, mask);
+                        break;
+                }
+                var i, first_len;
+                self.find('div').remove();
+                before.html('');
+                // long line
+                if (string.length > num_chars - prompt_len - 1 ||
+                    string.match(/\n/)) {
+                    var array;
+                    var tabs = string.match(/\t/g);
+                    var tabs_rm = tabs ? tabs.length * 3 : 0;
+                    //quick tabulation hack
+                    if (tabs) {
+                        string = string.replace(/\t/g, '\x00\x00\x00\x00');
+                    }
+                    // command contains new line characters
+                    if (string.match(/\n/)) {
+                        var tmp = string.split("\n");
+                        first_len = num_chars - prompt_len - 1;
+                        // empty character after each line
+                        for (i=0; i<tmp.length-1; ++i) {
+                            tmp[i] += ' ';
+                        }
+                        // split first line
+                        if (tmp[0].length > first_len) {
+                            array = [tmp[0].substring(0, first_len)];
+                            str = tmp[0].substring(first_len);
+                            array = array.concat(str_parts(str, num_chars));
+                        } else {
+                            array = [tmp[0]];
+                        }
+                        // process rest of the lines
+                        for (i=1; i<tmp.length; ++i) {
+                            if (tmp[i].length > num_chars) {
+                                array = array.concat(str_parts(tmp[i],
+                                                               num_chars));
+                            } else {
+                                array.push(tmp[i]);
+                            }
+                        }
+                    } else {
+                        array = get_splited_command_line(string);
+                    }
+                    if (tabs) {
+                        array = $.map(array, function(line) {
+                            return line.replace(/\x00\x00\x00\x00/g, '\t');
+                        });
+                    }
+                    first_len = array[0].length;
+                    //cursor in first line
+                    if (first_len === 0 && array.length === 1) {
+                        // skip empty line
+                    } else if (position < first_len) {
+                        draw_cursor_line(array[0], position);
+                        lines_after(array.slice(1));
+                    } else if (position === first_len) {
+                        before.before(div(array[0]));
+                        draw_cursor_line(array[1], 0);
+                        lines_after(array.slice(2));
+                    } else {
+                        var num_lines = array.length;
+                        var offset = 0;
+                        if (position < first_len) {
+                            draw_cursor_line(array[0], position);
+                            lines_after(array.slice(1));
+                        } else if (position === first_len) {
+                            before.before(div(array[0]));
+                            draw_cursor_line(array[1], 0);
+                            lines_after(array.slice(2));
+                        } else {
+                            var last = array.slice(-1)[0];
+                            var from_last = string.length - position - tabs_rm;
+                            var last_len = last.length;
+                            var pos = 0;
+                            if (from_last <= last_len) {
+                                lines_before(array.slice(0, -1));
+                                if (last_len === from_last) {
+                                    pos = 0;
+                                } else {
+                                    pos = last_len-from_last;
+                                }
+                                draw_cursor_line(last, pos);
+                            } else {
+                                // in the middle
+                                if (num_lines === 3) {
+                                    str = $.terminal.encode(array[0]);
+                                    before.before('<div>' + str + '</div>');
+                                    draw_cursor_line(array[1],
+                                                     position-first_len-1);
+                                    str = $.terminal.encode(array[2]);
+                                    after.after('<div class="clear">' + str +
+                                                '</div>');
+                                } else {
+                                    // more lines, cursor in the middle
+                                    var line_index;
+                                    var current;
+                                    pos = position;
+                                    for (i=0; i<array.length; ++i) {
+                                        var current_len = array[i].length;
+                                        if (pos > current_len) {
+                                            pos -= current_len;
+                                        } else {
+                                            break;
+                                        }
+                                    }
+                                    current = array[i];
+                                    line_index = i;
+                                    // cursor on first character in line
+                                    if (pos === current.length) {
+                                        pos = 0;
+                                        current = array[++line_index];
+                                    }
+                                    draw_cursor_line(current, pos);
+                                    lines_before(array.slice(0, line_index));
+                                    lines_after(array.slice(line_index+1));
+                                }
+                            }
+                        }
+                    }
+                } else {
+                     if (string === '') {
+                         before.html('');
+                         cursor.html('&nbsp;');
+                         after.html('');
+                     } else {
+                         draw_cursor_line(string, position);
+                     }
+                }
+            };
+        })(self);
+        // ---------------------------------------------------------------------
+        // :: Draw prompt that can be a function or a string
+        // ---------------------------------------------------------------------
+        var draw_prompt = (function() {
+            function set(prompt) {
+                prompt_node.html($.terminal.format($.terminal.encode(prompt)));
+                prompt_len = prompt_node.text().length;
+            }
+            return function() {
+                switch (typeof prompt) {
+                    case 'string':
+                        set(prompt);
+                        break;
+                    case 'function':
+                        prompt(set);
+                        break;
+                }
+            };
+        })();
+        // ---------------------------------------------------------------------
+        // :: Paste content to terminal using hidden textarea
+        // ---------------------------------------------------------------------
+        function paste(e) {
+            e = e.originalEvent;
+            if (self.isenabled()) {
+                var clip = self.find('textarea');
+                if (!clip.is(':focus')) {
+                    clip.focus();
+                }
+                var text;
+                if (window.clipboardData && window.clipboardData.getData) { // IE
+                    text = window.clipboardData.getData('Text');
+                } else if (e.clipboardData && e.clipboardData.getData) {
+                    text = e.clipboardData.getData('text/plain');
+                } else {
+                    //wait until Browser insert text to textarea
+                    cmd.oneTime(100, function() {
+                        self.insert(clip.val());
+                        clip.val('');
+                        fake_mobile_entry();
+                    });
+                }
+                if (text) {
+                    self.insert(text);
+                    clip.val('');
+                    fake_mobile_entry();
+                }
+            }
+        }
+        var first_up_history = true;
+        // prevent_keypress - hack for Android that was inserting characters on
+        // backspace
+        var prevent_keypress = false;
+        var no_keypress;
+        // ---------------------------------------------------------------------
+        // :: Keydown Event Handler
+        // ---------------------------------------------------------------------
+        function keydown_event(e) {
+            var result, pos, len;
+            if (enabled) {
+                if ($.isFunction(options.keydown)) {
+                    result = options.keydown(e);
+                    if (result !== undefined) {
+                        //prevent_keypress = true;
+                        return result;
+                    }
+                }
+                if (e.which !== 38 &&
+                    !(e.which === 80 && e.ctrlKey)) {
+                    first_up_history = true;
+                }
+                // arrows / Home / End / ENTER
+                if (reverse_search && (e.which === 35 || e.which === 36 ||
+                                       e.which === 37 || e.which === 38 ||
+                                       e.which === 39 || e.which === 40 ||
+                                       e.which === 13 || e.which === 27)) {
+                    clear_reverse_state();
+                    draw_prompt();
+                    if (e.which === 27) { // ESC
+                        self.set('');
+                    }
+                    redraw();
+                    // finish reverse search and execute normal event handler
+                    /* jshint validthis:true */
+                    keydown_event.call(this, e);
+                } else if (e.altKey) {
+                    // Chrome on Windows sets ctrlKey and altKey for alt
+                    // need to check for alt first
+                    //if (e.which === 18) { // press ALT
+                    if (e.which === 68) { //ALT+D
+                        self.set(command.slice(0, position) +
+                                 command.slice(position).
+                                 replace(/ *[^ ]+ *(?= )|[^ ]+$/, ''), true);
+                        // chrome jump to address bar
+                        return false;
+                    }
+                    return true;
+                } else if (e.keyCode === 13) { //enter
+                    if (e.shiftKey) {
+                        self.insert('\n');
+                    } else {
+                        if (history && command && !mask &&
+                            ($.isFunction(options.historyFilter) &&
+                             options.historyFilter(command)) ||
+                            (options.historyFilter instanceof RegExp &&
+                             command.match(options.historyFilter)) ||
+                            !options.historyFilter) {
+                            history.append(command);
+                        }
+                        var tmp = command;
+                        history.reset();
+                        self.set('');
+                        if (options.commands) {
+                            options.commands(tmp);
+                        }
+                        if ($.isFunction(prompt)) {
+                            draw_prompt();
+                        }
+                    }
+                } else if (e.which === 8) { //backspace
+                    if (reverse_search) {
+                        rev_search_str = rev_search_str.slice(0, -1);
+                        draw_reverse_prompt();
+                    } else {
+                        if (command !== '' && position > 0) {
+                            self['delete'](-1);
+                        }
+                    }
+                    if (is_touch) {
+                        return true; // mobile fix
+                    }
+                } else if (e.which === 67 && e.ctrlKey && e.shiftKey) {
+                    // CTRL+SHIFT+C
+                    selected_text = get_selected_text();
+                } else if (e.which === 86 && e.ctrlKey && e.shiftKey) {
+                    if (selected_text !== '') {
+                        self.insert(selected_text);
+                    }
+                } else if (e.which === 9 && !(e.ctrlKey || e.altKey)) { // TAB
+                    self.insert('\t');
+                } else if (e.which === 46) {
+                    //DELETE
+                    self['delete'](1);
+                    return;
+                } else if (history && (e.which === 38 && !e.ctrlKey) ||
+                           (e.which === 80 && e.ctrlKey)) {
+                    //UP ARROW or CTRL+P
+                    if (first_up_history) {
+                        last_command = command;
+                        self.set(history.current());
+                    } else {
+                        self.set(history.previous());
+                    }
+                    first_up_history = false;
+                } else if (history && (e.which === 40 && !e.ctrlKey) ||
+                           (e.which === 78 && e.ctrlKey)) {
+                    //DOWN ARROW or CTRL+N
+                    self.set(history.end() ? last_command : history.next());
+                } else if (e.which === 37 || (e.which === 66 && e.ctrlKey)) {
+                    //CTRL+LEFT ARROW or CTRL+B
+                    if (e.ctrlKey && e.which !== 66) {
+                        len = position - 1;
+                        pos = 0;
+                        if (command[len] === ' ') {
+                            --len;
+                        }
+                        for (var i = len; i > 0; --i) {
+                            if (command[i] === ' ' && command[i+1] !== ' ') {
+                                pos = i + 1;
+                                break;
+                            } else if (command[i] === '\n' &&
+                                       command[i+1] !== '\n') {
+                                pos = i;
+                                break;
+                            }
+                        }
+                        self.position(pos);
+                    } else {
+                        //LEFT ARROW or CTRL+B
+                        if (position > 0) {
+                            self.position(-1, true);
+                            redraw();
+                        }
+                    }
+                } else if (e.which === 82 && e.ctrlKey) { // CTRL+R
+                    if (reverse_search) {
+                        reverse_history_search(true);
+                    } else {
+                        backup_prompt = prompt;
+                        draw_reverse_prompt();
+                        last_command = command;
+                        self.set('');
+                        redraw();
+                        reverse_search = true;
+                    }
+                } else if (e.which == 71 && e.ctrlKey) { // CTRL+G
+                    if (reverse_search) {
+                        prompt = backup_prompt;
+                        draw_prompt();
+                        self.set(last_command);
+                        redraw();
+                        reverse_search = false;
+                        rev_search_str = '';
+                    }
+                } else if (e.which === 39 ||
+                           (e.which === 70 && e.ctrlKey)) {
+                    //RIGHT ARROW OR CTRL+F
+                    if (e.ctrlKey && e.which !== 70) {
+                        // jump to beginning or end of the word
+                        if (command[position] === ' ') {
+                            ++position;
+                        }
+                        var re = /\S[\n\s]{2,}|[\n\s]+\S?/;
+                        var match = command.slice(position).match(re);
+                        if (!match || match[0].match(/^\s+$/)) {
+                            self.position(command.length);
+                        } else {
+                            if (match[0][0] !== ' ') {
+                                position += match.index + 1;
+                            } else {
+                                position += match.index + match[0].length - 1;
+                                if (match[0][match[0].length-1] !== ' ') {
+                                    --position;
+                                }
+                            }
+                        }
+                        redraw();
+                    } else {
+                        if (position < command.length) {
+                            self.position(1, true);
+                        }
+                    }
+                } else if (e.which === 123) { // F12 - Allow Firebug
+                    return;
+                } else if (e.which === 36) { // HOME
+                    self.position(0);
+                } else if (e.which === 35) { // END
+                    self.position(command.length);
+                } else if (e.shiftKey && e.which == 45) { // Shift+Insert
+                    clip.val(''); // so we get it before paste event
+                    if (!is_paste_supported) {
+                        paste();
+                    } else {
+                        clip.focus();
+                    }
+                    return;
+                } else if (e.ctrlKey || e.metaKey) {
+                    if (e.which === 192) { // CMD+` switch browser window on Mac
+                        return;
+                    }
+                    if (e.metaKey) {
+                        if(e.which === 82) { // CMD+r page reload in Chrome Mac
+                            return;
+                        } else if(e.which === 76) {
+                            // CMD+l jump into Omnibox on Chrome Mac
+                            return;
+                        }
+                    }
+                    if (e.shiftKey) { // CTRL+SHIFT+??
+                        if (e.which === 84) {
+                            //CTRL+SHIFT+T open closed tab
+                            return;
+                        }
+                    //} else if (e.altKey) { //ALT+CTRL+??
+                    } else {
+                        if (e.which === 81) { // CTRL+W
+                            // don't work in Chromium (can't prevent close tab)
+                            if (command !== '' && position !== 0) {
+                                var m = command.slice(0, position).match(/([^ ]+ *$)/);
+                                kill_text = self['delete'](-m[0].length);
+                            }
+                            return false;
+                        } else if (e.which === 72) { // CTRL+H
+                            if (command !== '' && position > 0) {
+                                self['delete'](-1);
+                            }
+                            return false;
+                        //NOTE: in opera charCode is undefined
+                        } else if (e.which === 65) {
+                            //CTRL+A
+                            self.position(0);
+                        } else if (e.which === 69) {
+                            //CTRL+E
+                            self.position(command.length);
+                        } else if (e.which === 88 || e.which === 67 ||
+                                   e.which === 84) {
+                            //CTRL+X CTRL+C CTRL+W CTRL+T
+                            return;
+                        } else if (e.which === 89) { // CTRL+Y
+                            if (kill_text !== '') {
+                                self.insert(kill_text);
+                            }
+                        } else if (e.which === 86) { // CTRL+V
+                            clip.val('');
+                            if (!is_paste_supported) {
+                                paste();
+                            } else {
+                                clip.focus();
+                            }
+                            return;
+                        } else if (e.which === 75) { // CTRL+K
+                            kill_text = self['delete'](command.length-position);
+                        } else if (e.which === 85) { // CTRL+U
+                            if (command !== '' && position !== 0) {
+                                kill_text = self['delete'](-position);
+                            }
+                        } else if (e.which === 17) { //CTRL+TAB switch tab
+                            return false;
+                        }
+                    }
+                } else {
+                    prevent_keypress = false;
+                    no_keypress = true;
+                    return;
+                }
+                // this will prevent for instance backspace to go back one page
+                //prevent_keypress = true;
+                e.preventDefault();
+            }
+        }
+        function fire_change_command() {
+            if ($.isFunction(options.onCommandChange)) {
+                options.onCommandChange(command);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Command Line Methods
+        // ---------------------------------------------------------------------
+        $.extend(self, {
+            name: function(string) {
+                if (string !== undefined) {
+                    name = string;
+                    var enabled = history && history.enabled() || !history;
+                    history = new History(string, historySize);
+                    // disable new history if old was disabled
+                    if (!enabled) {
+                        history.disable();
+                    }
+                    return self;
+                } else {
+                    return name;
+                }
+            },
+            purge: function() {
+                history.clear();
+                return self;
+            },
+            history: function() {
+                return history;
+            },
+            'delete': function(n, stay) {
+                var removed;
+                if (n === 0) {
+                    return self;
+                } else if (n < 0) {
+                    if (position > 0) {
+                        // this may look weird but if n is negative we need
+                        // to use +
+                        removed = command.slice(0, position).slice(n);
+                        command = command.slice(0, position + n) +
+                            command.slice(position, command.length);
+                        if (!stay) {
+                            self.position(position+n);
+                        } else {
+                            fire_change_command();
+                        }
+                    }
+                } else {
+                    if (command !== '' && position < command.length) {
+                        removed = command.slice(position).slice(0, n);
+                        command = command.slice(0, position) +
+                            command.slice(position + n, command.length);
+                        fire_change_command();
+                    }
+                }
+                redraw();
+                fake_mobile_entry();
+                return removed;
+            },
+            set: function(string, stay) {
+                if (string !== undefined) {
+                    command = string;
+                    if (!stay) {
+                        self.position(command.length);
+                    }
+                    redraw();
+                    fake_mobile_entry();
+                    fire_change_command();
+                }
+                return self;
+            },
+            insert: function(string, stay) {
+                if (position === command.length) {
+                    command += string;
+                } else if (position === 0) {
+                    command = string + command;
+                } else {
+                    command = command.slice(0, position) +
+                        string + command.slice(position);
+                }
+                if (!stay) {
+                    self.position(string.length, true);
+                } else {
+                    fake_mobile_entry();
+                }
+                redraw();
+                fire_change_command();
+                return self;
+            },
+            get: function() {
+                return command;
+            },
+            commands: function(commands) {
+                if (commands) {
+                    options.commands = commands;
+                    return self;
+                } else {
+                    return commands;
+                }
+            },
+            destroy: function() {
+                doc.unbind('keypress.cmd', keypress_event);
+                doc.unbind('keydown.cmd', keydown_event);
+                doc.unbind('paste.cmd', paste);
+                doc.unbind('input.cmd', input);
+                self.stopTime('blink', blink);
+                self.find('.cursor').next().remove().end().prev().remove().
+                    end().remove();
+                self.find('.prompt, .clipboard').remove();
+                self.removeClass('cmd').removeData('cmd');
+                return self;
+            },
+            prompt: function(user_prompt) {
+                if (user_prompt === undefined) {
+                    return prompt;
+                } else {
+                    if (typeof user_prompt === 'string' ||
+                        typeof user_prompt === 'function') {
+                        prompt = user_prompt;
+                    } else {
+                        throw new Error('prompt must be a function or string');
+                    }
+                    draw_prompt();
+                    // we could check if command is longer then numchars-new
+                    // prompt
+                    redraw();
+                    return self;
+                }
+            },
+            kill_text: function() {
+                return kill_text;
+            },
+            position: function(n, relative) {
+                if (typeof n === 'number') {
+                    // if (position !== n) { this don't work, don't know why
+                    if (relative) {
+                        position += n;
+                    } else {
+                        if (n < 0) {
+                            position = 0;
+                        } else if (n > command.length) {
+                            position = command.length;
+                        } else {
+                            position = n;
+                        }
+                    }
+                    if ($.isFunction(options.onPositionChange)) {
+                        options.onPositionChange(position);
+                    }
+                    redraw();
+                    fake_mobile_entry();
+                    return self;
+                } else {
+                    return position;
+                }
+            },
+            visible: (function() {
+                var visible = self.visible;
+                return function() {
+                    visible.apply(self, []);
+                    redraw();
+                    draw_prompt();
+                };
+            })(),
+            show: (function() {
+                var show = self.show;
+                return function() {
+                    show.apply(self, []);
+                    redraw();
+                    draw_prompt();
+                };
+            })(),
+            resize: function(num) {
+                if (num) {
+                    num_chars = num;
+                } else {
+                    change_num_chars();
+                }
+                redraw();
+                return self;
+            },
+            enable: function() {
+                enabled = true;
+                self.addClass('enabled');
+                animation(true);
+                mobile_focus();
+                return self;
+            },
+            isenabled: function() {
+                return enabled;
+            },
+            disable: function() {
+                enabled = false;
+                self.removeClass('enabled');
+                animation(false);
+                mobile_focus();
+                return self;
+            },
+            mask: function(new_mask) {
+                if (typeof new_mask === 'undefined') {
+                    return mask;
+                } else {
+                    mask = new_mask;
+                    redraw();
+                    return self;
+                }
+            }
+        });
+        // ---------------------------------------------------------------------
+        // :: INIT
+        // ---------------------------------------------------------------------
+        self.name(options.name || options.prompt || '');
+        if (typeof options.prompt == 'string') {
+            prompt = options.prompt;
+        } else {
+            prompt = '> ';
+        }
+        draw_prompt();
+        if (options.enabled === undefined || options.enabled === true) {
+            self.enable();
+        }
+        // Keystrokes
+        var object;
+        var doc = $(document.documentElement || window);
+        function keypress_event(e) {
+            var result;
+            no_keypress = false;
+            if (e.ctrlKey && e.which === 99) { // CTRL+C
+                return;
+            }
+            if (prevent_keypress) {
+                return;
+            }
+            if (!reverse_search && $.isFunction(options.keypress)) {
+                result = options.keypress(e);
+            }
+            //$.terminal.active().echo(JSON.stringify(result));
+            if (result === undefined || result) {
+                if (enabled) {
+                    if ($.inArray(e.which, [38, 13, 0, 8]) > -1 &&
+                        //!(e.which === 40 && e.shiftKey ||
+                        !(e.which === 38 && e.shiftKey)) {
+                        if (e.keyCode == 123) { // for F12 which == 0
+                            return;
+                        }
+                        return false;
+                    } else if (!e.ctrlKey && !(e.altKey && e.which === 100) ||
+                               e.altKey) { // ALT+D
+                        if (reverse_search) {
+                            rev_search_str += String.fromCharCode(e.which);
+                            reverse_history_search();
+                            draw_reverse_prompt();
+                        } else {
+                            self.insert(String.fromCharCode(e.which));
+                        }
+                        return false;
+                    }
+                }
+            } else {
+                return result;
+            }
+        }
+        function input(e) {
+            if (no_keypress) {
+                // Some Androids don't fire keypress - #39
+                var val = clip.val();
+                if (val || e.which == 8) {  // #209 ; 8 - backspace
+                    self.set(val);
+                }
+            }
+        }
+        doc.bind('keypress.cmd', keypress_event).bind('keydown.cmd', keydown_event).
+            bind('input.cmd', input);
+        if (is_paste_supported) {
+            doc.bind('paste.cmd', paste);
+        }
+        // characters
+        self.data('cmd', self);
+        return self;
+    }; // cmd plugin
+
+    // -------------------------------------------------------------------------
+    // :: TOOLS
+    // -------------------------------------------------------------------------
+    function skip_formatting_count(string) {
+        // this will covert html entities to single characters
+        return $('<div>' + $.terminal.strip(string) + '</div>').text().length;
+    }
+    // -------------------------------------------------------------------------
+    function formatting_count(string) {
+        return string.length - skip_formatting_count(string);
+    }
+    // -------------------------------------------------------------------------
+    // taken from https://hacks.mozilla.org/2011/09/detecting-and-generating-
+    // css-animations-in-javascript/
+    var support_animations = (function() {
+        var animation = false,
+        animationstring = 'animation',
+        keyframeprefix = '',
+        domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
+        pfx  = '',
+        elm = document.createElement('div');
+        if (elm.style.animationName) { animation = true; }
+        if (animation === false) {
+            for (var i = 0; i < domPrefixes.length; i++) {
+                var name = domPrefixes[i] + 'AnimationName';
+                if (elm.style[ name ] !== undefined) {
+                    pfx = domPrefixes[i];
+                    animationstring = pfx + 'Animation';
+                    keyframeprefix = '-' + pfx.toLowerCase() + '-';
+                    animation = true;
+                    break;
+                }
+            }
+        }
+        return animation;
+    })();
+    // -------------------------------------------------------------------------
+    var is_android = navigator.userAgent.toLowerCase().indexOf("android") != -1;
+    // -------------------------------------------------------------------------
+    var is_touch = (function() {
+        return ('ontouchstart' in window) || window.DocumentTouch &&
+            document instanceof DocumentTouch;
+    })();
+    // -------------------------------------------------------------------------
+    function process_command(string, fn) {
+        var array = fn(string);
+        if (array.length) {
+            var name = array.shift();
+            var regex = new RegExp('^' + $.terminal.escape_regex(name));
+            var rest = string.replace(regex, '').trim();
+            return {
+                command: string,
+                name: name,
+                args: array,
+                rest: rest
+            };
+        } else {
+            return {
+                command: string,
+                name: '',
+                args: [],
+                rest: ''
+            };
+        }
+    }
+    // -------------------------------------------------------------------------
+    var format_split_re = /(\[\[[!gbiuso]*;[^;]*;[^\]]*\](?:[^\]]*\\\][^\]]*|[^\]]*|[^\[]*\[[^\]]*)\]?)/i;
+    var format_parts_re = /\[\[([!gbiuso]*);([^;]*);([^;\]]*);?([^;\]]*);?([^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^\[]*\[[^\]]*)\]?/gi;
+    var format_re = /\[\[([!gbiuso]*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^\[]*\[[^\]]*)\]?/gi;
+    var format_exist_re = /\[\[([!gbiuso]*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^\[]*\[[^\]]*)\]/gi;
+    var format_full_re = /^\[\[([!gbiuso]*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^\[]*\[[^\]]*)\]$/gi;
+    var color_hex_re = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;
+    //var url_re = /https?:\/\/(?:(?!&[^;]+;)[^\s:"'<>)])+/g;
+    //var url_re = /\bhttps?:\/\/(?:(?!&[^;]+;)[^\s"'<>)])+\b/g;
+    var url_re = /(\bhttps?:\/\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\s"'<>\]\[)])+\b)/gi;
+    var url_nf_re = /\b(https?:\/\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\s"'<>\][)])+)\b(?![^[\]]*])/gi;
+    var email_re = /((([^<>('")[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,})))/g;
+    var command_re = /('[^']*'|"(\\"|[^"])*"|(?:\/(\\\/|[^\/])+\/[gimy]*)(?=:? |$)|(\\ |[^ ])+|[\w-]+)/gi;
+    var format_begin_re = /(\[\[[!gbiuso]*;[^;]*;[^\]]*\])/i;
+    var format_start_re = /^(\[\[[!gbiuso]*;[^;]*;[^\]]*\])/i;
+    var format_last_re = /\[\[[!gbiuso]*;[^;]*;[^\]]*\]?$/i;
+    var format_exec_re = /(\[\[(?:[^\]]|\\\])*\]\])/;
+    $.terminal = {
+        version: '0.10.11',
+        // colors from http://www.w3.org/wiki/CSS/Properties/color/keywords
+        color_names: [
+            'black', 'silver', 'gray', 'white', 'maroon', 'red', 'purple',
+            'fuchsia', 'green', 'lime', 'olive', 'yellow', 'navy', 'blue',
+            'teal', 'aqua', 'aliceblue', 'antiquewhite', 'aqua', 'aquamarine',
+            'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue',
+            'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse',
+            'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson',
+            'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray',
+            'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta',
+            'darkolivegreen', 'darkorange', 'darkorchid', 'darkred',
+            'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray',
+            'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink',
+            'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick',
+            'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite',
+            'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey',
+            'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki',
+            'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon',
+            'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow',
+            'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon',
+            'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey',
+            'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen',
+            'magenta', 'maroon', 'mediumaquamarine', 'mediumblue',
+            'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue',
+            'mediumspringgreen', 'mediumturquoise', 'mediumvioletred',
+            'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite',
+            'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered',
+            'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise',
+            'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum',
+            'powderblue', 'purple', 'red', 'rosybrown', 'royalblue',
+            'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell',
+            'sienna', 'silver', 'skyblue', 'slateblue', 'slategray',
+            'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal',
+            'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white',
+            'whitesmoke', 'yellow', 'yellowgreen'],
+        // ---------------------------------------------------------------------
+        // :: Validate html color (it can be name or hex)
+        // ---------------------------------------------------------------------
+        valid_color: function(color) {
+            if (color.match(color_hex_re)) {
+                return true;
+            } else {
+                return $.inArray(color.toLowerCase(),
+                                 $.terminal.color_names) !== -1;
+            }
+        },
+        // ---------------------------------------------------------------------
+        // :: Escape all special regex characters, so it can be use as regex to
+        // :: match exact string that contain those characters
+        // ---------------------------------------------------------------------
+        escape_regex: function(str) {
+            if (typeof str == 'string') {
+                var special = /([-\\\^$\[\]()+{}?*.|])/g;
+                return str.replace(special, '\\$1');
+            }
+        },
+        // ---------------------------------------------------------------------
+        // :: test if string contain formatting
+        // ---------------------------------------------------------------------
+        have_formatting: function(str) {
+            return typeof str == 'string' && !!str.match(format_exist_re);
+        },
+        is_formatting: function(str) {
+            return typeof str == 'string' && !!str.match(format_full_re);
+        },
+        // ---------------------------------------------------------------------
+        // :: return array of formatting and text between them
+        // ---------------------------------------------------------------------
+        format_split: function(str) {
+            return str.split(format_split_re);
+        },
+        // ---------------------------------------------------------------------
+        // :: split text into lines with equal length so each line can be
+        // :: rendered separately (text formatting can be longer then a line).
+        // ---------------------------------------------------------------------
+        split_equal: function(str, length, words) {
+            var formatting = false;
+            var in_text = false;
+            var prev_format = '';
+            var result = [];
+            // add format text as 5th paramter to formatting it's used for
+            // data attribute in format function
+            var array = str.replace(format_re, function(_, format, text) {
+                var semicolons = format.match(/;/g).length;
+                // missing semicolons
+                if (semicolons >= 4) {
+                    return _;
+                } else if (semicolons == 2) {
+                    semicolons = ';;';
+                } else if (semicolons == 3) {
+                    semicolons = ';';
+                } else {
+                    semicolons = '';
+                }
+                // return '[[' + format + ']' + text + ']';
+                // closing braket will break formatting so we need to escape
+                // those using html entity equvalent
+                var safe = text.replace(/\\\]/g, '&#93;').replace(/\n/g, '\\n').
+                    replace(/&nbsp;/g, ' ');
+                return '[[' + format + semicolons + safe + ']' + text + ']';
+            }).split(/\n/g);
+            function is_space() {
+                return line.substring(j-6, j) == '&nbsp;' ||
+                    line.substring(j-1, j) == ' ';
+            }
+            for (var i = 0, len = array.length; i < len; ++i) {
+                if (array[i] === '') {
+                    result.push('');
+                    continue;
+                }
+                var line = array[i];
+                var first_index = 0;
+                var count = 0;
+                var space = -1;
+                for (var j=0, jlen=line.length; j<jlen; ++j) {
+                    if (line.substring(j).match(format_start_re)) {
+                        formatting = true;
+                        in_text = false;
+                    } else if (formatting && line[j] === ']') {
+                        if (in_text) {
+                            formatting = false;
+                            in_text = false;
+                        } else {
+                            in_text = true;
+                        }
+                    } else if ((formatting && in_text) || !formatting) {
+                        if (line[j] === '&') { // treat entity as one character
+                            var m = line.substring(j).match(/^(&[^;]+;)/);
+                            if (!m) {
+                                // should never happen if used by terminal,
+                                // because it always calls $.terminal.encode
+                                // before this function
+                                throw new Error("Unclosed html entity in line " +
+                                                (i+1) + ' at char ' + (j+1));
+                            }
+                            j+=m[1].length-2; // because continue adds 1 to j
+                            // if entity is at the end there is no next loop
+                            // issue #77
+                            if (j === jlen-1) {
+                                result.push(output + m[1]);
+                            }
+                            continue;
+                        } else if (line[j] === ']' && line[j-1] === '\\') {
+                            // escape \] counts as one character
+                            --count;
+                        } else {
+                            ++count;
+                        }
+                    }
+                    if (is_space() && ((formatting && in_text) || !formatting ||
+                                      (line[j] === '[' && line[j+1] === '['))) {
+                        space = j;
+                    }
+                    if ((count === length || j === jlen-1) &&
+                        ((formatting && in_text) || !formatting)) {
+                        var output;
+                        var text = $.terminal.strip(line.substring(space));
+                        text = $('<span>' + text + '</span>').text();
+                        var text_len = text.length;
+                        text = text.substring(0, j+length+1);
+                        var can_break = !!text.match(/\s/) || j+length+1 > text_len;
+                        if (words && space != -1 && j !== jlen-1 && can_break) {
+                            output = line.substring(first_index, space);
+                            j = space-1;
+                        } else {
+                            output = line.substring(first_index, j+1);
+                        }
+                        if (words) {
+                            output = output.replace(/(&nbsp;|\s)+$/g, '');
+                        }
+                        space = -1;
+                        first_index = j+1;
+                        count = 0;
+                        if (prev_format) {
+                            output = prev_format + output;
+                            if (output.match(']')) {
+                                prev_format = '';
+                            }
+                        }
+                        // Fix output if formatting not closed
+                        var matched = output.match(format_re);
+                        if (matched) {
+                            var last = matched[matched.length-1];
+                            if (last[last.length-1] !== ']') {
+                                prev_format = last.match(format_begin_re)[1];
+                                output += ']';
+                            } else if (output.match(format_last_re)) {
+                                var line_len = output.length;
+                                // why this line ???
+                                //var f_len = line_len-last[last.length-1].length;
+                                output = output.replace(format_last_re, '');
+                                prev_format = last.match(format_begin_re)[1];
+                            }
+                        }
+                        result.push(output);
+                    }
+                }
+            }
+            return result;
+        },
+        // ---------------------------------------------------------------------
+        // :: Encode formating as html for insertion into DOM
+        // ---------------------------------------------------------------------
+        encode: function(str) {
+            // don't escape entities
+            str = str.replace(/&(?!#[0-9]+;|[a-zA-Z]+;)/g, '&amp;');
+            return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
+                .replace(/ /g, '&nbsp;')
+                .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');
+        },
+        // ---------------------------------------------------------------------
+        // :: safe function that will render text as it is
+        // ---------------------------------------------------------------------
+        escape_formatting: function(string) {
+            return $.terminal.escape_brackets($.terminal.encode(string));
+        },
+        // ---------------------------------------------------------------------
+        // :: Replace terminal formatting with html
+        // ---------------------------------------------------------------------
+        format: function(str, options) {
+            var settings = $.extend({}, {
+                linksNoReferrer: false
+            }, options || {});
+            if (typeof str === 'string') {
+                //support for formating foo[[u;;]bar]baz[[b;#fff;]quux]zzz
+                var splitted = $.terminal.format_split(str);
+                str = $.map(splitted, function(text) {
+                    if (text === '') {
+                        return text;
+                    } else if ($.terminal.is_formatting(text)) {
+                        return text.replace(format_parts_re, function(s,
+                                                                      style,
+                                                                      color,
+                                                                      background,
+                                                                      _class,
+                                                                      data_text,
+                                                                      text) {
+                            if (text === '') {
+                                return ''; //'<span>&nbsp;</span>';
+                            }
+                            text = text.replace(/\\]/g, ']');
+                            var style_str = '';
+                            if (style.indexOf('b') !== -1) {
+                                style_str += 'font-weight:bold;';
+                            }
+                            var text_decoration = [];
+                            if (style.indexOf('u') !== -1) {
+                                text_decoration.push('underline');
+                            }
+                            if (style.indexOf('s') !== -1) {
+                                text_decoration.push('line-through');
+                            }
+                            if (style.indexOf('o') !== -1) {
+                                text_decoration.push('overline');
+                            }
+                            if (text_decoration.length) {
+                                style_str += 'text-decoration:' +
+                                    text_decoration.join(' ') + ';';
+                            }
+                            if (style.indexOf('i') !== -1) {
+                                style_str += 'font-style:italic;';
+                            }
+                            if ($.terminal.valid_color(color)) {
+                                style_str += 'color:' + color + ';';
+                                if (style.indexOf('g') !== -1) {
+                                    style_str += 'text-shadow:0 0 5px ' + color + ';';
+                                }
+                            }
+                            if ($.terminal.valid_color(background)) {
+                                style_str += 'background-color:' + background;
+                            }
+                            var data;
+                            if (data_text === '') {
+                                data = text;
+                            } else {
+                                data = data_text.replace(/&#93;/g, ']');
+                            }
+                            var result;
+                            if (style.indexOf('!') !== -1) {
+                                if (data.match(email_re)) {
+                                    result = '<a href="mailto:' + data + '" ';
+                                } else {
+                                    result = '<a target="_blank" href="' + data + '" ';
+                                    if (settings.linksNoReferrer) {
+                                        result += 'rel="noreferrer" ';
+                                    }
+                                }
+                            } else {
+                                result = '<span ';
+                            }
+                            if (style_str !== '') {
+                                result += 'style="' + style_str + '"';
+                            }
+                            if (_class !== '') {
+                                result += ' class="' + _class + '"';
+                            }
+                            if (style.indexOf('!') !== -1) {
+                                result += '>' + text + '</a>';
+                            } else {
+                                result += ' data-text="' +
+                                    data.replace('"', '&quote;') + '">' +
+                                    text + '</span>';
+                            }
+                            return result;
+                        });
+                    } else {
+                        return '<span>' + text.replace(/\\\]/g, ']') + '</span>';
+                    }
+                }).join('');
+                return str.replace(/<span><br\s*\/?><\/span>/gi, '<br/>');
+            } else {
+                return '';
+            }
+        },
+        // ---------------------------------------------------------------------
+        // :: Replace brackets with html entities
+        // ---------------------------------------------------------------------
+        escape_brackets: function(string) {
+            return string.replace(/\[/g, '&#91;').replace(/\]/g, '&#93;');
+        },
+        // ---------------------------------------------------------------------
+        // :: Remove formatting from text
+        // ---------------------------------------------------------------------
+        strip: function(str) {
+            return str.replace(format_parts_re, '$6');
+        },
+        // ---------------------------------------------------------------------
+        // :: Return active terminal
+        // ---------------------------------------------------------------------
+        active: function() {
+            return terminals.front();
+        },
+        // keep old as backward compatible
+        parseArguments: function(string) {
+            return $.terminal.parse_arguments(string);
+        },
+        splitArguments: function(string) {
+            return $.terminal.split_arguments(string);
+        },
+        parseCommand: function(string) {
+            return $.terminal.parse_command(string);
+        },
+        splitCommand: function(string) {
+            return $.terminal.split_command(string);
+        },
+        // ---------------------------------------------------------------------
+        // :: Function splits arguments and works with strings like
+        // :: 'asd' 'asd\' asd' "asd asd" asd\ 123 -n -b / [^ ]+ / /\s+/ asd\ a
+        // :: it creates a regex and numbers and replaces escape characters in
+        // :: double quotes
+        // ---------------------------------------------------------------------
+        parse_arguments: function(string) {
+            var float_re = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
+            return $.map(string.match(command_re) || [], function(arg) {
+                if (arg[0] === "'" && arg[arg.length-1] === "'") {
+                    return arg.replace(/^'|'$/g, '');
+                } else if (arg[0] === '"' && arg[arg.length-1] === '"') {
+                    arg = arg.replace(/^"|"$/g, '').replace(/\\([" ])/g, '$1');
+                    return arg.replace(/\\\\|\\t|\\n/g, function(string) {
+                        if (string[1] === 't') {
+                            return '\t';
+                        } else if (string[1] === 'n') {
+                            return '\n';
+                        } else {
+                            return '\\';
+                        }
+                    }).replace(/\\x([0-9a-f]+)/gi, function(_, hex) {
+                        return String.fromCharCode(parseInt(hex, 16));
+                    }).replace(/\\0([0-7]+)/g, function(_, oct) {
+                        return String.fromCharCode(parseInt(oct, 8));
+                    });
+                } else if (arg.match(/^\/(\\\/|[^\/])+\/[gimy]*$/)) { // RegEx
+                    var m = arg.match(/^\/([^\/]+)\/([^\/]*)$/);
+                    return new RegExp(m[1], m[2]);
+                } else if (arg.match(/^-?[0-9]+$/)) {
+                    return parseInt(arg, 10);
+                } else if (arg.match(float_re)) {
+                    return parseFloat(arg);
+                } else {
+                    return arg.replace(/\\ /g, ' ');
+                }
+            });
+        },
+        // ---------------------------------------------------------------------
+        // :: Split arguments: it only strips single and double quotes and
+        // :: escapes spaces
+        // ---------------------------------------------------------------------
+        split_arguments: function(string) {
+            return $.map(string.match(command_re) || [], function(arg) {
+                if (arg[0] === "'" && arg[arg.length-1] === "'") {
+                    return arg.replace(/^'|'$/g, '');
+                } else if (arg[0] === '"' && arg[arg.length-1] === '"') {
+                    return arg.replace(/^"|"$/g, '').replace(/\\([" ])/g, '$1');
+                } else if (arg.match(/\/.*\/[gimy]*$/)) {
+                    return arg;
+                } else {
+                    return arg.replace(/\\ /g, ' ');
+                }
+            });
+        },
+        // ---------------------------------------------------------------------
+        // :: Function that returns an object {name,args}. Arguments are parsed
+        // :: using the function parse_arguments
+        // ---------------------------------------------------------------------
+        parse_command: function(string) {
+            return process_command(string, $.terminal.parse_arguments);
+        },
+        // ---------------------------------------------------------------------
+        // :: Same as parse_command but arguments are parsed using split_arguments
+        // ---------------------------------------------------------------------
+        split_command: function(string) {
+            return process_command(string, $.terminal.split_arguments);
+        },
+        // ---------------------------------------------------------------------
+        // :: function executed for each text inside [{ .... }]
+        // ---------------------------------------------------------------------
+        extended_command: function(term, string) {
+            try {
+                change_hash = false;
+                term.exec(string, true).then(function() {
+                    change_hash = true;
+                });
+            } catch(e) {
+                // error is process in exec
+            }
+        }
+    };
+
+    // -----------------------------------------------------------------------
+    // Helper plugins
+    // -----------------------------------------------------------------------
+    $.fn.visible = function() {
+        return this.css('visibility', 'visible');
+    };
+    $.fn.hidden = function() {
+        return this.css('visibility', 'hidden');
+    };
+    // -----------------------------------------------------------------------
+    // JSON-RPC CALL
+    // -----------------------------------------------------------------------
+    var ids = {}; // list of url based id of JSON-RPC
+    $.jrpc = function(url, method, params, success, error) {
+        ids[url] = ids[url] || 0;
+        var request = $.json_stringify({
+           'jsonrpc': '2.0', 'method': method,
+            'params': params, 'id': ++ids[url]});
+        return $.ajax({
+            url: url,
+            data: request,
+            success: function(result, status, jqXHR) {
+                var content_type = jqXHR.getResponseHeader('Content-Type');
+                if (!content_type.match(/application\/json/)) {
+                    var msg = 'Response Content-Type is not application/json';
+                    if (console && console.warn) {
+                        console.warn(msg);
+                    } else {
+                        throw new Error('WARN: ' + msg);
+                    }
+                }
+                var json;
+                try {
+                    json = $.parseJSON(result);
+                } catch (e) {
+                    if (error) {
+                        error(jqXHR, 'Invalid JSON', e);
+                    } else {
+                        throw new Error('Invalid JSON');
+                    }
+                    return;
+                }
+                // don't catch errors in success callback
+                success(json, status, jqXHR);
+            },
+            error: error,
+            contentType: 'application/json',
+            dataType: 'text',
+            async: true,
+            cache: false,
+            //timeout: 1,
+            type: 'POST'});
+    };
+
+    // -----------------------------------------------------------------------
+    function is_scrolled_into_view(elem) {
+        var docViewTop = $(window).scrollTop();
+        var docViewBottom = docViewTop + $(window).height();
+
+        var elemTop = $(elem).offset().top;
+        var elemBottom = elemTop + $(elem).height();
+
+        return ((elemBottom >= docViewTop) && (elemTop <= docViewBottom));
+    }
+    // -----------------------------------------------------------------------
+    // :: Create fake terminal to calcualte the dimention of one character
+    // :: this will make terminal work if terminal div is not added to the
+    // :: DOM at init like with:
+    // :: $('<div/>').terminal().echo('foo bar').appendTo('body');
+    // -----------------------------------------------------------------------
+    function char_size() {
+        var temp = $('<div class="terminal temp"><div class="cmd"><span cla' +
+                     'ss="cursor">&nbsp;</span></div></div>').appendTo('body');
+        var span = temp.find('span');
+        var result = {
+            width: span.width(),
+            height: span.outerHeight()
+        };
+        temp.remove();
+        return result;
+    }
+    // -----------------------------------------------------------------------
+    // :: calculate numbers of characters
+    // -----------------------------------------------------------------------
+    function get_num_chars(terminal) {
+        var temp = $('<div class="terminal"><span class="cursor">' +
+                     '</span></div>').appendTo('body').css('padding', 0);
+        var span = temp.find('span');
+        // use more characters to get width of single character as a fraction
+        var max = 60;
+        var spaces = '';
+        for (var i=0;i<=max; ++i) {
+            spaces += '&nbsp;';
+        }
+        span.html(spaces);
+        var width = span.width()/max;
+        var result = Math.floor(terminal.width() / width);
+        temp.remove();
+        if (have_scrollbars(terminal)) {
+            var SCROLLBAR_WIDTH = 20;
+            // assume that scrollbars are 20px - in my Laptop with
+            // Linux/Chrome they are 16px
+            var margins = terminal.innerWidth() - terminal.width();
+            result -= Math.ceil((SCROLLBAR_WIDTH - margins / 2) / (width-1));
+        }
+        return result;
+    }
+    // -----------------------------------------------------------------------
+    // :: Calculate number of lines that fit without scroll
+    // -----------------------------------------------------------------------
+    function get_num_rows(terminal) {
+        return Math.floor(terminal.height() / char_size().height);
+    }
+    // -----------------------------------------------------------------------
+    // :: Get Selected Text (this is internal because it return text even if
+    // :: it's outside of terminal, is used to paste text to the terminal)
+    // -----------------------------------------------------------------------
+    function get_selected_text() {
+        if (window.getSelection || document.getSelection) {
+            var selection = (window.getSelection || document.getSelection)();
+            if (selection.text) {
+                return selection.text;
+            } else {
+                return selection.toString();
+            }
+        } else if (document.selection) {
+            return document.selection.createRange().text;
+        }
+    }
+    // -----------------------------------------------------------------------
+    // :: check if div have scrollbars (need to have overflow auto or always)
+    // -----------------------------------------------------------------------
+    function have_scrollbars(div) {
+        if (div.css('overflow') == 'scroll' ||
+            div.css('overflow-y') == 'scroll') {
+            return true;
+        } else if (div.is('body')) {
+            return $("body").height() > $(window).height();
+        } else {
+            return div.get(0).scrollHeight > div.innerHeight();
+        }
+    }
+    // -----------------------------------------------------------------------
+    // :: TERMINAL PLUGIN CODE
+    // -----------------------------------------------------------------------
+    var version_set = !$.terminal.version.match(/^\{\{/);
+    var copyright = 'Copyright (c) 2011-2016 Jakub Jankiewicz <http://jcubic'+
+        '.pl>';
+    var version_string = version_set ? ' v. ' + $.terminal.version : ' ';
+    //regex is for placing version string aligned to the right
+    var reg = new RegExp(" {" + version_string.length + "}$");
+    var name_ver = 'jQuery Terminal Emulator' +
+        (version_set ? version_string : '');
+    // -----------------------------------------------------------------------
+    // :: Terminal Signatures
+    // -----------------------------------------------------------------------
+    var signatures = [
+        ['jQuery Terminal', '(c) 2011-2016 jcubic'],
+        [name_ver, copyright.replace(/^Copyright | *<.*>/g, '')],
+        [name_ver, copyright.replace(/^Copyright /, '')],
+        ['      _______                 ________                        __',
+         '     / / _  /_ ____________ _/__  ___/______________  _____  / /',
+         ' __ / / // / // / _  / _/ // / / / _  / _/     / /  \\/ / _ \\/ /',
+         '/  / / // / // / ___/ // // / / / ___/ // / / / / /\\  / // / /__',
+         '\\___/____ \\\\__/____/_/ \\__ / /_/____/_//_/ /_/ /_/  \\/\\__\\_\\___/',
+         '         \\/          /____/                                   '.replace(reg, ' ') +
+         version_string,
+         copyright],
+        ['      __ _____                     ________                              __',
+         '     / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /',
+         ' __ / // // // // // _  // _// // / / // _  // _//     // //  \\/ // _ \\/ /',
+         '/  / // // // // // ___// / / // / / // ___// / / / / // // /\\  // // / /__',
+         '\\___//____ \\\\___//____//_/ _\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\__\\_\\___/',
+         '          \\/              /____/                                          '.replace(reg, '') +
+         version_string,
+         copyright]
+    ];
+    // -----------------------------------------------------------------------
+    // :: Default options
+    // -----------------------------------------------------------------------
+    $.terminal.defaults = {
+        prompt: '> ',
+        history: true,
+        exit: true,
+        clear: true,
+        enabled: true,
+        historySize: 60,
+        maskChar: '*',
+        checkArity: true,
+        raw: false,
+        exceptionHandler: null,
+        cancelableAjax: true,
+        processArguments: true,
+        linksNoReferrer: false,
+        processRPCResponse: null,
+        Token: true, // where this came from?
+        convertLinks: true,
+        historyState: false,
+        login: null,
+        outputLimit: -1,
+        formatters: [],
+        onAjaxError: null,
+        onRPCError: null,
+        completion: false,
+        historyFilter: null,
+        onInit: $.noop,
+        onClear: $.noop,
+        onBlur: $.noop,
+        onFocus: $.noop,
+        onTerminalChange: $.noop,
+        onExit: $.noop,
+        keypress: $.noop,
+        keydown: $.noop,
+        strings: {
+            wrongPasswordTryAgain: "Wrong password try again!",
+            wrongPassword: "Wrong password!",
+            ajaxAbortError: "Error while aborting ajax call!",
+            wrongArity: "Wrong number of arguments. Function '%s' expects %s got"+
+                " %s!",
+            commandNotFound: "Command '%s' Not Found!",
+            oneRPCWithIgnore: "You can use only one rpc with ignoreSystemDescr"+
+                "ibe",
+            oneInterpreterFunction: "You can't use more than one function (rpc"+
+                "with ignoreSystemDescribe counts as one)",
+            loginFunctionMissing: "You didn't specify a login function",
+            noTokenError: "Access denied (no token)",
+            serverResponse: "Server responded",
+            wrongGreetings: "Wrong value of greetings parameter",
+            notWhileLogin: "You can't call `%s' function while in login",
+            loginIsNotAFunction: "Authenticate must be a function",
+            canExitError: "You can't exit from main interpreter",
+            invalidCompletion: "Invalid completion",
+            invalidSelector: 'Sorry, but terminal said that "%s" is not valid '+
+                'selector!',
+            invalidTerminalId: 'Invalid Terminal ID',
+            login: "login",
+            password: "password",
+            recursiveCall: 'Recursive call detected, skip'
+        }
+    };
+    // -------------------------------------------------------------------------
+    // :: All terminal globals
+    // -------------------------------------------------------------------------
+    var requests = []; // for canceling on CTRL+D
+    var terminals = window.terminals = new Cycle(); // list of terminals global in this scope
+    // state for all terminals, terminals can't have own array fo state because
+    // there is only one popstate event
+    var save_state = []; // hold objects returned by export_view by history API
+    var hash_commands;
+    var change_hash = false; // don't change hash on Init
+    var fire_hash_change = true;
+    var first_instance = true; // used by history state
+    $.fn.terminal = function(init_interpreter, options) {
+        // ---------------------------------------------------------------------
+        // :: helper function
+        // ---------------------------------------------------------------------
+        function get_processed_command(command) {
+            if ($.isFunction(settings.processArguments)) {
+                return process_command(command, settings.processArguments);
+            } else if (settings.processArguments) {
+                return $.terminal.parse_command(command);
+            } else {
+                return $.terminal.split_command(command);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Display object on terminal
+        // ---------------------------------------------------------------------
+        function display_object(object) {
+            if (typeof object === 'string') {
+                self.echo(object);
+            } else if (object instanceof Array) {
+                self.echo($.map(object, function(object) {
+                    return $.json_stringify(object);
+                }).join(' '));
+            } else if (typeof object === 'object') {
+                self.echo($.json_stringify(object));
+            } else {
+                self.echo(object);
+            }
+        }
+        // Display line code in the file if line numbers are present
+        function print_line(url_spec) {
+            var re = /(.*):([0-9]+):([0-9]+)$/;
+            // google chrome have line and column after filename
+            var m = url_spec.match(re);
+            if (m) {
+                // TODO: do we need to call pause/resume or return promise?
+                self.pause();
+                $.get(m[1], function(response) {
+                    var prefix = location.href.replace(/[^\/]+$/, '');
+                    var file = m[1].replace(prefix, '');
+                    self.echo('[[b;white;]' + file + ']');
+                    var code = response.split('\n');
+                    var n = +m[2]-1;
+                    self.echo(code.slice(n-2, n+3).map(function(line, i) {
+                        if (i == 2) {
+                            line = '[[;#f00;]' +
+                                $.terminal.escape_brackets(line) + ']';
+                        }
+                        return '[' + (n+i) + ']: ' + line;
+                    }).join('\n')).resume();
+                }, 'text');
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Helper function
+        // ---------------------------------------------------------------------
+        function display_json_rpc_error(error) {
+            if ($.isFunction(settings.onRPCError)) {
+                settings.onRPCError.call(self, error);
+            } else {
+                self.error('&#91;RPC&#93; ' + error.message);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Create interpreter function from url string
+        // ---------------------------------------------------------------------
+        function make_basic_json_rpc(url, auth) {
+            var interpreter = function(method, params) {
+                self.pause();
+                $.jrpc(url, method, params, function(json) {
+                    if (json.error) {
+                        display_json_rpc_error(json.error);
+                    } else {
+                        if ($.isFunction(settings.processRPCResponse)) {
+                            settings.processRPCResponse.call(self, json.result, self);
+                        } else {
+                            display_object(json.result);
+                        }
+                    }
+                    self.resume();
+                }, ajax_error);
+            };
+            //this is the interpreter function
+            return function(command, terminal) {
+                if (command === '') {
+                    return;
+                }
+                try {
+                    command = get_processed_command(command);
+                } catch(e) {
+                    // exception can be thrown on invalid regex
+                    terminal.error(e.toString());
+                    return;
+                    //throw e; // this will show stack in other try..catch
+                }
+                if (!auth || command.name === 'help') {
+                    // allows to call help without a token
+                    interpreter(command.name, command.args);
+                } else {
+                    var token = terminal.token();
+                    if (token) {
+                        interpreter(command.name, [token].concat(command.args));
+                    } else {
+                        //should never happen
+                        terminal.error('&#91;AUTH&#93; ' +
+                                       strings.noTokenError);
+                    }
+                }
+            };
+        }
+        // ---------------------------------------------------------------------
+        // :: Create interpreter function from Object. If the value is object
+        // :: it will create nested interpreters
+        // ---------------------------------------------------------------------
+        function make_object_interpreter(object, arity, login, fallback) {
+            // function that maps commands to object methods
+            // it keeps terminal context
+            return function(user_command, terminal) {
+                if (user_command === '') {
+                    return;
+                }
+                //command = split_command_line(command);
+                var command;
+                try {
+                    command = get_processed_command(user_command);
+                } catch(e) {
+                    // exception can be thrown on invalid regex
+                    self.error(e.toString());
+                    return;
+                    //throw e; // this will show stack in other try..catch
+                }
+                /*
+                if (login) {
+                    var token = self.token(true);
+                    if (token) {
+                        command.args = [token].concat(command.args);
+                    } else {
+                        terminal.error('&#91;AUTH&#93; ' + strings.noTokenError);
+                        return;
+                    }
+                }*/
+                var val = object[command.name];
+                var type = $.type(val);
+                if (type === 'function') {
+                    if (arity && val.length !== command.args.length) {
+                        self.error("&#91;Arity&#93; " +
+                                   sprintf(strings.wrongArity,
+                                           command.name,
+                                           val.length,
+                                           command.args.length));
+                    } else {
+                        return val.apply(self, command.args);
+                    }
+                } else if (type === 'object' || type === 'string') {
+                    var commands = [];
+                    if (type === 'object') {
+                        commands = Object.keys(val);
+                        val = make_object_interpreter(val,
+                                                      arity,
+                                                      login);
+                    }
+                    terminal.push(val, {
+                        prompt: command.name + '> ',
+                        name: command.name,
+                        completion: type === 'object' ? commands : undefined
+                    });
+                } else {
+                    if ($.isFunction(fallback)) {
+                        fallback(user_command, self);
+                    } else if ($.isFunction(settings.onCommandNotFound)) {
+                        settings.onCommandNotFound(user_command, self);
+                    } else {
+                        terminal.error(sprintf(strings.commandNotFound,
+                                               command.name));
+                    }
+                }
+            };
+        }
+        // ---------------------------------------------------------------------
+        function ajax_error(xhr, status, error) {
+            self.resume(); // onAjaxError can use pause/resume call it first
+            if ($.isFunction(settings.onAjaxError)) {
+                settings.onAjaxError.call(self, xhr, status, error);
+            } else if (status !== 'abort') {
+                self.error('&#91;AJAX&#93; ' + status + ' - ' +
+                           strings.serverResponse + ': \n' +
+                           $.terminal.escape_brackets(xhr.responseText));
+            }
+        }
+        // ---------------------------------------------------------------------
+        function make_json_rpc_object(url, auth, success) {
+            $.jrpc(url, 'system.describe', [], function(ret) {
+                var commands = [];
+                if (ret.procs) {
+                    var interpreter_object = {};
+                    $.each(ret.procs, function(_, proc) {
+                        interpreter_object[proc.name] = function() {
+                            var append = auth && proc.name != 'help';
+                            var args = Array.prototype.slice.call(arguments);
+                            var args_len = args.length + (append ? 1 : 0);
+                            if (settings.checkArity && proc.params &&
+                                proc.params.length !== args_len) {
+                                self.error("&#91;Arity&#93; " +
+                                           sprintf(strings.wrongArity,
+                                                   proc.name,
+                                                   proc.params.length,
+                                                   args_len));
+                            } else {
+                                self.pause();
+                                if (append) {
+                                    var token = self.token(true);
+                                    if (token) {
+                                        args = [token].concat(args);
+                                    } else {
+                                        self.error('&#91;AUTH&#93; ' +
+                                                   strings.noTokenError);
+                                    }
+                                }
+                                $.jrpc(url, proc.name, args, function(json) {
+                                    if (json.error) {
+                                        display_json_rpc_error(json.error);
+                                    } else {
+                                        display_object(json.result);
+                                    }
+                                    self.resume();
+                                }, ajax_error);
+                            }
+                        };
+                    });
+                    success(interpreter_object);
+                } else {
+                    success(null);
+                }
+            }, function() {
+                success(null);
+            });
+        }
+        // ---------------------------------------------------------------------
+        function make_interpreter(user_intrp, login, finalize) {
+            finalize = finalize || $.noop;
+            var type = $.type(user_intrp);
+            var result = {};
+            var rpc_count = 0; // only one rpc can be use for array
+            var fn_interpreter;
+            if (type === 'array') {
+                var object = {};
+                // recur will be called when previous acync call is finished
+                (function recur(interpreters, success) {
+                    if (interpreters.length) {
+                        var first = interpreters[0];
+                        var rest = interpreters.slice(1);
+                        var type = $.type(first);
+                        if (type === 'string') {
+                            rpc_count++;
+                            self.pause();
+                            if (settings.ignoreSystemDescribe) {
+                                if (rpc_count === 1) {
+                                    fn_interpreter = make_basic_json_rpc(first, login);
+                                } else {
+                                    self.error(strings.oneRPCWithIgnore);
+                                }
+                                recur(rest, success);
+                            } else {
+                                make_json_rpc_object(first, login, function(new_obj) {
+                                    // will ignore rpc in array that don't have
+                                    // system.describe
+                                    if (new_obj) {
+                                        $.extend(object, new_obj);
+                                    }
+                                    self.resume();
+                                    recur(rest, success);
+                                });
+                            }
+                        } else if (type === 'function') {
+                            if (fn_interpreter) {
+                                self.error(strings.oneInterpreterFunction);
+                            } else {
+                                fn_interpreter = first;
+                            }
+                            recur(rest, success);
+                        } else if (type === 'object') {
+                            $.extend(object, first);
+                            recur(rest, success);
+                        }
+                    } else {
+                        success();
+                    }
+                })(user_intrp, function() {
+                    finalize({
+                        interpreter: make_object_interpreter(object,
+                                                             false,
+                                                             login,
+                                                             fn_interpreter),
+                        completion: Object.keys(object)
+                    });
+                });
+            } else if (type === 'string') {
+                if (settings.ignoreSystemDescribe) {
+                    finalize({
+                        interpreter: make_basic_json_rpc(user_intrp, login),
+                        completion: settings.completion
+                    });
+                } else {
+                    self.pause();
+                    make_json_rpc_object(user_intrp, login, function(object) {
+                        if (object) {
+                            result.interpreter = make_object_interpreter(object,
+                                                                         false,
+                                                                         login);
+                            result.completion = Object.keys(object);
+                        } else {
+                            // no procs in system.describe
+                            result.interpreter = make_basic_json_rpc(user_intrp, login);
+                            result.completion = settings.completion;
+                        }
+                        finalize(result);
+                        self.resume();
+                    });
+                }
+            } else if (type === 'object') {
+                finalize({
+                    interpreter: make_object_interpreter(user_intrp,
+                                                         settings.checkArity),
+                    completion: Object.keys(user_intrp)
+                });
+            } else {
+                // allow $('<div/>').terminal();
+                if (type === 'undefined') {
+                    user_intrp = $.noop;
+                } else if (type !== 'function') {
+                    throw type + " is invalid interpreter value";
+                }
+                finalize({
+                    interpreter: user_intrp,
+                    completion: settings.completion
+                });
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Create JSON-RPC authentication function
+        // ---------------------------------------------------------------------
+        function make_json_rpc_login(url, login) {
+            var method = $.type(login) === 'boolean' ? 'login' : login;
+            return function(user, passwd, callback, term) {
+                self.pause();
+                $.jrpc(url,
+                       method,
+                       [user, passwd],
+                       function(response) {
+                           if (!response.error && response.result) {
+                               callback(response.result);
+                           } else {
+                               // null will trigger message that login fail
+                               callback(null);
+                           }
+                           self.resume();
+                       }, ajax_error);
+            };
+            //default name is login so you can pass true
+        }
+        // ---------------------------------------------------------------------
+        // :: Return exception message as string
+        // ---------------------------------------------------------------------
+        function exception_message(e) {
+            if (typeof e === 'string') {
+                return e;
+            } else if (typeof e.fileName === 'string') {
+                return e.fileName + ': ' + e.message;
+            } else {
+                return e.message;
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: display Exception on terminal
+        // ---------------------------------------------------------------------
+        function display_exception(e, label) {
+            if ($.isFunction(settings.exceptionHandler)) {
+                settings.exceptionHandler.call(self, e);
+            } else {
+                self.exception(e, label);
+            }
+        }
+        // ---------------------------------------------------------------------
+        function scroll_to_bottom() {
+            var scrollHeight;
+            if (scroll_object.prop) {
+                scrollHeight = scroll_object.prop('scrollHeight');
+            } else {
+                scrollHeight = scroll_object.attr('scrollHeight');
+            }
+            scroll_object.scrollTop(scrollHeight);
+        }
+        // ---------------------------------------------------------------------
+        // :: validating if object is a string or a function, call that function
+        // :: and display the exeption if any
+        // ---------------------------------------------------------------------
+        function validate(label, object) {
+            try {
+                if ($.isFunction(object)) {
+                    object(function() {
+                        // don't care
+                    });
+                } else if (typeof object !== 'string') {
+                    var msg = label + ' must be string or function';
+                    throw msg;
+                }
+            } catch (e) {
+                display_exception(e, label.toUpperCase());
+                return false;
+            }
+            return true;
+        }
+        // ---------------------------------------------------------------------
+        // :: Draw line - can have line breaks and be longer than the width of
+        // :: the terminal, there are 2 options raw and finalize
+        // :: raw - will not encode the string and finalize if a function that
+        // :: will have div container of the line as first argument
+        // :: NOTE: it formats and appends lines to output_buffer. The actual
+        // :: append to terminal output happens in the flush function
+        // ---------------------------------------------------------------------
+        var output_buffer = [];
+        var NEW_LINE = 1;
+        function buffer_line(string, options) {
+            // urls should always have formatting to keep url if split
+            if (settings.convertLinks) {
+                string = string.replace(email_re, '[[!;;]$1]').
+                    replace(url_nf_re, '[[!;;]$1]');
+            }
+            var formatters = $.terminal.defaults.formatters;
+            var i, len;
+            if (!options.raw) {
+                // format using user defined formatters
+                for (i=0; i<formatters.length; ++i) {
+                    try {
+                        if (typeof formatters[i] == 'function') {
+                            var ret = formatters[i](string);
+                            if (typeof ret == 'string') {
+                                string = ret;
+                            }
+                        }
+                    } catch(e) {
+                        //display_exception(e, 'FORMATTING');
+                        alert('formatting error at formatters[' + i + ']\n' +
+                              (e.stack ? e.stack : e));
+                    }
+                }
+                string = $.terminal.encode(string);
+            }
+            output_buffer.push(NEW_LINE);
+            if (!options.raw && (string.length > num_chars ||
+                                       string.match(/\n/))) {
+                var words = options.keepWords;
+                var array = $.terminal.split_equal(string, num_chars, words);
+                for (i = 0, len = array.length; i < len; ++i) {
+                    if (array[i] === '' || array[i] === '\r') {
+                        output_buffer.push('<span></span>');
+                    } else {
+                        if (options.raw) {
+                            output_buffer.push(array[i]);
+                        } else {
+                            output_buffer.push($.terminal.format(array[i], {
+                                linksNoReferrer: settings.linksNoReferrer
+                            }));
+                        }
+                    }
+                }
+            } else {
+                if (!options.raw) {
+                    string = $.terminal.format(string, {
+                        linksNoReferrer: settings.linksNoReferrer
+                    });
+                }
+                output_buffer.push(string);
+            }
+            output_buffer.push(options.finalize);
+        }
+        // ---------------------------------------------------------------------
+        function process_line(line, options) {
+            // prevent exception in display exception
+            try {
+                var line_settings = $.extend({
+                    exec: true,
+                    raw: false,
+                    finalize: $.noop
+                }, options || {});
+                var string = $.type(line) === "function" ? line() : line;
+                string = $.type(string) === "string" ? string : String(string);
+                if (string !== '') {
+                    if (line_settings.exec) {
+                        string = $.map(string.split(format_exec_re), function(string) {
+                            if (string.match(format_exec_re) &&
+                                !$.terminal.is_formatting(string)) {
+                                // redraw should not execute commands and it have
+                                // and lines variable have all extended commands
+                                string = string.replace(/^\[\[|\]\]$/g, '');
+                                if (prev_command && prev_command.command == string) {
+                                    self.error(strings.recursiveCall);
+                                } else {
+                                    $.terminal.extended_command(self, string);
+                                }
+                                return '';
+                            } else {
+                                return string;
+                            }
+                        }).join('');
+                        if (string !== '') {
+                            // string can be empty after removing extended commands
+                            buffer_line(string, line_settings);
+                        }
+                    } else {
+                        buffer_line(string, line_settings);
+                    }
+                }
+            } catch (e) {
+                output_buffer = [];
+                // don't display exception if exception throw in terminal
+                alert('[Internal Exception(process_line)]:' +
+                      exception_message(e) + '\n' + e.stack);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Redraw all lines
+        // ---------------------------------------------------------------------
+        function redraw() {
+            command_line.resize(num_chars);
+            // we don't want reflow while processing lines
+            var detached_output = output.empty().detach();
+            var lines_to_show;
+            if (settings.outputLimit >= 0) {
+                // flush will limit lines but if there is lot of
+                // lines we don't need to show them and then remove
+                // them from terminal
+                var limit = settings.outputLimit === 0 ?
+                    self.rows() :
+                    settings.outputLimit;
+                lines_to_show = lines.slice(lines.length-limit-1);
+            } else {
+                lines_to_show = lines;
+            }
+            try {
+                output_buffer = [];
+                $.each(lines_to_show, function(i, line) {
+                    process_line.apply(null, line); // line is an array
+                });
+                command_line.before(detached_output); // reinsert output
+                self.flush();
+            } catch(e) {
+                alert('Exception in redraw\n' + e.stack);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Display user greetings or terminal signature
+        // ---------------------------------------------------------------------
+        function show_greetings() {
+            if (settings.greetings === undefined) {
+                self.echo(self.signature);
+            } else if (settings.greetings) {
+                var type = typeof settings.greetings;
+                if (type === 'string') {
+                    self.echo(settings.greetings);
+                } else if (type === 'function') {
+                    settings.greetings.call(self, self.echo);
+                } else {
+                    self.error(strings.wrongGreetings);
+                }
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Display prompt and last command
+        // ---------------------------------------------------------------------
+        function echo_command(command) {
+            var prompt = command_line.prompt();
+            var mask = command_line.mask();
+            switch (typeof mask) {
+                case 'string':
+                    command = command.replace(/./g, mask);
+                    break;
+                case 'boolean':
+                    if (mask) {
+                        command = command.replace(/./g, settings.maskChar);
+                    } else {
+                        command = $.terminal.escape_formatting(command);
+                    }
+                    break;
+            }
+            var options = {
+                finalize: function(div) {
+                    div.addClass('command');
+                }
+            };
+            if ($.isFunction(prompt)) {
+                prompt(function(string) {
+                    self.echo(string + command, options);
+                });
+            } else {
+                self.echo(prompt + command, options);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Helper function that restore state. Call import_view or exec
+        // ---------------------------------------------------------------------
+        function restore_state(spec) {
+            // spec [terminal_id, state_index, command]
+            var terminal = terminals.get()[spec[0]];
+            if (!terminal) {
+                throw new Error(strings.invalidTerminalId);
+            }
+            var command_idx = spec[1];
+            if (save_state[command_idx]) { // state exists
+                terminal.import_view(save_state[command_idx]);
+            } else {
+                // restore state
+                change_hash = false;
+                var command = spec[2];
+                if (command) {
+                    terminal.exec(command).then(function() {
+                        change_hash = true;
+                        save_state[command_idx] = terminal.export_view();
+                    });
+                }
+            }
+            /*if (spec[3].length) {
+                restore_state(spec[3]);
+            }*/
+        }
+        // ---------------------------------------------------------------------
+        // :: Helper function
+        // ---------------------------------------------------------------------
+        function maybe_update_hash() {
+            if (change_hash) {
+                fire_hash_change = false;
+                location.hash = $.json_stringify(hash_commands);
+                setTimeout(function() {
+                    fire_hash_change = true;
+                }, 100);
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Wrapper over interpreter, it implements exit and catches all
+        // :: exeptions from user code and displays them on the terminal
+        // ---------------------------------------------------------------------
+        var first_command = true;
+        var last_command;
+        var resume_callbacks = [];
+        var resume_event_bound = false;
+        function commands(command, silent, exec) {
+            last_command = command; // for debug
+            // first command store state of the terminal before the command get
+            // executed
+            if (first_command) {
+                first_command = false;
+                // execHash need first empty command too
+                if (settings.historyState || (settings.execHash && exec)) {
+                    if (!save_state.length) {
+                        // first command in first terminal don't have hash
+                        self.save_state();
+                    } else {
+                        self.save_state(null);
+                    }
+                }
+            }
+            function after_exec() {
+                // variables defined later in commands
+                if (!exec) {
+                    change_hash = true;
+                    if (settings.historyState) {
+                        self.save_state(command, false);
+                    }
+                    change_hash = saved_change_hash;
+                }
+                deferred.resolve();
+                if ($.isFunction(settings.onAfterCommand)) {
+                    settings.onAfterCommand(self, command);
+                }
+            }
+            try {
+                // this callback can disable commands
+                if ($.isFunction(settings.onBeforeCommand)) {
+                    if (settings.onBeforeCommand(self, command) === false) {
+                        return;
+                    }
+                }
+                if (!exec) {
+                    prev_command = $.terminal.split_command(command);
+                }
+                if (!ghost()) {
+                    // exec execute this function wihout the help of cmd plugin
+                    // that add command to history on enter
+                    if (exec && $.isFunction(settings.historyFilter) &&
+                        settings.historyFilter(command) ||
+                        command.match(settings.historyFilter)) {
+                        command_line.history().append(command);
+                    }
+                }
+                var interpreter = interpreters.top();
+                if (!silent) {
+                    echo_command(command);
+                }
+                // new promise will be returned to exec that will resolve his
+                // returned promise
+                var deferred = new $.Deferred();
+                // we need to save sate before commands is deleyd because
+                // execute_extended_command disable it and it can be executed
+                // after delay
+                var saved_change_hash = change_hash;
+                if (command.match(/^\s*login\s*$/) && self.token(true)) {
+                    if (self.level() > 1) {
+                        self.logout(true);
+                    } else {
+                        self.logout();
+                    }
+                    after_exec();
+                } else if (settings.exit && command.match(/^\s*exit\s*$/) &&
+                           !in_login) {
+                    var level = self.level();
+                    if (level == 1 && self.get_token() || level > 1) {
+                        if (self.get_token(true)) {
+                            self.set_token(undefined, true);
+                        }
+                        self.pop();
+                    }
+                    after_exec();
+                } else if (settings.clear && command.match(/^\s*clear\s*$/) &&
+                           !in_login) {
+                    self.clear();
+                    after_exec();
+                } else {
+                    var position = lines.length-1;
+                    // Call user interpreter function
+                    var result = interpreter.interpreter.call(self, command, self);
+                    if (result !== undefined) {
+                        // auto pause/resume when user return promises
+                        self.pause();
+                        return $.when(result).then(function(result) {
+                            // don't echo result if user echo something
+                            if (result && position === lines.length-1) {
+                                display_object(result);
+                            }
+                            after_exec();
+                            self.resume();
+                        });
+                    } else if (paused) {
+                        var old_command = command;
+                        resume_callbacks.push(function() {
+                            // exec with resume/pause in user code
+                            after_exec();
+                        });
+                    } else {
+                        after_exec();
+                    }
+                }
+                return deferred.promise();
+            } catch (e) {
+                display_exception(e, 'USER');
+                self.resume();
+                throw e;
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: The logout function removes Storage, disables history and runs
+        // :: the login function. This function is called only when options.login
+        // :: function is defined. The check for this is in the self.pop method
+        // ---------------------------------------------------------------------
+        function global_logout() {
+            if ($.isFunction(settings.onBeforeLogout)) {
+                try {
+                    if (settings.onBeforeLogout(self) === false) {
+                        return;
+                    }
+                } catch (e) {
+                    display_exception(e, 'onBeforeLogout');
+                    throw e;
+                }
+            }
+            clear_loging_storage();
+            if ($.isFunction(settings.onAfterLogout)) {
+                try {
+                    settings.onAfterLogout(self);
+                } catch (e) {
+                    display_exception(e, 'onAfterlogout');
+                    throw e;
+                }
+            }
+            self.login(settings.login, true, initialize);
+        }
+        // ---------------------------------------------------------------------
+        function clear_loging_storage() {
+            var name = self.prefix_name(true) + '_';
+            $.Storage.remove(name + 'token');
+            $.Storage.remove(name + 'login');
+        }
+        // ---------------------------------------------------------------------
+        // :: Save the interpreter name for use with purge
+        // ---------------------------------------------------------------------
+        function maybe_append_name(interpreter_name) {
+            var storage_key = self.prefix_name() + '_interpreters';
+            var names = $.Storage.get(storage_key);
+            if (names) {
+                names = $.parseJSON(names);
+            } else {
+                names = [];
+            }
+            if ($.inArray(interpreter_name, names) == -1) {
+                names.push(interpreter_name);
+                $.Storage.set(storage_key, $.json_stringify(names));
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: Function enables history, sets prompt, runs interpreter function
+        // ---------------------------------------------------------------------
+        function prepare_top_interpreter(silent) {
+            var interpreter = interpreters.top();
+            var name = self.prefix_name(true);
+            if (!ghost()) {
+                maybe_append_name(name);
+            }
+            command_line.name(name);
+            if ($.isFunction(interpreter.prompt)) {
+                command_line.prompt(function(command) {
+                    interpreter.prompt(command, self);
+                });
+            } else {
+                command_line.prompt(interpreter.prompt);
+            }
+            command_line.set('');
+            if (!silent && $.isFunction(interpreter.onStart)) {
+                interpreter.onStart(self);
+            }
+        }
+        // ---------------------------------------------------------------------
+        var local_first_instance;
+        function initialize() {
+            prepare_top_interpreter();
+            show_greetings();
+            // was_paused flag is workaround for case when user call exec before
+            // login and pause in onInit, 3rd exec will have proper timing (will
+            // execute after onInit resume)
+            var was_paused = false;
+            if ($.isFunction(settings.onInit)) {
+                onPause = function() { // local in terminal
+                    was_paused = true;
+                };
+                try {
+                    settings.onInit(self);
+                } catch (e) {
+                    display_exception(e, 'OnInit');
+                    // throw e; // it will be catched by terminal
+                } finally {
+                    onPause = $.noop;
+                    if (!was_paused) {
+                        // resume login if user didn't call pause in onInit
+                        // if user pause in onInit wait with exec until it
+                        // resume
+                        self.resume();
+                    }
+                }
+            }
+            function hashchange() {
+                if (fire_hash_change && settings.execHash) {
+                    try {
+                        if (location.hash) {
+                            var hash = location.hash.replace(/^#/, '');
+                            hash_commands = $.parseJSON(decodeURIComponent(hash));
+                        } else {
+                            hash_commands = [];
+                        }
+                        if (hash_commands.length) {
+                            restore_state(hash_commands[hash_commands.length-1]);
+                        } else if (save_state[0]) {
+                            self.import_view(save_state[0]);
+                        }
+                    } catch(e) {
+                        display_exception(e, 'TERMINAL');
+                    }
+                }
+            }
+            if (first_instance) {
+                first_instance = false;
+                if ($.fn.hashchange) {
+                    $(window).hashchange(hashchange);
+                } else {
+                    $(window).bind('hashchange', hashchange);
+                }
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: function complete the command
+        // ---------------------------------------------------------------------
+        function complete_helper(command, string, commands) {
+            if (settings.clear && $.inArray('clear', commands) == -1) {
+                commands.push('clear');
+            }
+            if (settings.exit && $.inArray('exit', commands) == -1) {
+                commands.push('exit');
+            }
+            var test = command_line.get().substring(0, command_line.position());
+            if (test !== command) {
+                // command line changed between TABS - ignore
+                return;
+            }
+            var regex = new RegExp('^' + $.terminal.escape_regex(string));
+            var matched = [];
+            for (var i=commands.length; i--;) {
+                if (regex.test(commands[i])) {
+                    matched.push(commands[i]);
+                }
+            }
+            if (matched.length === 1) {
+                self.insert(matched[0].replace(regex, ''));
+            } else if (matched.length > 1) {
+                if (tab_count >= 2) {
+                    echo_command(command);
+                    var text = matched.reverse().join('\t');
+                    self.echo($.terminal.escape_brackets(text), {keepWords: true});
+                    tab_count = 0;
+                } else {
+                    var found = false;
+                    var found_index;
+                    var j;
+                    loop:
+                    for (j=string.length; j<matched[0].length; ++j) {
+                        for (i=1; i<matched.length; ++i) {
+                            if (matched[0].charAt(j) !== matched[i].charAt(j)) {
+                                break loop;
+                            }
+                        }
+                        found = true;
+                    }
+                    if (found) {
+                        self.insert(matched[0].slice(0, j).replace(regex, ''));
+                    }
+                }
+            }
+        }
+        // ---------------------------------------------------------------------
+        // :: If Ghost don't store anything in localstorage
+        // ---------------------------------------------------------------------
+        function ghost() {
+            return in_login || command_line.mask() !== false;
+        }
+        // ---------------------------------------------------------------------
+        // :: Keydown event handler
+        // ---------------------------------------------------------------------
+        function key_down(e) {
+            // Prevent to be executed by cmd: CTRL+D, TAB, CTRL+TAB (if more
+            // then one terminal)
+            var result, i, top = interpreters.top();
+            if (!self.paused() && self.enabled()) {
+                if ($.isFunction(top.keydown)) {
+                    result = top.keydown(e, self);
+                    if (result !== undefined) {
+                        return result;
+                    }
+                } else if ($.isFunction(settings.keydown)) {
+                    result = settings.keydown(e, self);
+                    if (result !== undefined) {
+                        return result;
+                    }
+                }
+                var completion;
+                if ((settings.completion &&
+                     $.type(settings.completion) != 'boolean') &&
+                    top.completion === undefined) {
+                    completion = settings.completion;
+                } else {
+                    completion = top.completion;
+                }
+                // after text pasted into textarea in cmd plugin
+                self.oneTime(10, function() {
+                    on_scrollbar_show_resize();
+                });
+                if (e.which !== 9) { // not a TAB
+                    tab_count = 0;
+                }
+                if (e.which === 68 && e.ctrlKey) { // CTRL+D
+                    if (!in_login) {
+                        if (command_line.get() === '') {
+                            if (interpreters.size() > 1 ||
+                                settings.login !== undefined) {
+                                self.pop('');
+                            } else {
+                                self.resume();
+                                self.echo('');
+                            }
+                        } else {
+                            self.set_command('');
+                        }
+                    }
+                    return false;
+                } else if (e.which === 76 && e.ctrlKey) { // CTRL+L
+                    self.clear();
+                } else if (completion && e.which === 9) { // TAB
+                    // TODO: move this to cmd plugin
+                    //       add completion = array | function
+                    //       !!! Problem complete more then one key need terminal
+                    ++tab_count;
+                    // cursor can be in the middle of the command
+                    // so we need to get the text before the cursor
+                    var pos = command_line.position();
+                    var command = command_line.get().substring(0, pos);
+                    var strings = command.split(' ');
+                    var string; // string before cursor that will be completed
+                    if (strings.length == 1) {
+                        string = strings[0];
+                    } else {
+                        string = strings[strings.length-1];
+                        for (i=strings.length-1; i>0; i--) {
+                            // treat escape space as part of the string
+                            if (strings[i-1][strings[i-1].length-1] == '\\') {
+                                string = strings[i-1] + ' ' + string;
+                            } else {
+                                break;
+                            }
+                        }
+                    }
+                    switch ($.type(completion)) {
+                        case 'function':
+                            completion(self, string, function(commands) {
+                                complete_helper(command, string, commands);
+                            });
+                            break;
+                        case 'array':
+                            complete_helper(command, string, completion);
+                            break;
+                        default:
+                            // terminal will not catch this because it's an event
+                            throw new Error(strings.invalidCompletion);
+                    }
+                    return false;
+                } else if (e.which === 86 && e.ctrlKey) { // CTRL+V
+                    self.oneTime(1, function() {
+                        scroll_to_bottom();
+                    });
+                    return;
+                } else if (e.which === 9 && e.ctrlKey) { // CTRL+TAB
+                    if (terminals.length() > 1) {
+                        self.focus(false);
+                        return false;
+                    }
+                } else if (e.which === 34) { // PAGE DOWN
+                    self.scroll(self.height());
+                } else if (e.which === 33) { // PAGE UP
+                    self.scroll(-self.height());
+                } else {
+                    self.attr({scrollTop: self.attr('scrollHeight')});
+                }
+            } else if (e.which === 68 && e.ctrlKey) { // CTRL+D (if paused)
+                if (requests.length) {
+                    for (i=requests.length; i--;) {
+                        var r = requests[i];
+                        if (4 !== r.readyState) {
+                            try {
+                                r.abort();
+                            } catch (error) {
+                                self.error(strings.ajaxAbortError);
+                            }
+                        }
+                    }
+                    requests = [];
+                    // only resume if there are ajax calls
+                    self.resume();
+                }
+                return false;
+            }
+        }
+        // ---------------------------------------------------------------------
+        var self = this;
+        if (this.length > 1) {
+            return this.each(function() {
+                $.fn.terminal.call($(this),
+                                   init_interpreter,
+                                   $.extend({name: self.selector}, options));
+            });
+        }
+        // terminal already exists
+        if (self.data('terminal')) {
+            return self.data('terminal');
+        }
+        if (self.length === 0) {
+            throw sprintf($.terminal.defaults.strings.invalidSelector, self.selector);
+        }
+        //var names = []; // stack if interpeter names
+        var scroll_object;
+        var prev_command; // used for name on the terminal if not defined
+        var loged_in = false;
+        var tab_count = 0; // for tab completion
+        // array of line objects:
+        // - function (called whenever necessary, result is printed)
+        // - array (expected form: [line, settings])
+        // - anything else (cast to string when painted)
+        var lines = [];
+        var output; // .terminal-output jquery object
+        var terminal_id = terminals.length();
+        var num_chars; // numer of chars in line
+        var num_rows; // number of lines that fit without scrollbar
+        var command_list = []; // for tab completion
+        var url;
+        var logins = new Stack(); // stack of logins
+        var in_login = false;//some Methods should not be called when login
+        // TODO: Try to use mutex like counter for pause/resume
+        var onPause = $.noop;//used to indicate that user call pause onInit
+        var old_width, old_height;
+        var delayed_commands = []; // used when exec commands while paused
+        var settings = $.extend({},
+                                $.terminal.defaults,
+                                {name: self.selector},
+                                options || {});
+        var strings = $.terminal.defaults.strings;
+        var enabled = settings.enabled, frozen;
+        var paused = false;
+        // -----------------------------------------------------------------
+        // TERMINAL METHODS
+        // -----------------------------------------------------------------
+        $.extend(self, $.omap({
+            id: function() {
+                return terminal_id;
+            },
+            // -------------------------------------------------------------
+            // :: Clear the output
+            // -------------------------------------------------------------
+            clear: function() {
+                output.html('');
+                lines = [];
+                try {
+                    settings.onClear(self);
+                } catch (e) {
+                    display_exception(e, 'onClear');
+                    throw e;
+                }
+                self.attr({ scrollTop: 0});
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return an object that can be used with import_view to
+            // :: restore the state
+            // -------------------------------------------------------------
+            export_view: function() {
+                return $.extend({}, {
+                    focus: enabled,
+                    mask: command_line.mask(),
+                    prompt: self.get_prompt(),
+                    command: self.get_command(),
+                    position: command_line.position(),
+                    lines: clone(lines),
+                    interpreters: interpreters.clone()
+                }, $.isFunction(settings.onExport) ? settings.onExport() : {});
+            },
+            // -------------------------------------------------------------
+            // :: Restore the state of the previous exported view
+            // -------------------------------------------------------------
+            import_view: function(view) {
+                if (in_login) {
+                    throw new Error(sprintf(strings.notWhileLogin, 'import_view'));
+                }
+                if ($.isFunction(settings.onImport)) {
+                    settings.onImport(view);
+                }
+                self.set_prompt(view.prompt);
+                self.set_command(view.command);
+                command_line.position(view.position);
+                command_line.mask(view.mask);
+                if (view.focus) {
+                    self.focus();
+                }
+                lines = clone(view.lines);
+                interpreters = view.interpreters;
+                redraw();
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Store current terminal state
+            // -------------------------------------------------------------
+            save_state: function(command, ignore_hash, index) {
+                //save_state.push({view:self.export_view(), join:[]});
+                if (typeof index != 'undefined') {
+                    save_state[index] = self.export_view();
+                } else {
+                    save_state.push(self.export_view());
+                }
+                if (!$.isArray(hash_commands)) {
+                    hash_commands = [];
+                }
+                if (command !== undefined && !ignore_hash) {
+                    var state = [
+                        terminal_id,
+                        save_state.length-1,
+                        command
+                    ];
+                    hash_commands.push(state);
+                    maybe_update_hash();
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Execute a command, it will handle commands that do AJAX
+            // :: calls and have delays, if the second argument is set to
+            // :: true it will not echo executed command
+            // -------------------------------------------------------------
+            exec: function(command, silent, deferred) {
+                if ($.isArray(command)) {
+                    return $.when.apply($, $.map(command, function(command) {
+                        return self.exec(command, silent);
+                    }));
+                }
+                // both commands executed here (resume will call Term::exec)
+                var d = deferred || new $.Deferred();
+                if (paused) {
+                    // delay command multiple time
+                    delayed_commands.push([command, silent, d]);
+                } else {
+                    // commands may return promise from user code
+                    // it will resolve exec promise when user promise
+                    // is resolved
+                    commands(command, silent, true).then(function() {
+                        d.resolve(self);
+                    });
+                }
+                return d.promise();
+            },
+            // -------------------------------------------------------------
+            // :: bypass login function that wait untill you type user/pass
+            // :: it hide implementation detail
+            // -------------------------------------------------------------
+            autologin: function(user, token, silent) {
+                self.trigger('terminal.autologin', [user, token, silent]);
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Function changes the prompt of the command line to login
+            // :: with a password and calls the user login function with
+            // :: the callback that expects a token. The login is successful
+            // :: if the user calls it with value that is truthy
+            // -------------------------------------------------------------
+            login: function(auth, infinite, success, error) {
+                logins.push([].slice.call(arguments));
+                if (in_login) {
+                    throw new Error(sprintf(strings.notWhileLogin, 'login'));
+                }
+                if (!$.isFunction(auth)) {
+                    throw new Error(strings.loginIsNotAFunction);
+                }
+                if (self.token(true) && self.login_name(true)) {
+                    if ($.isFunction(success)) {
+                        success();
+                    }
+                    return self;
+                }
+                var user = null;
+                // don't store login data in history
+                if (settings.history) {
+                    command_line.history().disable();
+                }
+                // so we know how many times call pop
+                var level = self.level();
+                in_login = true;
+                function login_callback(user, token, silent, event) {
+                    if (token) {
+                        while (self.level() > level) {
+                            self.pop();
+                        }
+                        if (settings.history) {
+                            command_line.history().enable();
+                        }
+                        var name = self.prefix_name(true) + '_';
+                        $.Storage.set(name + 'token', token);
+                        $.Storage.set(name + 'login', user);
+                        in_login = false;
+                        if ($.isFunction(success)) {
+                            // will be used internaly since users know
+                            // when login success (they decide when
+                            // it happen by calling the callback -
+                            // this funtion)
+                            success();
+                        }
+                    } else {
+                        if (infinite) {
+                            if (!silent) {
+                                self.error(strings.wrongPasswordTryAgain);
+                            }
+                            self.pop().set_mask(false);
+                        } else {
+                            in_login = false;
+                            if (!silent) {
+                                self.error(strings.wrongPassword);
+                            }
+                            self.pop().pop();
+                        }
+                        // used only to call pop in push
+                        if ($.isFunction(error)) {
+                            error();
+                        }
+                    }
+                    self.off('terminal.autologin');
+                }
+                self.on('terminal.autologin', function(event, user, token, silent) {
+                    login_callback(user, token, silent);
+                });
+                self.push(function(user) {
+                    self.set_mask(settings.maskChar).push(function(pass) {
+                        try {
+                            auth.call(self, user, pass, function(token, silent) {
+                                login_callback(user, token, silent);
+                            });
+                        } catch(e) {
+                            display_exception(e, 'AUTH');
+                        }
+                    }, {
+                        prompt: strings.password + ': ',
+                        name: 'password'
+                    });
+                }, {
+                    prompt: strings.login + ': ',
+                    name: 'login'
+                });
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: User defined settings and defaults as well
+            // -------------------------------------------------------------
+            settings: function() {
+                return settings;
+            },
+            // -------------------------------------------------------------
+            // :: Return commands function from top interpreter
+            // -------------------------------------------------------------
+            commands: function() {
+                return interpreters.top().interpreter;
+            },
+            // -------------------------------------------------------------
+            // :: Low Level method that overwrites interpreter
+            // -------------------------------------------------------------
+            setInterpreter: function() {
+                if (window.console && console.warn) {
+                    console.warn('This function is deprecated, use set_inte'+
+                                 'rpreter insead!');
+                }
+                self.set_interpreter.apply(self, arguments);
+            },
+            // -------------------------------------------------------------
+            set_interpreter: function(user_intrp, login) {
+                function overwrite_interpreter() {
+                    self.pause();
+                    make_interpreter(user_intrp, !!login, function(result) {
+                        self.resume();
+                        var top = interpreters.top();
+                        $.extend(top, result);
+                        prepare_top_interpreter(true);
+                    });
+                }
+                if ($.type(user_intrp) == 'string' && login) {
+                    self.login(make_json_rpc_login(user_intrp, login),
+                               true,
+                               overwrite_interpreter);
+                } else {
+                    overwrite_interpreter();
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Show user greetings or terminal signature
+            // -------------------------------------------------------------
+            greetings: function() {
+                show_greetings();
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return true if terminal is paused false otherwise
+            // -------------------------------------------------------------
+            paused: function() {
+                return paused;
+            },
+            // -------------------------------------------------------------
+            // :: Pause the terminal, it should be used for ajax calls
+            // -------------------------------------------------------------
+            pause: function() {
+                onPause();
+                if (!paused && command_line) {
+                    paused = true;
+                    command_line.disable().hidden();
+                    if ($.isFunction(settings.onPause)) {
+                        settings.onPause();
+                    }
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Resume the previously paused terminal
+            // -------------------------------------------------------------
+            resume: function() {
+                if (paused && command_line) {
+                    paused = false;
+                    command_line.enable().visible();
+                    var original = delayed_commands;
+                    delayed_commands = [];
+                    (function recur() {
+                        if (original.length) {
+                            self.exec.apply(self, original.shift()).then(recur);
+                        } else {
+                            self.trigger('resume');
+                            var fn = resume_callbacks.shift();
+                            if (fn) {
+                                fn();
+                            }
+                            scroll_to_bottom();
+                            if ($.isFunction(settings.onResume)) {
+                                settings.onResume();
+                            }
+                        }
+                    })();
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return the number of characters that fit into the width of
+            // :: the terminal
+            // -------------------------------------------------------------
+            cols: function() {
+                return settings.numChars?settings.numChars:get_num_chars(self);
+            },
+            // -------------------------------------------------------------
+            // :: Return the number of lines that fit into the height of the
+            // :: terminal
+            // -------------------------------------------------------------
+            rows: function() {
+                return settings.numRows?settings.numRows:get_num_rows(self);
+            },
+            // -------------------------------------------------------------
+            // :: Return the History object
+            // -------------------------------------------------------------
+            history: function() {
+                return command_line.history();
+            },
+            // -------------------------------------------------------------
+            // :: toggle recording of history state
+            // -------------------------------------------------------------
+            history_state: function(toggle) {
+                if (toggle) {
+                    // if set to true and if set from user command we need
+                    // not to include the command
+                    self.oneTime(1, function() {
+                        settings.historyState = true;
+                        if (!save_state.length) {
+                            self.save_state();
+                        } else if (terminals.length() > 1) {
+                            self.save_state(null);
+                        }
+                    });
+                } else {
+                    settings.historyState = false;
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Switch to the next terminal
+            // -------------------------------------------------------------
+            next: function() {
+                if (terminals.length() === 1) {
+                    return self;
+                } else {
+                    var offsetTop = self.offset().top;
+                    var height = self.height();
+                    var scrollTop = self.scrollTop();
+                    if (!is_scrolled_into_view(self)) {
+                        self.enable();
+                        $('html,body').animate({
+                            scrollTop: offsetTop-50
+                        }, 500);
+                        return self;
+                    } else {
+                        terminals.front().disable();
+                        var next = terminals.rotate().enable();
+                        // 100 provides buffer in viewport
+                        var x = next.offset().top - 50;
+                        $('html,body').animate({scrollTop: x}, 500);
+                        try {
+                            settings.onTerminalChange(next);
+                        } catch (e) {
+                            display_exception(e, 'onTerminalChange');
+                            throw e;
+                        }
+                        return next;
+                    }
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Make the terminal in focus or blur depending on the first
+            // :: argument. If there is more then one terminal it will
+            // :: switch to next one, if the second argument is set to true
+            // ::  the events will be not fired. Used on init
+            // -------------------------------------------------------------
+            focus: function(toggle, silent) {
+                if (terminals.length() === 1) {
+                    if (toggle === false) {
+                        try {
+                            if (!silent && settings.onBlur(self) !== false ||
+                                silent) {
+                                self.disable();
+                            }
+                        } catch (e) {
+                            display_exception(e, 'onBlur');
+                            throw e;
+                        }
+                    } else {
+                        try {
+                            if (!silent && settings.onFocus(self) !== false ||
+                                silent) {
+                                self.enable();
+                            }
+                        } catch (e) {
+                            display_exception(e, 'onFocus');
+                            throw e;
+                        }
+                    }
+                } else {
+                    if (toggle === false) {
+                        self.next();
+                    } else {
+                        var front = terminals.front();
+                        if (front != self) {
+                            front.disable();
+                            if (!silent) {
+                                try {
+                                    settings.onTerminalChange(self);
+                                } catch (e) {
+                                    display_exception(e, 'onTerminalChange');
+                                    throw e;
+                                }
+                            }
+                        }
+                        terminals.set(self);
+                        self.enable();
+                    }
+                }
+                // why this delay - it can't be use for mobile
+                /*
+                self.oneTime(1, function() {
+                });
+                */
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Disable/Enable terminal that can be enabled by click
+            // -------------------------------------------------------------
+            freeze: function(freeze) {
+                if (freeze) {
+                    self.disable();
+                    frozen = true;
+                } else {
+                    frozen = false;
+                    self.enable();
+                }
+            },
+            // -------------------------------------------------------------
+            // :: check if terminal is frozen
+            // -------------------------------------------------------------
+            frozen: function() {
+                return frozen;
+            },
+            // -------------------------------------------------------------
+            // :: Enable the terminal
+            // -------------------------------------------------------------
+            enable: function() {
+                if (!enabled && !frozen) {
+                    if (num_chars === undefined) {
+                        //enabling first time
+                        self.resize();
+                    }
+                    if (command_line) {
+                        command_line.enable();
+                        enabled = true;
+                    }
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Disable the terminal
+            // -------------------------------------------------------------
+            disable: function() {
+                if (enabled && command_line && !frozen) {
+                    enabled = false;
+                    command_line.disable();
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: return true if the terminal is enabled
+            // -------------------------------------------------------------
+            enabled: function() {
+                return enabled;
+            },
+            // -------------------------------------------------------------
+            // :: Return the terminal signature depending on the size of the terminal
+            // -------------------------------------------------------------
+            signature: function() {
+                var cols = self.cols();
+                var i = cols < 15 ? null : cols < 35 ? 0 : cols < 55 ? 1 : cols < 64 ? 2 : cols < 75 ? 3 : 4;
+                if (i !== null) {
+                    return signatures[i].join('\n') + '\n';
+                } else {
+                    return '';
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Return the version number
+            // -------------------------------------------------------------
+            version: function() {
+                return $.terminal.version;
+            },
+            // -------------------------------------------------------------
+            // :: Return actual command line object (jquery object with cmd
+            // :: methods)
+            // -------------------------------------------------------------
+            cmd: function() {
+                return command_line;
+            },
+            // -------------------------------------------------------------
+            // :: Return the current command entered by terminal
+            // -------------------------------------------------------------
+            get_command: function() {
+                return command_line.get();
+            },
+            // -------------------------------------------------------------
+            // :: Change the command line to the new one
+            // -------------------------------------------------------------
+            set_command: function(command) {
+                command_line.set(command);
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Insert text into the command line after the cursor
+            // -------------------------------------------------------------
+            insert: function(string) {
+                if (typeof string === 'string') {
+                    command_line.insert(string);
+                    return self;
+                } else {
+                    throw "insert function argument is not a string";
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Set the prompt of the command line
+            // -------------------------------------------------------------
+            set_prompt: function(prompt) {
+                if (validate('prompt', prompt)) {
+                    if ($.isFunction(prompt)) {
+                        command_line.prompt(function(callback) {
+                            prompt(callback, self);
+                        });
+                    } else {
+                        command_line.prompt(prompt);
+                    }
+                    interpreters.top().prompt = prompt;
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return the prompt used by the terminal
+            // -------------------------------------------------------------
+            get_prompt: function() {
+                return interpreters.top().prompt;
+                // command_line.prompt(); - can be a wrapper
+                //return command_line.prompt();
+            },
+            // -------------------------------------------------------------
+            // :: Enable or Disable mask depedning on the passed argument
+            // :: the mask can also be character (in fact it will work with
+            // :: strings longer then one)
+            // -------------------------------------------------------------
+            set_mask: function(mask) {
+                command_line.mask(mask === true ? settings.maskChar : mask);
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return the ouput of the terminal as text
+            // -------------------------------------------------------------
+            get_output: function(raw) {
+                if (raw) {
+                    return lines;
+                } else {
+                    return $.map(lines, function(item) {
+                        return $.isFunction(item[0]) ? item[0]() : item[0];
+                    }).join('\n');
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Recalculate and redraw everything
+            // -------------------------------------------------------------
+            resize: function(width, height) {
+                if (!self.is(':visible')) {
+                    // delay resize if terminal not visible
+                    self.stopTime('resize');
+                    self.oneTime(500, 'resize', function() {
+                        self.resize(width, height);
+                    });
+                } else {
+                    if (width && height) {
+                        self.width(width);
+                        self.height(height);
+                    }
+                    width = self.width();
+                    height = self.height();
+                    var new_num_chars = self.cols();
+                    var new_num_rows = self.rows();
+                    // only if number of chars changed
+                    if (new_num_chars !== num_chars ||
+                        new_num_rows !== num_rows) {
+                        num_chars = new_num_chars;
+                        num_rows = new_num_rows;
+                        redraw();
+                        var top = interpreters.top();
+                        if ($.isFunction(top.resize)) {
+                            top.resize(self);
+                        } else if ($.isFunction(settings.onResize)) {
+                            settings.onResize(self);
+                        }
+                        old_height = height;
+                        old_width = width;
+                        scroll_to_bottom();
+                    }
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Flush the output to the terminal
+            // -------------------------------------------------------------
+            flush: function() {
+                try {
+                    var wrapper;
+                    // print all lines
+                    $.each(output_buffer, function(i, line) {
+                        if (line === NEW_LINE) {
+                            wrapper = $('<div></div>');
+                        } else if ($.isFunction(line)) {
+                            // this is finalize function from echo
+                            wrapper.appendTo(output);
+                            try {
+                                line(wrapper);
+                                /* this don't work with resize
+                                   line(wrapper, function(user_finalize) {
+                                   // TODO:
+                                   //user_finalize need to be save in line object
+                                   user_finalize(wrapper);
+                                   });*/
+                            } catch (e) {
+                                display_exception(e, 'USER:echo(finalize)');
+                            }
+                        } else {
+                            $('<div/>').html(line).
+                                appendTo(wrapper).width('100%');
+                        }
+                    });
+                    if (settings.outputLimit >= 0) {
+                        var limit = settings.outputLimit === 0 ?
+                            self.rows() :
+                            settings.outputLimit;
+                        var $lines = output.find('div div');
+                        if ($lines.length > limit) {
+                            var max = lines.length-limit+1;
+                            var for_remove = $lines.slice(0, max);
+                            // you can't get parent if you remove the
+                            // element so we first get the parent
+                            var parents = for_remove.parent();
+                            for_remove.remove();
+                            parents.each(function() {
+                                var self = $(this);
+                                if (self.is(':empty')) {
+                                    // there can be divs inside parent that
+                                    // was not removed
+                                    self.remove();
+                                }
+                            });
+                        }
+                    }
+                    scroll_to_bottom();
+                    output_buffer = [];
+                } catch (e) {
+                    alert('[Flush] ' + exception_message(e) + '\n' +
+                          e.stack);
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Update the output line - line number can be negative
+            // -------------------------------------------------------------
+            update: function(line, string) {
+                if (line < 0) {
+                    line = lines.length + line; // yes +
+                }
+                if (!lines[line]) {
+                    self.error('Invalid line number ' + line);
+                } else {
+                    lines[line][0] = string;
+                    // it would be hard to figure out which div need to be
+                    // updated so we update everything
+                    redraw();
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Print data to the terminal output. It can have two options
+            // :: a function that is called with the container div that
+            // :: holds the output (as a jquery object) every time the
+            // :: output is printed (including resize and scrolling)
+            // :: If the line is a function it will be called for every
+            // :: redraw.
+            // :: it use $.when so you can echo a promise
+            // -------------------------------------------------------------
+            echo: function(string, options) {
+                string = string || '';
+                $.when(string).then(function(string) {
+                    try {
+                        output_buffer = [];
+                        var locals = $.extend({
+                            flush: true,
+                            raw: settings.raw,
+                            finalize: $.noop,
+                            keepWords: false
+                        }, options || {});
+                        process_line(string, locals);
+                        // extended commands should be processed only once
+                        // in echo and not on redraw
+                        lines.push([string, $.extend(locals, {
+                            exec: false
+                        })]);
+                        if (locals.flush) {
+                            self.flush();
+                        }
+                        num_rows = get_num_rows(self);
+                        on_scrollbar_show_resize();
+                    } catch (e) {
+                        // if echo throw exception we can't use error to
+                        // display that exception
+                        alert('[Terminal.echo] ' + exception_message(e) +
+                              '\n' + e.stack);
+                    }
+                });
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: echo red text
+            // -------------------------------------------------------------
+            error: function(message, finalize) {
+                //quick hack to fix trailing backslash
+                var str = $.terminal.escape_brackets(message).
+                    replace(/\\$/, '&#92;').
+                    replace(url_re, ']$1[[;;;error]');
+                return self.echo('[[;;;error]' + str + ']', finalize);
+            },
+            // -------------------------------------------------------------
+            // :: Display Exception on terminal
+            // -------------------------------------------------------------
+            exception: function(e, label) {
+                var message = exception_message(e);
+                if (label) {
+                    message = '&#91;' + label + '&#93;: ' + message;
+                }
+                if (message) {
+                    self.error(message, {
+                        finalize: function(div) {
+                            div.addClass('exception message');
+                        }
+                    });
+                }
+                if (typeof e.fileName === 'string') {
+                    //display filename and line which throw exeption
+                    self.pause();
+                    $.get(e.fileName, function(file) {
+                        self.resume();
+                        var num = e.lineNumber - 1;
+                        var line = file.split('\n')[num];
+                        if (line) {
+                            self.error('[' + e.lineNumber + ']: ' + line);
+                        }
+                    });
+                }
+                if (e.stack) {
+                    self.echo(e.stack.split(/\n/g).map(function(trace) {
+                        return '[[;;;error]' + trace.replace(url_re, function(url) {
+                            return ']' + url + '[[;;;error]';
+                        }) + ']';
+                    }).join('\n'), {
+                        finalize: function(div) {
+                            div.addClass('exception stack-trace');
+                        }
+                    });
+                }
+            },
+            // -------------------------------------------------------------
+            // :: Scroll Div that holds the terminal
+            // -------------------------------------------------------------
+            scroll: function(amount) {
+                var pos;
+                amount = Math.round(amount);
+                if (scroll_object.prop) { // work with jQuery > 1.6
+                    if (amount > scroll_object.prop('scrollTop') && amount > 0) {
+                        scroll_object.prop('scrollTop', 0);
+                    }
+                    pos = scroll_object.prop('scrollTop');
+                    scroll_object.scrollTop(pos + amount);
+                } else {
+                    if (amount > scroll_object.attr('scrollTop') && amount > 0) {
+                        scroll_object.attr('scrollTop', 0);
+                    }
+                    pos = scroll_object.attr('scrollTop');
+                    scroll_object.scrollTop(pos + amount);
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Exit all interpreters and logout. The function will throw
+            // :: exception if there is no login provided
+            // -------------------------------------------------------------
+            logout: function(local) {
+                if (in_login) {
+                    throw new Error(sprintf(strings.notWhileLogin, 'import_view'));
+                }
+                if (local) {
+                    var login = logins.pop();
+                    self.set_token(undefined, true);
+                    self.login.apply(self, login);
+                } else {
+                    while (interpreters.size() > 0) {
+                        // pop will call global_logout that will call login
+                        // and size will be > 0; this is workaround the problem
+                        if (self.pop()) {
+                            break;
+                        }
+                    }
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Function returns the token returned by callback function
+            // :: in login function. It does nothing (return undefined) if
+            // :: there is no login
+            // -------------------------------------------------------------
+            token: function(local) {
+                return $.Storage.get(self.prefix_name(local) + '_token');
+            },
+            // -------------------------------------------------------------
+            // :: Function sets the token to the supplied value. This function
+            // :: works regardless of wherer settings.login is supplied
+            // -------------------------------------------------------------
+            set_token: function(token, local) {
+                var name = self.prefix_name(local) + '_token';
+                if (typeof token == 'undefined') {
+                    $.Storage.remove(name, token);
+                } else {
+                    $.Storage.set(name, token);
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Function get the token either set by the login method or
+            // :: by the set_token method.
+            // -------------------------------------------------------------
+            get_token: function(local) {
+                return $.Storage.get(self.prefix_name(local) + '_token');
+            },
+            // -------------------------------------------------------------
+            // :: Function return Login name entered by the user
+            // -------------------------------------------------------------
+            login_name: function(local) {
+                return $.Storage.get(self.prefix_name(local) + '_login');
+            },
+            // -------------------------------------------------------------
+            // :: Function returns the name of current interpreter
+            // -------------------------------------------------------------
+            name: function() {
+                return interpreters.top().name;
+            },
+            // -------------------------------------------------------------
+            // :: Function return prefix name for login/token
+            // -------------------------------------------------------------
+            prefix_name: function(local) {
+                var name = (settings.name ? settings.name + '_': '') +
+                    terminal_id;
+                if (local && interpreters.size() > 1) {
+                    var local_name = interpreters.map(function(intrp) {
+                        return intrp.name;
+                    }).slice(1).join('_');
+                    if (local_name) {
+                        name += '_' + local_name;
+                    }
+                }
+                return name;
+            },
+            // -------------------------------------------------------------
+            // :: wrapper for common use case
+            // -------------------------------------------------------------
+            read: function(message, callback) {
+                var d = new $.Deferred();
+                self.push(function(text) {
+                    self.pop();
+                    if ($.isFunction(callback)) {
+                        callback(text);
+                    }
+                    d.resolve(text);
+                }, {
+                    prompt: message
+                });
+                return d.promise();
+            },
+            // -------------------------------------------------------------
+            // :: Push a new interenter on the Stack
+            // -------------------------------------------------------------
+            push: function(interpreter, options) {
+                options = options || {};
+                if (!options.name && prev_command) {
+                    // push is called in login
+                    options.name = prev_command.name;
+                }
+                if (options.prompt === undefined) {
+                    options.prompt = options.name + ' ';
+                }
+                //names.push(options.name);
+                var top = interpreters.top();
+                if (top) {
+                    top.mask = command_line.mask();
+                }
+                var was_paused = paused;
+                self.pause();
+                make_interpreter(interpreter, !!options.login, function(ret) {
+                    // result is object with interpreter and completion
+                    // properties
+                    interpreters.push($.extend({}, ret, options));
+                    if (options.login) {
+                        var type = $.type(options.login);
+                        if (type == 'function') {
+                            // self.pop on error
+                            self.login(options.login,
+                                       false,
+                                       prepare_top_interpreter,
+                                       self.pop);
+                        } else if ($.type(interpreter) == 'string' &&
+                                   type == 'string' || type == 'boolean') {
+                            self.login(make_json_rpc_login(interpreter,
+                                                           options.login),
+                                       false,
+                                       prepare_top_interpreter,
+                                       self.pop);
+                        }
+                    } else {
+                        prepare_top_interpreter();
+                    }
+                    if (!was_paused) {
+                        self.resume();
+                    }
+                });
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Remove the last interpreter from the Stack
+            // -------------------------------------------------------------
+            pop: function(string) {
+                if (string !== undefined) {
+                    echo_command(string);
+                }
+                var token = self.token(true);
+                if (interpreters.size() == 1) {
+                    if (settings.login) {
+                        global_logout();
+                        if ($.isFunction(settings.onExit)) {
+                            try {
+                                settings.onExit(self);
+                            } catch (e) {
+                                display_exception(e, 'onExit');
+                                throw e;
+                            }
+                        }
+                        return true;
+                    } else {
+                        self.error(strings.canExitError);
+                    }
+                } else {
+                    if (self.token(true)) {
+                        clear_loging_storage();
+                    }
+                    var current = interpreters.pop();
+                    prepare_top_interpreter();
+                    if ($.isFunction(current.onExit)) {
+                        try {
+                            current.onExit(self);
+                        } catch (e) {
+                            display_exception(e, 'onExit');
+                            throw e;
+                        }
+                    }
+                    // restore mask
+                    self.set_mask(interpreters.top().mask);
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Change terminal option(s) at runtime
+            // -------------------------------------------------------------
+            option: function(object_or_name, value) {
+                if (typeof value == 'undefined') {
+                    if (typeof object_or_name == 'string') {
+                        return settings[object_or_name];
+                    } else if (typeof object_or_name == 'object') {
+                        $.each(object_or_name, function(key, value) {
+                            settings[key] = value;
+                        });
+                    }
+                } else {
+                    settings[object_or_name] = value;
+                }
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Return how deep you are in nested interpreters
+            // -------------------------------------------------------------
+            level: function() {
+                return interpreters.size();
+            },
+            // -------------------------------------------------------------
+            // :: Reinitialize the terminal
+            // -------------------------------------------------------------
+            reset: function() {
+                self.clear();
+                while(interpreters.size() > 1) {
+                    interpreters.pop();
+                }
+                initialize();
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Remove all local storage left by terminal, it will not
+            // :: logout you until you refresh the browser
+            // -------------------------------------------------------------
+            purge: function() {
+                var prefix = self.prefix_name() + '_';
+                var names = $.Storage.get(prefix + 'interpreters');
+                $.each($.parseJSON(names), function(_, name) {
+                    $.Storage.remove(name + '_commands');
+                    $.Storage.remove(name + '_token');
+                    $.Storage.remove(name + '_login');
+                });
+                command_line.purge();
+                $.Storage.remove(prefix + 'interpreters');
+                return self;
+            },
+            // -------------------------------------------------------------
+            // :: Remove all events and DOM nodes left by terminal, it will
+            // :: not purge the terminal so you will have the same state
+            // :: when you refresh the browser
+            // -------------------------------------------------------------
+            destroy: function() {
+                command_line.destroy().remove();
+                output.remove();
+                $(document).unbind('.terminal');
+                $(window).unbind('.terminal');
+                self.unbind('click mousewheel');
+                self.removeData('terminal').removeClass('terminal');
+                if (settings.width) {
+                    self.css('width', '');
+                }
+                if (settings.height) {
+                    self.css('height', '');
+                }
+                $(window).off('blur', blur_terminal).
+                    off('focus', focus_terminal);
+                terminals.remove(terminal_id);
+                return self;
+            }
+        }, function(name, fun) {
+            // wrap all functions and display execptions
+            return function() {
+                try {
+                    return fun.apply(self, [].slice.apply(arguments));
+                } catch (e) {
+                    // exec catch by command (resume call exec)
+                    if (name !== 'exec' && name !== 'resume') {
+                        display_exception(e, 'TERMINAL');
+                    }
+                    throw e;
+                }
+            };
+        }));
+
+        // -----------------------------------------------------------------
+        var on_scrollbar_show_resize = (function() {
+            var scroll_bars = have_scrollbars(self);
+            return function() {
+                if (scroll_bars !== have_scrollbars(self)) {
+                    // if the scollbar appearance changes we will have a
+                    // different number of chars
+                    self.resize();
+                    scroll_bars = have_scrollbars(self);
+                }
+            };
+        })();
+
+
+        // -----------------------------------------------------------------
+        // INIT CODE
+        // -----------------------------------------------------------------
+        if (settings.width) {
+            self.width(settings.width);
+        }
+        if (settings.height) {
+            self.height(settings.height);
+        }
+        var agent = navigator.userAgent.toLowerCase();
+        if (!agent.match(/(webkit)[ \/]([\w.]+)/) &&
+            self[0].tagName.toLowerCase() == 'body') {
+            scroll_object = $('html');
+        } else {
+            scroll_object = self;
+        }
+        // register ajaxSend for cancel requests on CTRL+D
+        $(document).bind('ajaxSend.terminal', function(e, xhr, opt) {
+            requests.push(xhr);
+        });
+        output = $('<div>').addClass('terminal-output').appendTo(self);
+        self.addClass('terminal');
+        // keep focus in clipboard textarea in mobile
+        /*
+          if (('ontouchstart' in window) || window.DocumentTouch &&
+          document instanceof DocumentTouch) {
+          self.click(function() {
+          self.find('textarea').focus();
+          });
+          self.find('textarea').focus();
+          }
+        */
+        /*
+          self.bind('touchstart.touchScroll', function() {
+
+          });
+          self.bind('touchmove.touchScroll', function() {
+
+          });
+        */
+        //$('<input type="text"/>').hide().focus().appendTo(self);
+
+        // before login event
+        if (settings.login && $.isFunction(settings.onBeforeLogin)) {
+            try {
+                settings.onBeforeLogin(self);
+            } catch (e) {
+                display_exception(e, 'onBeforeLogin');
+                throw e;
+            }
+        }
+        var auth = settings.login;
+        // create json-rpc authentication function
+        var base_interpreter;
+        if (typeof init_interpreter == 'string') {
+            base_interpreter = init_interpreter;
+        } else if (init_interpreter instanceof Array &&
+                   typeof init_interpreter[0] == 'string') {
+            base_interpreter = init_interpreter[0];
+        }
+        if (base_interpreter &&
+            (typeof settings.login === 'string' || settings.login)) {
+            settings.login = make_json_rpc_login(base_interpreter,
+                                                 settings.login);
+        }
+        terminals.append(self);
+        var interpreters;
+        var command_line;
+        var old_enabled;
+        function focus_terminal() {
+            if (old_enabled) {
+                self.focus();
+            }
+        }
+        function blur_terminal() {
+            old_enabled = enabled;
+            self.disable();
+        }
+        make_interpreter(init_interpreter, !!settings.login, function(itrp) {
+            if (settings.completion && typeof settings.completion != 'boolean') {
+                //overwrite interpreter completion by global setting #224
+                itrp.completion = settings.completion;
+            }
+            interpreters = new Stack($.extend({
+                name: settings.name,
+                prompt: settings.prompt,
+                keypress: settings.keypress,
+                keydown: settings.keydown,
+                resize: settings.onResize,
+                greetings: settings.greetings,
+                mousewheel: settings.mousewheel
+            }, itrp));
+            // CREATE COMMAND LINE
+            command_line = $('<div/>').appendTo(self).cmd({
+                prompt: settings.prompt,
+                history: settings.history,
+                historyFilter: settings.historyFilter,
+                historySize: settings.historySize,
+                width: '100%',
+                enabled: enabled && !is_touch,
+                keydown: key_down,
+                keypress: function(e) {
+                    var result, i, top = interpreters.top();
+                    if ($.isFunction(top.keypress)) {
+                        return top.keypress(e, self);
+                    } else if ($.isFunction(settings.keypress)) {
+                        return settings.keypress(e, self);
+                    }
+                },
+                onCommandChange: function(command) {
+                    if ($.isFunction(settings.onCommandChange)) {
+                        try {
+                            settings.onCommandChange(command, self);
+                        } catch (e) {
+                            display_exception(e, 'onCommandChange');
+                            throw e;
+                        }
+                    }
+                    scroll_to_bottom();
+                },
+                commands: commands
+            });
+            // touch devices need touch event to get virtual keyboard
+            if (enabled && self.is(':visible') && !is_touch) {
+                self.focus(undefined, true);
+            } else {
+                self.disable();
+            }
+            self.oneTime(100, function() {
+                function disable(e) {
+                    var sender = $(e.target);
+                    if (!sender.closest('.terminal').length &&
+                        self.enabled() &&
+                        settings.onBlur(self) !== false) {
+                        self.disable();
+                    }
+                }
+                $(document).bind('click.terminal', disable).
+                    bind('contextmenu.terminal', disable);
+            });
+            if (!is_touch) {
+                // work weird on mobile
+                var $win = $(window).on('focus', focus_terminal).
+                    on('blur', blur_terminal);
+            } else {
+                /*
+                self.find('textarea').on('blur.terminal', function() {
+                    if (enabled) {
+                        self.focus(false);
+                    }
+                });*/
+            }
+            self.click(function(e) {
+                if (!self.enabled()) {
+                    self.focus();
+                } else if (is_touch) {
+                    // keep focusing silently so textarea get focus
+                    self.focus(true, true);
+                }
+                // this will ensure that textarea has focus
+                command_line.enable();
+            }).delegate('.exception a', 'click', function(e) {
+                //.on('click', '.exception a', function(e) {
+                // in new jquery .delegate just call .on
+                var href = $(this).attr('href');
+                if (href.match(/:[0-9]+$/)) { // display line if specified
+                    e.preventDefault();
+                    print_line(href);
+                }
+            });
+            if (!navigator.platform.match(/linux/i)) {
+                // on linux system paste work with middle mouse button
+                self.mousedown(function(e) {
+                    if (e.which == 2) {
+                        var selected = get_selected_text();
+                        self.insert(selected);
+                    }
+                });
+            }
+            if (self.is(':visible')) {
+                num_chars = self.cols();
+                command_line.resize(num_chars);
+                num_rows = get_num_rows(self);
+            }
+            // -------------------------------------------------------------
+            // Run Login
+            if (settings.login) {
+                self.login(settings.login, true, initialize);
+            } else {
+                initialize();
+            }
+            self.oneTime(100, function() {
+                $win.bind('resize.terminal', function() {
+                    if (self.is(':visible')) {
+                        var width = self.width();
+                        var height = self.height();
+                        // prevent too many calculations in IE
+                        if (old_height !== height || old_width !== width) {
+                            self.resize();
+                        }
+                    }
+                });
+            });
+            // -------------------------------------------------------------
+            // :: helper
+            function exec_spec(spec) {
+                var terminal = terminals.get()[spec[0]];
+                // execute if belong to this terminal
+                if (terminal && terminal_id == terminal.id()) {
+                    if (spec[2]) {
+                        try {
+                            if (paused) {
+                                var defer = $.Deferred();
+                                resume_callbacks.push(function() {
+                                    return terminal.exec(spec[2]).then(function(term, i) {
+                                        terminal.save_state(spec[2], true, spec[1]);
+                                        defer.resolve();
+                                    });
+                                });
+                                return defer.promise();
+                            } else {
+                                return terminal.exec(spec[2]).then(function(term, i) {
+                                    terminal.save_state(spec[2], true, spec[1]);
+                                });
+                            }
+                        } catch (e) {
+                            var cmd = $.terminal.escape_brackets(command);
+                            var msg = "Error while exec with command " + cmd;
+                            terminal.error(msg).exception(e);
+                        }
+                    }
+                }
+            }
+            // exec from hash called in each terminal instance
+            if (settings.execHash) {
+                if (location.hash) {
+                    try {
+                        var hash = location.hash.replace(/^#/, '');
+                        // yes no var - global inside terminal
+                        hash_commands = $.parseJSON(decodeURIComponent(hash));
+                        var i = 0;
+                        (function recur() {
+                            var spec = hash_commands[i++];
+                            if (spec) {
+                                exec_spec(spec).then(recur);
+                            } else {
+                                change_hash = true;
+                            }
+                        })();//*/
+                    } catch (e) {
+                        //invalid json - ignore
+                    }
+                } else {
+                    change_hash = true;
+                }
+            } else {
+                change_hash = true; // if enabled later
+            }
+            //change_hash = true; // exec can now change hash
+            // -------------------------------------------------------------
+            if ($.event.special.mousewheel) {
+                var shift = false;
+                $(document).bind('keydown.terminal', function(e) {
+                    if (e.shiftKey) {
+                        shift = true;
+                    }
+                }).bind('keyup.terminal', function(e) {
+                    // in Google Chromium/Linux shiftKey is false
+                    if (e.shiftKey || e.which == 16) {
+                        shift = false;
+                    }
+                });
+                self.mousewheel(function(event, delta) {
+                    if (!shift) {
+                        var interpreter = interpreters.top();
+                        if ($.isFunction(interpreter.mousewheel)) {
+                            var ret = interpreter.mousewheel(event, delta, self);
+                            if (ret === false) {
+                                return;
+                            }
+                        } else if ($.isFunction(settings.mousewheel)) {
+                            settings.mousewheel(event, delta, self);
+                        }
+                        if (delta > 0) {
+                            self.scroll(-40);
+                        } else {
+                            self.scroll(40);
+                        }
+                        //event.preventDefault();
+                    }
+                });
+            }
+        }); // make_interpreter
+        self.data('terminal', self);
+        return self;
+    }; //terminal plugin
+})(jQuery);
-- 
2.10.2

