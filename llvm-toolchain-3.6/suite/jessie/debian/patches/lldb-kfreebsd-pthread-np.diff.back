Index: llvm-toolchain-3.6-3.6~+rc1/lldb/source/Host/freebsd/HostThreadFreeBSD.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/lldb/source/Host/freebsd/HostThreadFreeBSD.cpp
+++ llvm-toolchain-3.6-3.6~+rc1/lldb/source/Host/freebsd/HostThreadFreeBSD.cpp
@@ -14,7 +14,9 @@
 // C includes
 #include <errno.h>
 #include <pthread.h>
+#if defined (__FreeBSD__)
 #include <pthread_np.h>
+#endif
 #include <stdlib.h>
 #include <sys/sysctl.h>
 #include <sys/user.h>
Index: llvm-toolchain-3.6-3.6~+rc1/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/Makefile
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-##===- source/Host/Makefile --------------------------------*- Makefile -*-===##
-# 
-#                     The LLVM Compiler Infrastructure
-#
-# This file is distributed under the University of Illinois Open Source
-# License. See LICENSE.TXT for details.
-# 
-##===----------------------------------------------------------------------===##
-
-LLDB_LEVEL := ../..
-
-include $(LLDB_LEVEL)/../../Makefile.config
-
-DIRS := common
-
-ifeq ($(HOST_OS),Darwin)
-DIRS += posix
-DIRS += macosx
-endif
-
-ifeq ($(HOST_OS),Linux)
-DIRS += posix
-DIRS += linux
-endif
-
-ifneq (,$(filter $(HOST_OS), FreeBSD GNU/kFreeBSD))
-DIRS += posix
-DIRS += freebsd
-endif
-
-ifeq ($(HOST_OS),MingW)
-DIRS += windows
-endif
-
-include $(LLDB_LEVEL)/Makefile
Index: llvm-toolchain-3.6-3.6~+rc1/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/common/Host.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/common/Host.cpp
+++ /dev/null
@@ -1,1073 +0,0 @@
-//===-- Host.cpp ------------------------------------------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "lldb/lldb-python.h"
-
-// C includes
-#include <errno.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#ifndef _WIN32
-#include <unistd.h>
-#include <dlfcn.h>
-#include <grp.h>
-#include <netdb.h>
-#include <pwd.h>
-#include <sys/stat.h>
-#endif
-
-#if defined (__APPLE__)
-#include <mach/mach_port.h>
-#include <mach/mach_init.h>
-#include <mach-o/dyld.h>
-#endif
-
-#if defined (__linux__) || defined (__FreeBSD__) || defined (__FreeBSD_kernel__) || defined (__APPLE__) || defined(__NetBSD__)
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-#include <spawn.h>
-#endif
-#include <sys/wait.h>
-#include <sys/syscall.h>
-#endif
-
-#if defined (__FreeBSD__)
-#include <pthread_np.h>
-#endif
-
-// C++ includes
-#include <limits>
-
-#include "lldb/Host/FileSystem.h"
-#include "lldb/Host/Host.h"
-#include "lldb/Host/HostInfo.h"
-#include "lldb/Core/ArchSpec.h"
-#include "lldb/Core/Debugger.h"
-#include "lldb/Core/Error.h"
-#include "lldb/Core/Log.h"
-#include "lldb/Core/Module.h"
-#include "lldb/Host/FileSpec.h"
-#include "lldb/Host/HostProcess.h"
-#include "lldb/Host/MonitoringProcessLauncher.h"
-#include "lldb/Host/ProcessLauncher.h"
-#include "lldb/Host/ThreadLauncher.h"
-#include "lldb/lldb-private-forward.h"
-#include "lldb/Target/FileAction.h"
-#include "lldb/Target/ProcessLaunchInfo.h"
-#include "lldb/Target/TargetList.h"
-#include "lldb/Utility/CleanUp.h"
-
-#if defined(_WIN32)
-#include "lldb/Host/windows/ProcessLauncherWindows.h"
-#else
-#include "lldb/Host/posix/ProcessLauncherPosix.h"
-#endif
-
-#if defined (__APPLE__)
-#ifndef _POSIX_SPAWN_DISABLE_ASLR
-#define _POSIX_SPAWN_DISABLE_ASLR       0x0100
-#endif
-
-extern "C"
-{
-    int __pthread_chdir(const char *path);
-    int __pthread_fchdir (int fildes);
-}
-
-#endif
-
-using namespace lldb;
-using namespace lldb_private;
-
-#if !defined (__APPLE__) && !defined (_WIN32)
-struct MonitorInfo
-{
-    lldb::pid_t pid;                            // The process ID to monitor
-    Host::MonitorChildProcessCallback callback; // The callback function to call when "pid" exits or signals
-    void *callback_baton;                       // The callback baton for the callback function
-    bool monitor_signals;                       // If true, call the callback when "pid" gets signaled.
-};
-
-static thread_result_t
-MonitorChildProcessThreadFunction (void *arg);
-
-HostThread
-Host::StartMonitoringChildProcess(Host::MonitorChildProcessCallback callback, void *callback_baton, lldb::pid_t pid, bool monitor_signals)
-{
-    MonitorInfo * info_ptr = new MonitorInfo();
-
-    info_ptr->pid = pid;
-    info_ptr->callback = callback;
-    info_ptr->callback_baton = callback_baton;
-    info_ptr->monitor_signals = monitor_signals;
-    
-    char thread_name[256];
-    ::snprintf(thread_name, sizeof(thread_name), "<lldb.host.wait4(pid=%" PRIu64 ")>", pid);
-    return ThreadLauncher::LaunchThread(thread_name, MonitorChildProcessThreadFunction, info_ptr, NULL);
-}
-
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-//------------------------------------------------------------------
-// Scoped class that will disable thread canceling when it is
-// constructed, and exception safely restore the previous value it
-// when it goes out of scope.
-//------------------------------------------------------------------
-class ScopedPThreadCancelDisabler
-{
-public:
-    ScopedPThreadCancelDisabler()
-    {
-        // Disable the ability for this thread to be cancelled
-        int err = ::pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &m_old_state);
-        if (err != 0)
-            m_old_state = -1;
-    }
-
-    ~ScopedPThreadCancelDisabler()
-    {
-        // Restore the ability for this thread to be cancelled to what it
-        // previously was.
-        if (m_old_state != -1)
-            ::pthread_setcancelstate (m_old_state, 0);
-    }
-private:
-    int m_old_state;    // Save the old cancelability state.
-};
-#endif // __ANDROID_NDK__
-
-static thread_result_t
-MonitorChildProcessThreadFunction (void *arg)
-{
-    Log *log(lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS));
-    const char *function = __FUNCTION__;
-    if (log)
-        log->Printf ("%s (arg = %p) thread starting...", function, arg);
-
-    MonitorInfo *info = (MonitorInfo *)arg;
-
-    const Host::MonitorChildProcessCallback callback = info->callback;
-    void * const callback_baton = info->callback_baton;
-    const bool monitor_signals = info->monitor_signals;
-
-    assert (info->pid <= UINT32_MAX);
-    const ::pid_t pid = monitor_signals ? -1 * getpgid(info->pid) : info->pid;
-
-    delete info;
-
-    int status = -1;
-#if defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
-    #define __WALL 0
-#endif
-    const int options = __WALL;
-
-    while (1)
-    {
-        log = lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS);
-        if (log)
-            log->Printf("%s ::wait_pid (pid = %" PRIi32 ", &status, options = %i)...", function, pid, options);
-
-        // Wait for all child processes
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-        ::pthread_testcancel ();
-#endif
-        // Get signals from all children with same process group of pid
-        const ::pid_t wait_pid = ::waitpid (pid, &status, options);
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-        ::pthread_testcancel ();
-#endif
-        if (wait_pid == -1)
-        {
-            if (errno == EINTR)
-                continue;
-            else
-            {
-                if (log)
-                    log->Printf ("%s (arg = %p) thread exiting because waitpid failed (%s)...", __FUNCTION__, arg, strerror(errno));
-                break;
-            }
-        }
-        else if (wait_pid > 0)
-        {
-            bool exited = false;
-            int signal = 0;
-            int exit_status = 0;
-            const char *status_cstr = NULL;
-            if (WIFSTOPPED(status))
-            {
-                signal = WSTOPSIG(status);
-                status_cstr = "STOPPED";
-            }
-            else if (WIFEXITED(status))
-            {
-                exit_status = WEXITSTATUS(status);
-                status_cstr = "EXITED";
-                exited = true;
-            }
-            else if (WIFSIGNALED(status))
-            {
-                signal = WTERMSIG(status);
-                status_cstr = "SIGNALED";
-                if (wait_pid == abs(pid)) {
-                    exited = true;
-                    exit_status = -1;
-                }
-            }
-            else
-            {
-                status_cstr = "(\?\?\?)";
-            }
-
-            // Scope for pthread_cancel_disabler
-            {
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-                ScopedPThreadCancelDisabler pthread_cancel_disabler;
-#endif
-
-                log = lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS);
-                if (log)
-                    log->Printf ("%s ::waitpid (pid = %" PRIi32 ", &status, options = %i) => pid = %" PRIi32 ", status = 0x%8.8x (%s), signal = %i, exit_state = %i",
-                                 function,
-                                 wait_pid,
-                                 options,
-                                 pid,
-                                 status,
-                                 status_cstr,
-                                 signal,
-                                 exit_status);
-
-                if (exited || (signal != 0 && monitor_signals))
-                {
-                    bool callback_return = false;
-                    if (callback)
-                        callback_return = callback (callback_baton, wait_pid, exited, signal, exit_status);
-                    
-                    // If our process exited, then this thread should exit
-                    if (exited && wait_pid == abs(pid))
-                    {
-                        if (log)
-                            log->Printf ("%s (arg = %p) thread exiting because pid received exit signal...", __FUNCTION__, arg);
-                        break;
-                    }
-                    // If the callback returns true, it means this process should
-                    // exit
-                    if (callback_return)
-                    {
-                        if (log)
-                            log->Printf ("%s (arg = %p) thread exiting because callback returned true...", __FUNCTION__, arg);
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    log = lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS);
-    if (log)
-        log->Printf ("%s (arg = %p) thread exiting...", __FUNCTION__, arg);
-
-    return NULL;
-}
-
-#endif // #if !defined (__APPLE__) && !defined (_WIN32)
-
-#if !defined (__APPLE__)
-
-void
-Host::SystemLog (SystemLogType type, const char *format, va_list args)
-{
-    vfprintf (stderr, format, args);
-}
-
-#endif
-
-void
-Host::SystemLog (SystemLogType type, const char *format, ...)
-{
-    va_list args;
-    va_start (args, format);
-    SystemLog (type, format, args);
-    va_end (args);
-}
-
-lldb::pid_t
-Host::GetCurrentProcessID()
-{
-    return ::getpid();
-}
-
-#ifndef _WIN32
-
-lldb::tid_t
-Host::GetCurrentThreadID()
-{
-#if defined (__APPLE__)
-    // Calling "mach_thread_self()" bumps the reference count on the thread
-    // port, so we need to deallocate it. mach_task_self() doesn't bump the ref
-    // count.
-    thread_port_t thread_self = mach_thread_self();
-    mach_port_deallocate(mach_task_self(), thread_self);
-    return thread_self;
-#elif defined(__FreeBSD__)
-    return lldb::tid_t(pthread_getthreadid_np());
-#elif defined(__ANDROID_NDK__)
-    return lldb::tid_t(gettid());
-#elif defined(__linux__)
-    return lldb::tid_t(syscall(SYS_gettid));
-#else
-    return lldb::tid_t(pthread_self());
-#endif
-}
-
-lldb::thread_t
-Host::GetCurrentThread ()
-{
-    return lldb::thread_t(pthread_self());
-}
-
-const char *
-Host::GetSignalAsCString (int signo)
-{
-    switch (signo)
-    {
-    case SIGHUP:    return "SIGHUP";    // 1    hangup
-    case SIGINT:    return "SIGINT";    // 2    interrupt
-    case SIGQUIT:   return "SIGQUIT";   // 3    quit
-    case SIGILL:    return "SIGILL";    // 4    illegal instruction (not reset when caught)
-    case SIGTRAP:   return "SIGTRAP";   // 5    trace trap (not reset when caught)
-    case SIGABRT:   return "SIGABRT";   // 6    abort()
-#if  defined(SIGPOLL)
-#if !defined(SIGIO) || (SIGPOLL != SIGIO)
-// Under some GNU/Linux, SIGPOLL and SIGIO are the same. Causing the build to
-// fail with 'multiple define cases with same value'
-    case SIGPOLL:   return "SIGPOLL";   // 7    pollable event ([XSR] generated, not supported)
-#endif
-#endif
-#if  defined(SIGEMT)
-    case SIGEMT:    return "SIGEMT";    // 7    EMT instruction
-#endif
-    case SIGFPE:    return "SIGFPE";    // 8    floating point exception
-    case SIGKILL:   return "SIGKILL";   // 9    kill (cannot be caught or ignored)
-    case SIGBUS:    return "SIGBUS";    // 10    bus error
-    case SIGSEGV:   return "SIGSEGV";   // 11    segmentation violation
-    case SIGSYS:    return "SIGSYS";    // 12    bad argument to system call
-    case SIGPIPE:   return "SIGPIPE";   // 13    write on a pipe with no one to read it
-    case SIGALRM:   return "SIGALRM";   // 14    alarm clock
-    case SIGTERM:   return "SIGTERM";   // 15    software termination signal from kill
-    case SIGURG:    return "SIGURG";    // 16    urgent condition on IO channel
-    case SIGSTOP:   return "SIGSTOP";   // 17    sendable stop signal not from tty
-    case SIGTSTP:   return "SIGTSTP";   // 18    stop signal from tty
-    case SIGCONT:   return "SIGCONT";   // 19    continue a stopped process
-    case SIGCHLD:   return "SIGCHLD";   // 20    to parent on child stop or exit
-    case SIGTTIN:   return "SIGTTIN";   // 21    to readers pgrp upon background tty read
-    case SIGTTOU:   return "SIGTTOU";   // 22    like TTIN for output if (tp->t_local&LTOSTOP)
-#if  defined(SIGIO)
-    case SIGIO:     return "SIGIO";     // 23    input/output possible signal
-#endif
-    case SIGXCPU:   return "SIGXCPU";   // 24    exceeded CPU time limit
-    case SIGXFSZ:   return "SIGXFSZ";   // 25    exceeded file size limit
-    case SIGVTALRM: return "SIGVTALRM"; // 26    virtual time alarm
-    case SIGPROF:   return "SIGPROF";   // 27    profiling time alarm
-#if  defined(SIGWINCH)
-    case SIGWINCH:  return "SIGWINCH";  // 28    window size changes
-#endif
-#if  defined(SIGINFO)
-    case SIGINFO:   return "SIGINFO";   // 29    information request
-#endif
-    case SIGUSR1:   return "SIGUSR1";   // 30    user defined signal 1
-    case SIGUSR2:   return "SIGUSR2";   // 31    user defined signal 2
-    default:
-        break;
-    }
-    return NULL;
-}
-
-#endif
-
-void
-Host::WillTerminate ()
-{
-}
-
-#if !defined (__APPLE__) && !defined (__FreeBSD__) && !defined (__FreeBSD_kernel__) && !defined (__linux__) // see macosx/Host.mm
-
-void
-Host::Backtrace (Stream &strm, uint32_t max_frames)
-{
-    // TODO: Is there a way to backtrace the current process on other systems?
-}
-
-size_t
-Host::GetEnvironment (StringList &env)
-{
-    // TODO: Is there a way to the host environment for this process on other systems?
-    return 0;
-}
-
-#endif // #if !defined (__APPLE__) && !defined (__FreeBSD__) && !defined (__FreeBSD_kernel__) && !defined (__linux__)
-
-#ifndef _WIN32
-
-lldb::thread_key_t
-Host::ThreadLocalStorageCreate(ThreadLocalStorageCleanupCallback callback)
-{
-    pthread_key_t key;
-    ::pthread_key_create (&key, callback);
-    return key;
-}
-
-void*
-Host::ThreadLocalStorageGet(lldb::thread_key_t key)
-{
-    return ::pthread_getspecific (key);
-}
-
-void
-Host::ThreadLocalStorageSet(lldb::thread_key_t key, void *value)
-{
-   ::pthread_setspecific (key, value);
-}
-
-#endif
-
-#if !defined (__APPLE__) // see Host.mm
-
-bool
-Host::GetBundleDirectory (const FileSpec &file, FileSpec &bundle)
-{
-    bundle.Clear();
-    return false;
-}
-
-bool
-Host::ResolveExecutableInBundle (FileSpec &file)
-{
-    return false;
-}
-#endif
-
-#ifndef _WIN32
-
-FileSpec
-Host::GetModuleFileSpecForHostAddress (const void *host_addr)
-{
-    FileSpec module_filespec;
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-    Dl_info info;
-    if (::dladdr (host_addr, &info))
-    {
-        if (info.dli_fname)
-            module_filespec.SetFile(info.dli_fname, true);
-    }
-#else
-    assert(false && "dladdr() not supported on Android");
-#endif
-    return module_filespec;
-}
-
-#endif
-
-#if !defined(__linux__)
-bool
-Host::FindProcessThreads (const lldb::pid_t pid, TidMap &tids_to_attach)
-{
-    return false;
-}
-#endif
-
-struct ShellInfo
-{
-    ShellInfo () :
-        process_reaped (false),
-        can_delete (false),
-        pid (LLDB_INVALID_PROCESS_ID),
-        signo(-1),
-        status(-1)
-    {
-    }
-
-    lldb_private::Predicate<bool> process_reaped;
-    lldb_private::Predicate<bool> can_delete;
-    lldb::pid_t pid;
-    int signo;
-    int status;
-};
-
-static bool
-MonitorShellCommand (void *callback_baton,
-                     lldb::pid_t pid,
-                     bool exited,       // True if the process did exit
-                     int signo,         // Zero for no signal
-                     int status)   // Exit value of process if signal is zero
-{
-    ShellInfo *shell_info = (ShellInfo *)callback_baton;
-    shell_info->pid = pid;
-    shell_info->signo = signo;
-    shell_info->status = status;
-    // Let the thread running Host::RunShellCommand() know that the process
-    // exited and that ShellInfo has been filled in by broadcasting to it
-    shell_info->process_reaped.SetValue(1, eBroadcastAlways);
-    // Now wait for a handshake back from that thread running Host::RunShellCommand
-    // so we know that we can delete shell_info_ptr
-    shell_info->can_delete.WaitForValueEqualTo(true);
-    // Sleep a bit to allow the shell_info->can_delete.SetValue() to complete...
-    usleep(1000);
-    // Now delete the shell info that was passed into this function
-    delete shell_info;
-    return true;
-}
-
-Error
-Host::RunShellCommand (const char *command,
-                       const char *working_dir,
-                       int *status_ptr,
-                       int *signo_ptr,
-                       std::string *command_output_ptr,
-                       uint32_t timeout_sec,
-                       bool run_in_default_shell)
-{
-    Error error;
-    ProcessLaunchInfo launch_info;
-    launch_info.SetArchitecture(HostInfo::GetArchitecture());
-    if (run_in_default_shell)
-    {
-        // Run the command in a shell
-        launch_info.SetShell(HostInfo::GetDefaultShell());
-        launch_info.GetArguments().AppendArgument(command);
-        const bool localhost = true;
-        const bool will_debug = false;
-        const bool first_arg_is_full_shell_command = true;
-        launch_info.ConvertArgumentsForLaunchingInShell (error,
-                                                         localhost,
-                                                         will_debug,
-                                                         first_arg_is_full_shell_command,
-                                                         0);
-    }
-    else
-    {
-        // No shell, just run it
-        Args args (command);
-        const bool first_arg_is_executable = true;
-        launch_info.SetArguments(args, first_arg_is_executable);
-    }
-    
-    if (working_dir)
-        launch_info.SetWorkingDirectory(working_dir);
-    llvm::SmallString<PATH_MAX> output_file_path;
-
-    if (command_output_ptr)
-    {
-        // Create a temporary file to get the stdout/stderr and redirect the
-        // output of the command into this file. We will later read this file
-        // if all goes well and fill the data into "command_output_ptr"
-        FileSpec tmpdir_file_spec;
-        if (HostInfo::GetLLDBPath(ePathTypeLLDBTempSystemDir, tmpdir_file_spec))
-        {
-            tmpdir_file_spec.AppendPathComponent("lldb-shell-output.%%%%%%");
-            llvm::sys::fs::createUniqueFile(tmpdir_file_spec.GetPath().c_str(), output_file_path);
-        }
-        else
-        {
-            llvm::sys::fs::createTemporaryFile("lldb-shell-output.%%%%%%", "", output_file_path);
-        }
-    }
-    
-    launch_info.AppendSuppressFileAction (STDIN_FILENO, true, false);
-    if (!output_file_path.empty())
-    {
-        launch_info.AppendOpenFileAction(STDOUT_FILENO, output_file_path.c_str(), false, true);
-        launch_info.AppendDuplicateFileAction(STDOUT_FILENO, STDERR_FILENO);
-    }
-    else
-    {
-        launch_info.AppendSuppressFileAction (STDOUT_FILENO, false, true);
-        launch_info.AppendSuppressFileAction (STDERR_FILENO, false, true);
-    }
-    
-    // The process monitor callback will delete the 'shell_info_ptr' below...
-    std::unique_ptr<ShellInfo> shell_info_ap (new ShellInfo());
-    
-    const bool monitor_signals = false;
-    launch_info.SetMonitorProcessCallback(MonitorShellCommand, shell_info_ap.get(), monitor_signals);
-    
-    error = LaunchProcess (launch_info);
-    const lldb::pid_t pid = launch_info.GetProcessID();
-
-    if (error.Success() && pid == LLDB_INVALID_PROCESS_ID)
-        error.SetErrorString("failed to get process ID");
-
-    if (error.Success())
-    {
-        // The process successfully launched, so we can defer ownership of
-        // "shell_info" to the MonitorShellCommand callback function that will
-        // get called when the process dies. We release the unique pointer as it
-        // doesn't need to delete the ShellInfo anymore.
-        ShellInfo *shell_info = shell_info_ap.release();
-        TimeValue *timeout_ptr = nullptr;
-        TimeValue timeout_time(TimeValue::Now());
-        if (timeout_sec > 0) {
-            timeout_time.OffsetWithSeconds(timeout_sec);
-            timeout_ptr = &timeout_time;
-        }
-        bool timed_out = false;
-        shell_info->process_reaped.WaitForValueEqualTo(true, timeout_ptr, &timed_out);
-        if (timed_out)
-        {
-            error.SetErrorString("timed out waiting for shell command to complete");
-
-            // Kill the process since it didn't complete within the timeout specified
-            Kill (pid, SIGKILL);
-            // Wait for the monitor callback to get the message
-            timeout_time = TimeValue::Now();
-            timeout_time.OffsetWithSeconds(1);
-            timed_out = false;
-            shell_info->process_reaped.WaitForValueEqualTo(true, &timeout_time, &timed_out);
-        }
-        else
-        {
-            if (status_ptr)
-                *status_ptr = shell_info->status;
-
-            if (signo_ptr)
-                *signo_ptr = shell_info->signo;
-
-            if (command_output_ptr)
-            {
-                command_output_ptr->clear();
-                FileSpec file_spec(output_file_path.c_str(), File::eOpenOptionRead);
-                uint64_t file_size = file_spec.GetByteSize();
-                if (file_size > 0)
-                {
-                    if (file_size > command_output_ptr->max_size())
-                    {
-                        error.SetErrorStringWithFormat("shell command output is too large to fit into a std::string");
-                    }
-                    else
-                    {
-                        command_output_ptr->resize(file_size);
-                        file_spec.ReadFileContents(0, &((*command_output_ptr)[0]), command_output_ptr->size(), &error);
-                    }
-                }
-            }
-        }
-        shell_info->can_delete.SetValue(true, eBroadcastAlways);
-    }
-
-    FileSpec output_file_spec(output_file_path.c_str(), false);
-    if (FileSystem::GetFileExists(output_file_spec))
-        FileSystem::Unlink(output_file_path.c_str());
-    // Handshake with the monitor thread, or just let it know in advance that
-    // it can delete "shell_info" in case we timed out and were not able to kill
-    // the process...
-    return error;
-}
-
-
-// LaunchProcessPosixSpawn for Apple, Linux, FreeBSD and other GLIBC
-// systems
-
-#if defined (__APPLE__) || defined (__linux__) || defined (__FreeBSD__) || defined (__GLIBC__) || defined(__NetBSD__)
-// this method needs to be visible to macosx/Host.cpp and
-// common/Host.cpp.
-
-short
-Host::GetPosixspawnFlags(const ProcessLaunchInfo &launch_info)
-{
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-    short flags = POSIX_SPAWN_SETSIGDEF | POSIX_SPAWN_SETSIGMASK;
-
-#if defined (__APPLE__)
-    if (launch_info.GetFlags().Test (eLaunchFlagExec))
-        flags |= POSIX_SPAWN_SETEXEC;           // Darwin specific posix_spawn flag
-    
-    if (launch_info.GetFlags().Test (eLaunchFlagDebug))
-        flags |= POSIX_SPAWN_START_SUSPENDED;   // Darwin specific posix_spawn flag
-    
-    if (launch_info.GetFlags().Test (eLaunchFlagDisableASLR))
-        flags |= _POSIX_SPAWN_DISABLE_ASLR;     // Darwin specific posix_spawn flag
-        
-    if (launch_info.GetLaunchInSeparateProcessGroup())
-        flags |= POSIX_SPAWN_SETPGROUP;
-    
-#ifdef POSIX_SPAWN_CLOEXEC_DEFAULT
-#if defined (__APPLE__) && (defined (__x86_64__) || defined (__i386__))
-    static LazyBool g_use_close_on_exec_flag = eLazyBoolCalculate;
-    if (g_use_close_on_exec_flag == eLazyBoolCalculate)
-    {
-        g_use_close_on_exec_flag = eLazyBoolNo;
-        
-        uint32_t major, minor, update;
-        if (HostInfo::GetOSVersion(major, minor, update))
-        {
-            // Kernel panic if we use the POSIX_SPAWN_CLOEXEC_DEFAULT on 10.7 or earlier
-            if (major > 10 || (major == 10 && minor > 7))
-            {
-                // Only enable for 10.8 and later OS versions
-                g_use_close_on_exec_flag = eLazyBoolYes;
-            }
-        }
-    }
-#else
-    static LazyBool g_use_close_on_exec_flag = eLazyBoolYes;
-#endif
-    // Close all files exception those with file actions if this is supported.
-    if (g_use_close_on_exec_flag == eLazyBoolYes)
-        flags |= POSIX_SPAWN_CLOEXEC_DEFAULT;
-#endif
-#endif // #if defined (__APPLE__)
-    return flags;
-#else
-    assert(false && "Host::GetPosixspawnFlags() not supported on Android");
-    return 0;
-#endif
-}
-
-Error
-Host::LaunchProcessPosixSpawn(const char *exe_path, const ProcessLaunchInfo &launch_info, lldb::pid_t &pid)
-{
-    Error error;
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-    Log *log(lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_HOST | LIBLLDB_LOG_PROCESS));
-
-    posix_spawnattr_t attr;
-    error.SetError( ::posix_spawnattr_init (&attr), eErrorTypePOSIX);
-
-    if (error.Fail() || log)
-        error.PutToLog(log, "::posix_spawnattr_init ( &attr )");
-    if (error.Fail())
-        return error;
-
-    // Make a quick class that will cleanup the posix spawn attributes in case
-    // we return in the middle of this function.
-    lldb_utility::CleanUp <posix_spawnattr_t *, int> posix_spawnattr_cleanup(&attr, posix_spawnattr_destroy);
-
-    sigset_t no_signals;
-    sigset_t all_signals;
-    sigemptyset (&no_signals);
-    sigfillset (&all_signals);
-    ::posix_spawnattr_setsigmask(&attr, &no_signals);
-#if defined (__linux__)  || defined (__FreeBSD__)
-    ::posix_spawnattr_setsigdefault(&attr, &no_signals);
-#else
-    ::posix_spawnattr_setsigdefault(&attr, &all_signals);
-#endif
-
-    short flags = GetPosixspawnFlags(launch_info);
-
-    error.SetError( ::posix_spawnattr_setflags (&attr, flags), eErrorTypePOSIX);
-    if (error.Fail() || log)
-        error.PutToLog(log, "::posix_spawnattr_setflags ( &attr, flags=0x%8.8x )", flags);
-    if (error.Fail())
-        return error;
-
-    // posix_spawnattr_setbinpref_np appears to be an Apple extension per:
-    // http://www.unix.com/man-page/OSX/3/posix_spawnattr_setbinpref_np/
-#if defined (__APPLE__) && !defined (__arm__)
-    
-    // Don't set the binpref if a shell was provided.  After all, that's only going to affect what version of the shell
-    // is launched, not what fork of the binary is launched.  We insert "arch --arch <ARCH> as part of the shell invocation
-    // to do that job on OSX.
-    
-    if (launch_info.GetShell() == nullptr)
-    {
-        // We don't need to do this for ARM, and we really shouldn't now that we
-        // have multiple CPU subtypes and no posix_spawnattr call that allows us
-        // to set which CPU subtype to launch...
-        const ArchSpec &arch_spec = launch_info.GetArchitecture();
-        cpu_type_t cpu = arch_spec.GetMachOCPUType();
-        cpu_type_t sub = arch_spec.GetMachOCPUSubType();
-        if (cpu != 0 &&
-            cpu != static_cast<cpu_type_t>(UINT32_MAX) &&
-            cpu != static_cast<cpu_type_t>(LLDB_INVALID_CPUTYPE) &&
-            !(cpu == 0x01000007 && sub == 8)) // If haswell is specified, don't try to set the CPU type or we will fail 
-        {
-            size_t ocount = 0;
-            error.SetError( ::posix_spawnattr_setbinpref_np (&attr, 1, &cpu, &ocount), eErrorTypePOSIX);
-            if (error.Fail() || log)
-                error.PutToLog(log, "::posix_spawnattr_setbinpref_np ( &attr, 1, cpu_type = 0x%8.8x, count => %llu )", cpu, (uint64_t)ocount);
-
-            if (error.Fail() || ocount != 1)
-                return error;
-        }
-    }
-
-#endif
-
-    const char *tmp_argv[2];
-    char * const *argv = (char * const*)launch_info.GetArguments().GetConstArgumentVector();
-    char * const *envp = (char * const*)launch_info.GetEnvironmentEntries().GetConstArgumentVector();
-    if (argv == NULL)
-    {
-        // posix_spawn gets very unhappy if it doesn't have at least the program
-        // name in argv[0]. One of the side affects I have noticed is the environment
-        // variables don't make it into the child process if "argv == NULL"!!!
-        tmp_argv[0] = exe_path;
-        tmp_argv[1] = NULL;
-        argv = (char * const*)tmp_argv;
-    }
-
-#if !defined (__APPLE__)
-    // manage the working directory
-    char current_dir[PATH_MAX];
-    current_dir[0] = '\0';
-#endif
-
-    const char *working_dir = launch_info.GetWorkingDirectory();
-    if (working_dir)
-    {
-#if defined (__APPLE__)
-        // Set the working directory on this thread only
-        if (__pthread_chdir (working_dir) < 0) {
-            if (errno == ENOENT) {
-                error.SetErrorStringWithFormat("No such file or directory: %s", working_dir);
-            } else if (errno == ENOTDIR) {
-                error.SetErrorStringWithFormat("Path doesn't name a directory: %s", working_dir);
-            } else {
-                error.SetErrorStringWithFormat("An unknown error occurred when changing directory for process execution.");
-            }
-            return error;
-        }
-#else
-        if (::getcwd(current_dir, sizeof(current_dir)) == NULL)
-        {
-            error.SetError(errno, eErrorTypePOSIX);
-            error.LogIfError(log, "unable to save the current directory");
-            return error;
-        }
-
-        if (::chdir(working_dir) == -1)
-        {
-            error.SetError(errno, eErrorTypePOSIX);
-            error.LogIfError(log, "unable to change working directory to %s", working_dir);
-            return error;
-        }
-#endif
-    }
-
-    ::pid_t result_pid = LLDB_INVALID_PROCESS_ID;
-    const size_t num_file_actions = launch_info.GetNumFileActions ();
-    if (num_file_actions > 0)
-    {
-        posix_spawn_file_actions_t file_actions;
-        error.SetError( ::posix_spawn_file_actions_init (&file_actions), eErrorTypePOSIX);
-        if (error.Fail() || log)
-            error.PutToLog(log, "::posix_spawn_file_actions_init ( &file_actions )");
-        if (error.Fail())
-            return error;
-
-        // Make a quick class that will cleanup the posix spawn attributes in case
-        // we return in the middle of this function.
-        lldb_utility::CleanUp <posix_spawn_file_actions_t *, int> posix_spawn_file_actions_cleanup (&file_actions, posix_spawn_file_actions_destroy);
-
-        for (size_t i=0; i<num_file_actions; ++i)
-        {
-            const FileAction *launch_file_action = launch_info.GetFileActionAtIndex(i);
-            if (launch_file_action)
-            {
-                if (!AddPosixSpawnFileAction(&file_actions, launch_file_action, log, error))
-                    return error;
-            }
-        }
-
-        error.SetError(::posix_spawnp(&result_pid, exe_path, &file_actions, &attr, argv, envp), eErrorTypePOSIX);
-
-        if (error.Fail() || log)
-        {
-            error.PutToLog(log, "::posix_spawnp ( pid => %i, path = '%s', file_actions = %p, attr = %p, argv = %p, envp = %p )", result_pid,
-                           exe_path, static_cast<void *>(&file_actions), static_cast<void *>(&attr), reinterpret_cast<const void *>(argv),
-                           reinterpret_cast<const void *>(envp));
-            if (log)
-            {
-                for (int ii=0; argv[ii]; ++ii)
-                    log->Printf("argv[%i] = '%s'", ii, argv[ii]);
-            }
-        }
-
-    }
-    else
-    {
-        error.SetError(::posix_spawnp(&result_pid, exe_path, NULL, &attr, argv, envp), eErrorTypePOSIX);
-
-        if (error.Fail() || log)
-        {
-            error.PutToLog(log, "::posix_spawnp ( pid => %i, path = '%s', file_actions = NULL, attr = %p, argv = %p, envp = %p )",
-                           result_pid, exe_path, static_cast<void *>(&attr), reinterpret_cast<const void *>(argv),
-                           reinterpret_cast<const void *>(envp));
-            if (log)
-            {
-                for (int ii=0; argv[ii]; ++ii)
-                    log->Printf("argv[%i] = '%s'", ii, argv[ii]);
-            }
-        }
-    }
-    pid = result_pid;
-
-    if (working_dir)
-    {
-#if defined (__APPLE__)
-        // No more thread specific current working directory
-        __pthread_fchdir (-1);
-#else
-        if (::chdir(current_dir) == -1 && error.Success())
-        {
-            error.SetError(errno, eErrorTypePOSIX);
-            error.LogIfError(log, "unable to change current directory back to %s",
-                    current_dir);
-        }
-#endif
-    }
-#else
-    error.SetErrorString("Host::LaunchProcessPosixSpawn() not supported on Android");
-#endif
-
-    return error;
-}
-
-bool
-Host::AddPosixSpawnFileAction(void *_file_actions, const FileAction *info, Log *log, Error &error)
-{
-#if !defined(__ANDROID__) && !defined(__ANDROID_NDK__)
-    if (info == NULL)
-        return false;
-
-    posix_spawn_file_actions_t *file_actions = reinterpret_cast<posix_spawn_file_actions_t *>(_file_actions);
-
-    switch (info->GetAction())
-    {
-        case FileAction::eFileActionNone:
-            error.Clear();
-            break;
-
-        case FileAction::eFileActionClose:
-            if (info->GetFD() == -1)
-                error.SetErrorString("invalid fd for posix_spawn_file_actions_addclose(...)");
-            else
-            {
-                error.SetError(::posix_spawn_file_actions_addclose(file_actions, info->GetFD()), eErrorTypePOSIX);
-                if (log && (error.Fail() || log))
-                    error.PutToLog(log, "posix_spawn_file_actions_addclose (action=%p, fd=%i)",
-                                   static_cast<void *>(file_actions), info->GetFD());
-            }
-            break;
-
-        case FileAction::eFileActionDuplicate:
-            if (info->GetFD() == -1)
-                error.SetErrorString("invalid fd for posix_spawn_file_actions_adddup2(...)");
-            else if (info->GetActionArgument() == -1)
-                error.SetErrorString("invalid duplicate fd for posix_spawn_file_actions_adddup2(...)");
-            else
-            {
-                error.SetError(
-                    ::posix_spawn_file_actions_adddup2(file_actions, info->GetFD(), info->GetActionArgument()),
-                    eErrorTypePOSIX);
-                if (log && (error.Fail() || log))
-                    error.PutToLog(log, "posix_spawn_file_actions_adddup2 (action=%p, fd=%i, dup_fd=%i)",
-                                   static_cast<void *>(file_actions), info->GetFD(), info->GetActionArgument());
-            }
-            break;
-
-        case FileAction::eFileActionOpen:
-            if (info->GetFD() == -1)
-                error.SetErrorString("invalid fd in posix_spawn_file_actions_addopen(...)");
-            else
-            {
-                int oflag = info->GetActionArgument();
-
-                mode_t mode = 0;
-
-                if (oflag & O_CREAT)
-                    mode = 0640;
-
-                error.SetError(
-                    ::posix_spawn_file_actions_addopen(file_actions, info->GetFD(), info->GetPath(), oflag, mode),
-                    eErrorTypePOSIX);
-                if (error.Fail() || log)
-                    error.PutToLog(log,
-                                   "posix_spawn_file_actions_addopen (action=%p, fd=%i, path='%s', oflag=%i, mode=%i)",
-                                   static_cast<void *>(file_actions), info->GetFD(), info->GetPath(), oflag, mode);
-            }
-            break;
-    }
-    return error.Success();
-#else
-    error.SetErrorString("Host::AddPosixSpawnFileAction() not supported on Android");
-    return false;
-#endif
-}
-#endif // LaunchProcedssPosixSpawn: Apple, Linux, FreeBSD and other GLIBC systems
-
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__GLIBC__) || defined(__NetBSD__) || defined(_WIN32)
-// The functions below implement process launching via posix_spawn() for Linux,
-// FreeBSD and NetBSD.
-
-Error
-Host::LaunchProcess (ProcessLaunchInfo &launch_info)
-{
-    std::unique_ptr<ProcessLauncher> delegate_launcher;
-#if defined(_WIN32)
-    delegate_launcher.reset(new ProcessLauncherWindows());
-#else
-    delegate_launcher.reset(new ProcessLauncherPosix());
-#endif
-    MonitoringProcessLauncher launcher(std::move(delegate_launcher));
-
-    Error error;
-    HostProcess process = launcher.LaunchProcess(launch_info, error);
-
-    // TODO(zturner): It would be better if the entire HostProcess were returned instead of writing
-    // it into this structure.
-    launch_info.SetProcessID(process.GetProcessId());
-
-    return error;
-}
-#endif // defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)
-
-#ifndef _WIN32
-void
-Host::Kill(lldb::pid_t pid, int signo)
-{
-    ::kill(pid, signo);
-}
-
-#endif
-
-#if !defined (__APPLE__)
-bool
-Host::OpenFileInExternalEditor (const FileSpec &file_spec, uint32_t line_no)
-{
-    return false;
-}
-
-void
-Host::SetCrashDescriptionWithFormat (const char *format, ...)
-{
-}
-
-void
-Host::SetCrashDescription (const char *description)
-{
-}
-
-lldb::pid_t
-Host::LaunchApplication (const FileSpec &app_file_spec)
-{
-    return LLDB_INVALID_PROCESS_ID;
-}
-
-#endif
-
-#if !defined (__linux__) && !defined (__FreeBSD__) && !defined (__NetBSD__)
-
-const lldb_private::UnixSignalsSP&
-Host::GetUnixSignals ()
-{
-    static UnixSignalsSP s_unix_signals_sp (new UnixSignals ());
-    return s_unix_signals_sp;
-}
-
-#endif
Index: llvm-toolchain-3.6-3.6~+rc1/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/freebsd/Host.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/freebsd/Host.cpp
+++ /dev/null
@@ -1,314 +0,0 @@
-//===-- source/Host/freebsd/Host.cpp ------------------------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// C Includes
-#include <stdio.h>
-#include <dlfcn.h>
-#include <execinfo.h>
-#include <sys/types.h>
-#include <sys/user.h>
-#include <sys/sysctl.h>
-#include <sys/proc.h>
-
-#include <sys/ptrace.h>
-#include <sys/exec.h>
-#include <machine/elf.h>
-
-// C++ Includes
-// Other libraries and framework includes
-// Project includes
-#include "lldb/Core/Error.h"
-#include "lldb/Host/Endian.h"
-#include "lldb/Host/Host.h"
-#include "lldb/Host/HostInfo.h"
-#include "lldb/Core/Module.h"
-#include "lldb/Core/DataExtractor.h"
-#include "lldb/Core/StreamFile.h"
-#include "lldb/Core/StreamString.h"
-#include "lldb/Core/Log.h"
-#include "lldb/Target/Process.h"
-#include "lldb/Target/Platform.h"
-
-#include "lldb/Core/DataBufferHeap.h"
-#include "lldb/Core/DataExtractor.h"
-#include "lldb/Utility/CleanUp.h"
-
-#include "Plugins/Process/Utility/FreeBSDSignals.h"
-
-#include "llvm/Support/Host.h"
-
-extern "C" {
-    extern char **environ;
-}
-
-using namespace lldb;
-using namespace lldb_private;
-
-void
-Host::Backtrace (Stream &strm, uint32_t max_frames)
-{
-    char backtrace_path[] = "/tmp/lldb-backtrace-tmp-XXXXXX";
-    int backtrace_fd = ::mkstemp (backtrace_path);
-    if (backtrace_fd != -1)
-    {
-        std::vector<void *> frame_buffer (max_frames, NULL);
-        int count = ::backtrace (&frame_buffer[0], frame_buffer.size());
-        ::backtrace_symbols_fd (&frame_buffer[0], count, backtrace_fd);
-
-        const off_t buffer_size = ::lseek(backtrace_fd, 0, SEEK_CUR);
-
-        if (::lseek(backtrace_fd, 0, SEEK_SET) == 0)
-        {
-            char *buffer = (char *)::malloc (buffer_size);
-            if (buffer)
-            {
-                ssize_t bytes_read = ::read (backtrace_fd, buffer, buffer_size);
-                if (bytes_read > 0)
-                    strm.Write(buffer, bytes_read);
-                ::free (buffer);
-            }
-        }
-        ::close (backtrace_fd);
-        ::unlink (backtrace_path);
-    }
-}
-
-size_t
-Host::GetEnvironment (StringList &env)
-{
-    char *v;
-    char **var = environ;
-    for (; var != NULL && *var != NULL; ++var)
-    {
-        v = strchr(*var, (int)'-');
-        if (v == NULL)
-            continue;
-        env.AppendString(v);
-    }
-    return env.GetSize();
-}
-
-static bool
-GetFreeBSDProcessArgs (const ProcessInstanceInfoMatch *match_info_ptr,
-                      ProcessInstanceInfo &process_info)
-{
-    if (process_info.ProcessIDIsValid())
-    {
-        int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_ARGS, (int)process_info.GetProcessID() };
-
-        char arg_data[8192];
-        size_t arg_data_size = sizeof(arg_data);
-        if (::sysctl (mib, 4, arg_data, &arg_data_size , NULL, 0) == 0)
-        {
-            DataExtractor data (arg_data, arg_data_size, lldb::endian::InlHostByteOrder(), sizeof(void *));
-            lldb::offset_t offset = 0;
-            const char *cstr;
-
-            cstr = data.GetCStr (&offset);
-            if (cstr)
-            {
-                process_info.GetExecutableFile().SetFile(cstr, false);
-
-                if (!(match_info_ptr == NULL ||
-                    NameMatches (process_info.GetExecutableFile().GetFilename().GetCString(),
-                                 match_info_ptr->GetNameMatchType(),
-                                 match_info_ptr->GetProcessInfo().GetName())))
-                    return false;
-
-                Args &proc_args = process_info.GetArguments();
-                while (1)
-                {
-                    const uint8_t *p = data.PeekData(offset, 1);
-                    while ((p != NULL) && (*p == '\0') && offset < arg_data_size)
-                    {
-                        ++offset;
-                        p = data.PeekData(offset, 1);
-                    }
-                    if (p == NULL || offset >= arg_data_size)
-                        return true;
-
-                    cstr = data.GetCStr(&offset);
-                    if (cstr)
-                        proc_args.AppendArgument(cstr);
-                    else
-                        return true;
-                }
-            }
-        }
-    }
-    return false;
-}
-
-static bool
-GetFreeBSDProcessCPUType (ProcessInstanceInfo &process_info)
-{
-    if (process_info.ProcessIDIsValid())
-    {
-        process_info.GetArchitecture() = HostInfo::GetArchitecture(HostInfo::eArchKindDefault);
-        return true;
-    }
-    process_info.GetArchitecture().Clear();
-    return false;
-}
-
-static bool
-GetFreeBSDProcessUserAndGroup(ProcessInstanceInfo &process_info)
-{
-    struct kinfo_proc proc_kinfo;
-    size_t proc_kinfo_size;
-
-    if (process_info.ProcessIDIsValid())
-    {
-        int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID,
-            (int)process_info.GetProcessID() };
-        proc_kinfo_size = sizeof(struct kinfo_proc);
-
-        if (::sysctl (mib, 4, &proc_kinfo, &proc_kinfo_size, NULL, 0) == 0)
-        {
-            if (proc_kinfo_size > 0)
-            {
-                process_info.SetParentProcessID (proc_kinfo.ki_ppid);
-                process_info.SetUserID (proc_kinfo.ki_ruid);
-                process_info.SetGroupID (proc_kinfo.ki_rgid);
-                process_info.SetEffectiveUserID (proc_kinfo.ki_uid);
-                if (proc_kinfo.ki_ngroups > 0)
-                    process_info.SetEffectiveGroupID (proc_kinfo.ki_groups[0]);
-                else
-                    process_info.SetEffectiveGroupID (UINT32_MAX);
-                return true;
-            }
-        }
-    }
-    process_info.SetParentProcessID (LLDB_INVALID_PROCESS_ID);
-    process_info.SetUserID (UINT32_MAX);
-    process_info.SetGroupID (UINT32_MAX);
-    process_info.SetEffectiveUserID (UINT32_MAX);
-    process_info.SetEffectiveGroupID (UINT32_MAX);
-    return false;
-}
-
-uint32_t
-Host::FindProcesses (const ProcessInstanceInfoMatch &match_info, ProcessInstanceInfoList &process_infos)
-{
-    std::vector<struct kinfo_proc> kinfos;
-
-    int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL };
-
-    size_t pid_data_size = 0;
-    if (::sysctl (mib, 3, NULL, &pid_data_size, NULL, 0) != 0)
-        return 0;
-
-    // Add a few extra in case a few more show up
-    const size_t estimated_pid_count = (pid_data_size / sizeof(struct kinfo_proc)) + 10;
-
-    kinfos.resize (estimated_pid_count);
-    pid_data_size = kinfos.size() * sizeof(struct kinfo_proc);
-
-    if (::sysctl (mib, 3, &kinfos[0], &pid_data_size, NULL, 0) != 0)
-        return 0;
-
-    const size_t actual_pid_count = (pid_data_size / sizeof(struct kinfo_proc));
-
-    bool all_users = match_info.GetMatchAllUsers();
-    const ::pid_t our_pid = getpid();
-    const uid_t our_uid = getuid();
-    for (size_t i = 0; i < actual_pid_count; i++)
-    {
-        const struct kinfo_proc &kinfo = kinfos[i];
-        const bool kinfo_user_matches = (all_users ||
-                                         (kinfo.ki_ruid == our_uid) ||
-                                         // Special case, if lldb is being run as root we can attach to anything.
-                                         (our_uid == 0)
-                                         );
-
-        if (kinfo_user_matches == false      || // Make sure the user is acceptable
-            kinfo.ki_pid == our_pid          || // Skip this process
-            kinfo.ki_pid == 0                || // Skip kernel (kernel pid is zero)
-            kinfo.ki_stat == SZOMB    || // Zombies are bad, they like brains...
-            kinfo.ki_flag & P_TRACED  || // Being debugged?
-            kinfo.ki_flag & P_WEXIT)     // Working on exiting
-            continue;
-
-        // Every thread is a process in FreeBSD, but all the threads of a single process
-        // have the same pid. Do not store the process info in the result list if a process
-        // with given identifier is already registered there.
-        bool already_registered = false;
-        for (uint32_t pi = 0;
-             !already_registered &&
-             (const int)kinfo.ki_numthreads > 1 &&
-             pi < (const uint32_t)process_infos.GetSize(); pi++)
-            already_registered = (process_infos.GetProcessIDAtIndex(pi) == (uint32_t)kinfo.ki_pid);
-
-        if (already_registered)
-            continue;
-
-        ProcessInstanceInfo process_info;
-        process_info.SetProcessID (kinfo.ki_pid);
-        process_info.SetParentProcessID (kinfo.ki_ppid);
-        process_info.SetUserID (kinfo.ki_ruid);
-        process_info.SetGroupID (kinfo.ki_rgid);
-        process_info.SetEffectiveUserID (kinfo.ki_svuid);
-        process_info.SetEffectiveGroupID (kinfo.ki_svgid);
-
-        // Make sure our info matches before we go fetch the name and cpu type
-        if (match_info.Matches (process_info) &&
-            GetFreeBSDProcessArgs (&match_info, process_info))
-        {
-            GetFreeBSDProcessCPUType (process_info);
-            if (match_info.Matches (process_info))
-                process_infos.Append (process_info);
-        }
-    }
-
-    return process_infos.GetSize();
-}
-
-bool
-Host::GetProcessInfo (lldb::pid_t pid, ProcessInstanceInfo &process_info)
-{
-    process_info.SetProcessID(pid);
-
-    if (GetFreeBSDProcessArgs(NULL, process_info))
-    {
-        // should use libprocstat instead of going right into sysctl?
-        GetFreeBSDProcessCPUType(process_info);
-        GetFreeBSDProcessUserAndGroup(process_info);
-        return true;
-    }
-
-    process_info.Clear();
-    return false;
-}
-
-lldb::DataBufferSP
-Host::GetAuxvData(lldb_private::Process *process)
-{
-   int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_AUXV, 0 };
-   size_t auxv_size = AT_COUNT * sizeof(Elf_Auxinfo);
-   DataBufferSP buf_sp;
-
-   std::unique_ptr<DataBufferHeap> buf_ap(new DataBufferHeap(auxv_size, 0));
-
-   mib[3] = process->GetID();
-   if (::sysctl(mib, 4, buf_ap->GetBytes(), &auxv_size, NULL, 0) == 0) {
-           buf_sp.reset(buf_ap.release());
-   } else {
-           perror("sysctl failed on auxv");
-   }
-
-   return buf_sp;
-}
-
-const UnixSignalsSP&
-Host::GetUnixSignals ()
-{
-    static const lldb_private::UnixSignalsSP s_unix_signals_sp (new FreeBSDSignals ());
-    return s_unix_signals_sp;
-}
-
Index: llvm-toolchain-3.6-3.6~+rc1/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/freebsd/ThisThread.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/freebsd/ThisThread.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-//===-- ThisThread.cpp ------------------------------------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "lldb/Host/HostNativeThread.h"
-#include "lldb/Host/ThisThread.h"
-
-#include "llvm/ADT/SmallVector.h"
-
-#include <pthread.h>
-#include <pthread_np.h>
-
-using namespace lldb_private;
-
-void
-ThisThread::SetName(llvm::StringRef name)
-{
-    ::pthread_set_name_np(::pthread_self(), name.data());
-}
-
-void
-ThisThread::GetName(llvm::SmallVectorImpl<char> &name)
-{
-    HostNativeThread::GetName(::pthread_getthreadid_np(), name);
-}
Index: llvm-toolchain-3.6-3.6~+rc1/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/linux/Host.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/home/sylvestre/llvm-toolchain-3.6-3.6~+rc1/tools/lldb/source/Host/linux/Host.cpp
+++ /dev/null
@@ -1,419 +0,0 @@
-//===-- source/Host/linux/Host.cpp ------------------------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-// C Includes
-#include <stdio.h>
-#include <sys/utsname.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <fcntl.h>
-#ifndef __ANDROID__
-#include <execinfo.h>
-#endif
-
-// C++ Includes
-// Other libraries and framework includes
-// Project includes
-#include "lldb/Core/Error.h"
-#include "lldb/Core/Log.h"
-#include "lldb/Target/Process.h"
-
-#include "lldb/Host/Host.h"
-#ifdef __ANDROID_NDK__
-#include "lldb/Host/android/Android.h"
-#endif
-#include "lldb/Core/DataBufferHeap.h"
-#include "lldb/Core/DataExtractor.h"
-
-#include "lldb/Core/ModuleSpec.h"
-#include "lldb/Symbol/ObjectFile.h"
-#include "Plugins/Process/Linux/ProcFileReader.h"
-#include "Plugins/Process/Utility/LinuxSignals.h"
-
-using namespace lldb;
-using namespace lldb_private;
-
-typedef enum ProcessStateFlags
-{
-    eProcessStateRunning           = (1u << 0), // Running
-    eProcessStateSleeping          = (1u << 1), // Sleeping in an interruptible wait
-    eProcessStateWaiting           = (1u << 2), // Waiting in an uninterruptible disk sleep
-    eProcessStateZombie            = (1u << 3), // Zombie
-    eProcessStateTracedOrStopped   = (1u << 4), // Traced or stopped (on a signal)
-    eProcessStatePaging            = (1u << 5)  // Paging
-} ProcessStateFlags;
-
-typedef struct ProcessStatInfo
-{
-    lldb::pid_t ppid;           // Parent Process ID
-    uint32_t fProcessState;     // ProcessStateFlags
-} ProcessStatInfo;
-
-// Get the process info with additional information from /proc/$PID/stat (like process state, and tracer pid).
-static bool GetProcessAndStatInfo (lldb::pid_t pid, ProcessInstanceInfo &process_info, ProcessStatInfo &stat_info, lldb::pid_t &tracerpid);
-
-static bool
-ReadProcPseudoFileStat (lldb::pid_t pid, ProcessStatInfo& stat_info)
-{
-    // Read the /proc/$PID/stat file.
-    lldb::DataBufferSP buf_sp = ProcFileReader::ReadIntoDataBuffer (pid, "stat");
-
-    // The filename of the executable is stored in parenthesis right after the pid. We look for the closing
-    // parenthesis for the filename and work from there in case the name has something funky like ')' in it.
-    const char *filename_end = strrchr ((const char *)buf_sp->GetBytes(), ')');
-    if (filename_end)
-    {
-        char state = '\0';
-        int ppid = LLDB_INVALID_PROCESS_ID;
-
-        // Read state and ppid.
-        sscanf (filename_end + 1, " %c %d", &state, &ppid);
-
-        stat_info.ppid = ppid;
-
-        switch (state)
-        {
-            case 'R':
-                stat_info.fProcessState |= eProcessStateRunning;
-                break;
-            case 'S':
-                stat_info.fProcessState |= eProcessStateSleeping;
-                break;
-            case 'D':
-                stat_info.fProcessState |= eProcessStateWaiting;
-                break;
-            case 'Z':
-                stat_info.fProcessState |= eProcessStateZombie;
-                break;
-            case 'T':
-                stat_info.fProcessState |= eProcessStateTracedOrStopped;
-                break;
-            case 'W':
-                stat_info.fProcessState |= eProcessStatePaging;
-                break;
-        }
-
-        return true;
-    }
-
-    return false;
-}
-
-static void
-GetLinuxProcessUserAndGroup (lldb::pid_t pid, ProcessInstanceInfo &process_info, lldb::pid_t &tracerpid)
-{
-    tracerpid = 0;
-    uint32_t rUid = UINT32_MAX;     // Real User ID
-    uint32_t eUid = UINT32_MAX;     // Effective User ID
-    uint32_t rGid = UINT32_MAX;     // Real Group ID
-    uint32_t eGid = UINT32_MAX;     // Effective Group ID
-
-    // Read the /proc/$PID/status file and parse the Uid:, Gid:, and TracerPid: fields.
-    lldb::DataBufferSP buf_sp = ProcFileReader::ReadIntoDataBuffer (pid, "status");
-
-    static const char uid_token[] = "Uid:";
-    char *buf_uid = strstr ((char *)buf_sp->GetBytes(), uid_token);
-    if (buf_uid)
-    {
-        // Real, effective, saved set, and file system UIDs. Read the first two.
-        buf_uid += sizeof(uid_token);
-        rUid = strtol (buf_uid, &buf_uid, 10);
-        eUid = strtol (buf_uid, &buf_uid, 10);
-    }
-
-    static const char gid_token[] = "Gid:";
-    char *buf_gid = strstr ((char *)buf_sp->GetBytes(), gid_token);
-    if (buf_gid)
-    {
-        // Real, effective, saved set, and file system GIDs. Read the first two.
-        buf_gid += sizeof(gid_token);
-        rGid = strtol (buf_gid, &buf_gid, 10);
-        eGid = strtol (buf_gid, &buf_gid, 10);
-    }
-
-    static const char tracerpid_token[] = "TracerPid:";
-    char *buf_tracerpid = strstr((char *)buf_sp->GetBytes(), tracerpid_token);
-    if (buf_tracerpid)
-    {
-        // Tracer PID. 0 if we're not being debugged.
-        buf_tracerpid += sizeof(tracerpid_token);
-        tracerpid = strtol (buf_tracerpid, &buf_tracerpid, 10);
-    }
-
-    process_info.SetUserID (rUid);
-    process_info.SetEffectiveUserID (eUid);
-    process_info.SetGroupID (rGid);
-    process_info.SetEffectiveGroupID (eGid);
-}
-
-lldb::DataBufferSP
-Host::GetAuxvData(lldb_private::Process *process)
-{
-    return ProcFileReader::ReadIntoDataBuffer (process->GetID(), "auxv");
-}
-
-lldb::DataBufferSP
-Host::GetAuxvData (lldb::pid_t pid)
-{
-    return ProcFileReader::ReadIntoDataBuffer (pid, "auxv");
-}
-
-static bool
-IsDirNumeric(const char *dname)
-{
-    for (; *dname; dname++)
-    {
-        if (!isdigit (*dname))
-            return false;
-    }
-    return true;
-}
-
-uint32_t
-Host::FindProcesses (const ProcessInstanceInfoMatch &match_info, ProcessInstanceInfoList &process_infos)
-{
-    static const char procdir[] = "/proc/";
-
-    DIR *dirproc = opendir (procdir);
-    if (dirproc)
-    {
-        struct dirent *direntry = NULL;
-        const uid_t our_uid = getuid();
-        const lldb::pid_t our_pid = getpid();
-        bool all_users = match_info.GetMatchAllUsers();
-
-        while ((direntry = readdir (dirproc)) != NULL)
-        {
-            if (direntry->d_type != DT_DIR || !IsDirNumeric (direntry->d_name))
-                continue;
-
-            lldb::pid_t pid = atoi (direntry->d_name);
-
-            // Skip this process.
-            if (pid == our_pid)
-                continue;
-
-            lldb::pid_t tracerpid;
-            ProcessStatInfo stat_info;
-            ProcessInstanceInfo process_info;
-
-            if (!GetProcessAndStatInfo (pid, process_info, stat_info, tracerpid))
-                continue;
-
-            // Skip if process is being debugged.
-            if (tracerpid != 0)
-                continue;
-
-            // Skip zombies.
-            if (stat_info.fProcessState & eProcessStateZombie)
-                continue;
-
-            // Check for user match if we're not matching all users and not running as root.
-            if (!all_users && (our_uid != 0) && (process_info.GetUserID() != our_uid))
-                continue;
-
-            if (match_info.Matches (process_info))
-            {
-                process_infos.Append (process_info);
-            }
-        }
-
-        closedir (dirproc);
-    }
-
-    return process_infos.GetSize();
-}
-
-bool
-Host::FindProcessThreads (const lldb::pid_t pid, TidMap &tids_to_attach)
-{
-    bool tids_changed = false;
-    static const char procdir[] = "/proc/";
-    static const char taskdir[] = "/task/";
-    std::string process_task_dir = procdir + std::to_string(pid) + taskdir;
-    DIR *dirproc = opendir (process_task_dir.c_str());
-
-    if (dirproc)
-    {
-        struct dirent *direntry = NULL;
-        while ((direntry = readdir (dirproc)) != NULL)
-        {
-            if (direntry->d_type != DT_DIR || !IsDirNumeric (direntry->d_name))
-                continue;
-
-            lldb::tid_t tid = atoi(direntry->d_name);
-            TidMap::iterator it = tids_to_attach.find(tid);
-            if (it == tids_to_attach.end())
-            {
-                tids_to_attach.insert(TidPair(tid, false));
-                tids_changed = true;
-            }
-        }
-        closedir (dirproc);
-    }
-
-    return tids_changed;
-}
-
-static bool
-GetELFProcessCPUType (const char *exe_path, ProcessInstanceInfo &process_info)
-{
-    // Clear the architecture.
-    process_info.GetArchitecture().Clear();
-
-    ModuleSpecList specs;
-    FileSpec filespec (exe_path, false);
-    const size_t num_specs = ObjectFile::GetModuleSpecifications (filespec, 0, 0, specs);
-    // GetModuleSpecifications() could fail if the executable has been deleted or is locked.
-    // But it shouldn't return more than 1 architecture.
-    assert(num_specs <= 1 && "Linux plugin supports only a single architecture");
-    if (num_specs == 1)
-    {
-        ModuleSpec module_spec;
-        if (specs.GetModuleSpecAtIndex (0, module_spec) && module_spec.GetArchitecture().IsValid())
-        {
-            process_info.GetArchitecture () = module_spec.GetArchitecture();
-            return true;
-        }
-    }
-    return false;
-}
-
-static bool
-GetProcessAndStatInfo (lldb::pid_t pid, ProcessInstanceInfo &process_info, ProcessStatInfo &stat_info, lldb::pid_t &tracerpid)
-{
-    tracerpid = 0;
-    process_info.Clear();
-    ::memset (&stat_info, 0, sizeof(stat_info));
-    stat_info.ppid = LLDB_INVALID_PROCESS_ID;
-
-    // Use special code here because proc/[pid]/exe is a symbolic link.
-    char link_path[PATH_MAX];
-    char exe_path[PATH_MAX] = "";
-    if (snprintf (link_path, PATH_MAX, "/proc/%" PRIu64 "/exe", pid) <= 0)
-        return false;
-
-    ssize_t len = readlink (link_path, exe_path, sizeof(exe_path) - 1);
-    if (len <= 0)
-        return false;
-
-    // readlink does not append a null byte.
-    exe_path[len] = 0;
-
-    // If the binary has been deleted, the link name has " (deleted)" appended.
-    //  Remove if there.
-    static const ssize_t deleted_len = strlen(" (deleted)");
-    if (len > deleted_len &&
-        !strcmp(exe_path + len - deleted_len, " (deleted)"))
-    {
-        exe_path[len - deleted_len] = 0;
-    }
-    else
-    {
-        GetELFProcessCPUType (exe_path, process_info);
-    }
-
-    process_info.SetProcessID(pid);
-    process_info.GetExecutableFile().SetFile(exe_path, false);
-
-    lldb::DataBufferSP buf_sp;
-
-    // Get the process environment.
-    buf_sp = ProcFileReader::ReadIntoDataBuffer(pid, "environ");
-    Args &info_env = process_info.GetEnvironmentEntries();
-    char *next_var = (char *)buf_sp->GetBytes();
-    char *end_buf = next_var + buf_sp->GetByteSize();
-    while (next_var < end_buf && 0 != *next_var)
-    {
-        info_env.AppendArgument(next_var);
-        next_var += strlen(next_var) + 1;
-    }
-
-    // Get the command line used to start the process.
-    buf_sp = ProcFileReader::ReadIntoDataBuffer(pid, "cmdline");
-
-    // Grab Arg0 first, if there is one.
-    char *cmd = (char *)buf_sp->GetBytes();
-    if (cmd)
-    {
-        process_info.SetArg0(cmd);
-
-        // Now process any remaining arguments.
-        Args &info_args = process_info.GetArguments();
-        char *next_arg = cmd + strlen(cmd) + 1;
-        end_buf = cmd + buf_sp->GetByteSize();
-        while (next_arg < end_buf && 0 != *next_arg)
-        {
-            info_args.AppendArgument(next_arg);
-            next_arg += strlen(next_arg) + 1;
-        }
-    }
-
-    // Read /proc/$PID/stat to get our parent pid.
-    if (ReadProcPseudoFileStat (pid, stat_info))
-    {
-        process_info.SetParentProcessID (stat_info.ppid);
-    }
-
-    // Get User and Group IDs and get tracer pid.
-    GetLinuxProcessUserAndGroup (pid, process_info, tracerpid);
-
-    return true;
-}
-
-bool
-Host::GetProcessInfo (lldb::pid_t pid, ProcessInstanceInfo &process_info)
-{
-    lldb::pid_t tracerpid;
-    ProcessStatInfo stat_info;
-
-    return GetProcessAndStatInfo (pid, process_info, stat_info, tracerpid);
-}
-
-void
-Host::Backtrace (Stream &strm, uint32_t max_frames)
-{
-#ifndef __ANDROID__
-    if (max_frames > 0)
-    {
-        std::vector<void *> frame_buffer (max_frames, NULL);
-        int num_frames = ::backtrace (&frame_buffer[0], frame_buffer.size());
-        char** strs = ::backtrace_symbols (&frame_buffer[0], num_frames);
-        if (strs)
-        {
-            // Start at 1 to skip the "Host::Backtrace" frame
-            for (int i = 1; i < num_frames; ++i)
-                strm.Printf("%s\n", strs[i]);
-            ::free (strs);
-        }
-    }
-#else
-    assert(false && "::backtrace() not supported on Android");
-#endif
-}
-
-size_t
-Host::GetEnvironment (StringList &env)
-{
-    char **host_env = environ;
-    char *env_entry;
-    size_t i;
-    for (i=0; (env_entry = host_env[i]) != NULL; ++i)
-        env.AppendString(env_entry);
-    return i;
-}
-
-const lldb_private::UnixSignalsSP&
-Host::GetUnixSignals ()
-{
-    static const lldb_private::UnixSignalsSP s_unix_signals_sp (new process_linux::LinuxSignals ());
-    return s_unix_signals_sp;
-}
-
Index: llvm-toolchain-3.6-3.6~+rc1/lldb/source/Host/common/Host.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/lldb/source/Host/common/Host.cpp
+++ llvm-toolchain-3.6-3.6~+rc1/lldb/source/Host/common/Host.cpp
@@ -1061,7 +1061,7 @@ Host::LaunchApplication (const FileSpec
 
 #endif
 
-#if !defined (__linux__) && !defined (__FreeBSD__) && !defined (__NetBSD__)
+#if !defined (__linux__) && !defined (__FreeBSD__) && !defined (__NetBSD__) && !defined(__FreeBSD_kernel__)
 
 const lldb_private::UnixSignalsSP&
 Host::GetUnixSignals ()
Index: llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MICmnLogMediumFile.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/lldb/tools/lldb-mi/MICmnLogMediumFile.cpp
+++ llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MICmnLogMediumFile.cpp
@@ -24,7 +24,7 @@
 #include "MICmnResources.h"
 #if defined(_MSC_VER)
 #include "MIUtilSystemWindows.h"
-#elif defined(__FreeBSD__) || defined(__linux__)
+#elif defined(__FreeBSD__) || defined(__linux__) || defined(__FreeBSD_kernel__)
 #include "MIUtilSystemLinux.h"
 #elif defined(__APPLE__)
 #include "MIUtilSystemOsx.h"
Index: llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MIUtilSystemLinux.cpp
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/lldb/tools/lldb-mi/MIUtilSystemLinux.cpp
+++ llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MIUtilSystemLinux.cpp
@@ -19,7 +19,7 @@
 // Copyright:   None.
 //--
 
-#if defined(__FreeBSD__) || defined(__linux__)
+#if defined(__FreeBSD__) || defined(__linux__) || defined(__FreeBSD_kernel__)
 
 // In-house headers:
 #include "MIUtilSystemLinux.h"
Index: llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MIUtilSystemLinux.h
===================================================================
--- llvm-toolchain-3.6-3.6~+rc1.orig/lldb/tools/lldb-mi/MIUtilSystemLinux.h
+++ llvm-toolchain-3.6-3.6~+rc1/lldb/tools/lldb-mi/MIUtilSystemLinux.h
@@ -21,7 +21,7 @@
 
 #pragma once
 
-#if defined(__FreeBSD__) || defined(__linux__)
+#if defined(__FreeBSD__) || defined(__linux__) || defined(__FreeBSD_kernel__)
 
 // In-house headers:
 #include "MIUtilString.h"
