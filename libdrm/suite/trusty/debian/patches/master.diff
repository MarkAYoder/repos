diff --git a/Makefile.am b/Makefile.am
index 3952a88..3cb516c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -53,7 +53,11 @@ if HAVE_FREEDRENO
 FREEDRENO_SUBDIR = freedreno
 endif
 
-SUBDIRS = . $(LIBKMS_SUBDIR) $(INTEL_SUBDIR) $(NOUVEAU_SUBDIR) $(RADEON_SUBDIR) $(OMAP_SUBDIR) $(EXYNOS_SUBDIR) $(FREEDRENO_SUBDIR) tests man
+if HAVE_TEGRA
+TEGRA_SUBDIR = tegra
+endif
+
+SUBDIRS = . $(LIBKMS_SUBDIR) $(INTEL_SUBDIR) $(NOUVEAU_SUBDIR) $(RADEON_SUBDIR) $(OMAP_SUBDIR) $(EXYNOS_SUBDIR) $(FREEDRENO_SUBDIR) $(TEGRA_SUBDIR) tests man
 
 libdrm_la_LTLIBRARIES = libdrm.la
 libdrm_ladir = $(libdir)
diff --git a/Makefile.sources b/Makefile.sources
index d86fb2a..566f7b5 100644
--- a/Makefile.sources
+++ b/Makefile.sources
@@ -26,6 +26,7 @@ LIBDRM_INCLUDE_H_FILES := \
 	include/drm/radeon_drm.h \
 	include/drm/savage_drm.h \
 	include/drm/sis_drm.h \
+	include/drm/tegra_drm.h \
 	include/drm/via_drm.h
 
 LIBDRM_INCLUDE_VMWGFX_H_FILES := \
diff --git a/configure.ac b/configure.ac
index ee59b03..c88a1c5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -98,6 +98,11 @@ AC_ARG_ENABLE(freedreno-experimental-api,
 	      [Enable support for freedreno's experimental API (default: disabled)]),
 	      [FREEDRENO=$enableval], [FREEDRENO=no])
 
+AC_ARG_ENABLE(tegra-experimental-api,
+	      AS_HELP_STRING([--enable-tegra-experimental-api],
+	      [Enable support for Tegra's experimental API (default: disabled)]),
+	      [TEGRA=$enableval], [TEGRA=no])
+
 AC_ARG_ENABLE(install-test-programs,
 		  AS_HELP_STRING([--enable-install-test-programs],
 		  [Install test programs (default: no)]),
@@ -304,6 +309,11 @@ if test "x$RADEON" = xyes; then
 	AC_DEFINE(HAVE_RADEON, 1, [Have radeon support])
 fi
 
+AM_CONDITIONAL(HAVE_TEGRA, [test "x$TEGRA" = xyes])
+if test "x$TEGRA" = xyes; then
+	AC_DEFINE(HAVE_TEGRA, 1, [Have Tegra support])
+fi
+
 AM_CONDITIONAL(HAVE_INSTALL_TESTS, [test "x$INSTALL_TESTS" = xyes])
 if test "x$INSTALL_TESTS" = xyes; then
 	AC_DEFINE(HAVE_INSTALL_TESTS, 1, [Install test programs])
@@ -403,13 +413,17 @@ AC_CONFIG_FILES([
 	exynos/libdrm_exynos.pc
 	freedreno/Makefile
 	freedreno/libdrm_freedreno.pc
+	tegra/Makefile
+	tegra/libdrm_tegra.pc
 	tests/Makefile
 	tests/modeprint/Makefile
 	tests/modetest/Makefile
 	tests/kmstest/Makefile
+	tests/proptest/Makefile
 	tests/radeon/Makefile
 	tests/vbltest/Makefile
 	tests/exynos/Makefile
+	tests/tegra/Makefile
 	man/Makefile
 	libdrm.pc])
 AC_OUTPUT
@@ -425,4 +439,5 @@ echo "  Nouveau API    $NOUVEAU"
 echo "  OMAP API       $OMAP"
 echo "  EXYNOS API     $EXYNOS"
 echo "  Freedreno API  $FREEDRENO"
+echo "  Tegra API      $TEGRA"
 echo ""
diff --git a/freedreno/freedreno_bo.c b/freedreno/freedreno_bo.c
index fe8f503..9089c93 100644
--- a/freedreno/freedreno_bo.c
+++ b/freedreno/freedreno_bo.c
@@ -207,7 +207,14 @@ fd_bo_from_handle(struct fd_device *dev, uint32_t handle, uint32_t size)
 	struct fd_bo *bo = NULL;
 
 	pthread_mutex_lock(&table_lock);
+
+	bo = lookup_bo(dev->handle_table, handle);
+	if (bo)
+		goto out_unlock;
+
 	bo = bo_from_handle(dev, size, handle);
+
+out_unlock:
 	pthread_mutex_unlock(&table_lock);
 
 	return bo;
diff --git a/include/drm/drm_mode.h b/include/drm/drm_mode.h
index 76fd76b..a2ab88a 100644
--- a/include/drm/drm_mode.h
+++ b/include/drm/drm_mode.h
@@ -173,6 +173,9 @@ struct drm_mode_get_plane_res {
 #define DRM_MODE_ENCODER_TMDS	2
 #define DRM_MODE_ENCODER_LVDS	3
 #define DRM_MODE_ENCODER_TVDAC	4
+#define DRM_MODE_ENCODER_VIRTUAL 5
+#define DRM_MODE_ENCODER_DSI	6
+#define DRM_MODE_ENCODER_DPMST	7
 
 struct drm_mode_get_encoder {
 	__u32 encoder_id;
@@ -210,6 +213,8 @@ struct drm_mode_get_encoder {
 #define DRM_MODE_CONNECTOR_HDMIB	12
 #define DRM_MODE_CONNECTOR_TV		13
 #define DRM_MODE_CONNECTOR_eDP		14
+#define DRM_MODE_CONNECTOR_VIRTUAL      15
+#define DRM_MODE_CONNECTOR_DSI		16
 
 struct drm_mode_get_connector {
 
@@ -239,6 +244,21 @@ struct drm_mode_get_connector {
 #define DRM_MODE_PROP_BLOB	(1<<4)
 #define DRM_MODE_PROP_BITMASK	(1<<5) /* bitmask of enumerated types */
 
+/* non-extended types: legacy bitmask, one bit per type: */
+#define DRM_MODE_PROP_LEGACY_TYPE  ( \
+		DRM_MODE_PROP_RANGE | \
+		DRM_MODE_PROP_ENUM | \
+		DRM_MODE_PROP_BLOB | \
+		DRM_MODE_PROP_BITMASK)
+
+/* extended-types: rather than continue to consume a bit per type,
+ * grab a chunk of the bits to use as integer type id.
+ */
+#define DRM_MODE_PROP_EXTENDED_TYPE	0x0000ffc0
+#define DRM_MODE_PROP_TYPE(n)		((n) << 6)
+#define DRM_MODE_PROP_OBJECT		DRM_MODE_PROP_TYPE(1)
+#define DRM_MODE_PROP_SIGNED_RANGE	DRM_MODE_PROP_TYPE(2)
+
 struct drm_mode_property_enum {
 	__u64 value;
 	char name[DRM_PROP_NAME_LEN];
diff --git a/include/drm/tegra_drm.h b/include/drm/tegra_drm.h
new file mode 100644
index 0000000..8dae8f3
--- /dev/null
+++ b/include/drm/tegra_drm.h
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2012-2013, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _UAPI_TEGRA_DRM_H_
+#define _UAPI_TEGRA_DRM_H_
+
+#include <drm.h>
+
+#define DRM_TEGRA_GEM_CREATE_TILED     (1 << 0)
+#define DRM_TEGRA_GEM_CREATE_BOTTOM_UP (1 << 1)
+
+struct drm_tegra_gem_create {
+	__u64 size;
+	__u32 flags;
+	__u32 handle;
+};
+
+struct drm_tegra_gem_mmap {
+	__u32 handle;
+	__u32 offset;
+};
+
+struct drm_tegra_syncpt_read {
+	__u32 id;
+	__u32 value;
+};
+
+struct drm_tegra_syncpt_incr {
+	__u32 id;
+	__u32 pad;
+};
+
+struct drm_tegra_syncpt_wait {
+	__u32 id;
+	__u32 thresh;
+	__u32 timeout;
+	__u32 value;
+};
+
+#define DRM_TEGRA_NO_TIMEOUT	(0xffffffff)
+
+struct drm_tegra_open_channel {
+	__u32 client;
+	__u32 pad;
+	__u64 context;
+};
+
+struct drm_tegra_close_channel {
+	__u64 context;
+};
+
+struct drm_tegra_get_syncpt {
+	__u64 context;
+	__u32 index;
+	__u32 id;
+};
+
+struct drm_tegra_get_syncpt_base {
+	__u64 context;
+	__u32 syncpt;
+	__u32 id;
+};
+
+struct drm_tegra_syncpt {
+	__u32 id;
+	__u32 incrs;
+};
+
+struct drm_tegra_cmdbuf {
+	__u32 handle;
+	__u32 offset;
+	__u32 words;
+	__u32 pad;
+};
+
+struct drm_tegra_reloc {
+	struct {
+		__u32 handle;
+		__u32 offset;
+	} cmdbuf;
+	struct {
+		__u32 handle;
+		__u32 offset;
+	} target;
+	__u32 shift;
+	__u32 pad;
+};
+
+struct drm_tegra_waitchk {
+	__u32 handle;
+	__u32 offset;
+	__u32 syncpt;
+	__u32 thresh;
+};
+
+struct drm_tegra_submit {
+	__u64 context;
+	__u32 num_syncpts;
+	__u32 num_cmdbufs;
+	__u32 num_relocs;
+	__u32 num_waitchks;
+	__u32 waitchk_mask;
+	__u32 timeout;
+	__u64 syncpts;
+	__u64 cmdbufs;
+	__u64 relocs;
+	__u64 waitchks;
+	__u32 fence;		/* Return value */
+
+	__u32 reserved[5];	/* future expansion */
+};
+
+#define DRM_TEGRA_GEM_TILING_MODE_PITCH 0
+#define DRM_TEGRA_GEM_TILING_MODE_TILED 1
+#define DRM_TEGRA_GEM_TILING_MODE_BLOCK 2
+
+struct drm_tegra_gem_set_tiling {
+	/* input */
+	__u32 handle;
+	__u32 mode;
+	__u32 value;
+	__u32 pad;
+};
+
+struct drm_tegra_gem_get_tiling {
+	/* input */
+	__u32 handle;
+	/* output */
+	__u32 mode;
+	__u32 value;
+	__u32 pad;
+};
+
+#define DRM_TEGRA_GEM_BOTTOM_UP		(1 << 0)
+#define DRM_TEGRA_GEM_FLAGS		(DRM_TEGRA_GEM_BOTTOM_UP)
+
+struct drm_tegra_gem_set_flags {
+	/* input */
+	__u32 handle;
+	/* output */
+	__u32 flags;
+};
+
+struct drm_tegra_gem_get_flags {
+	/* input */
+	__u32 handle;
+	/* output */
+	__u32 flags;
+};
+
+#define DRM_TEGRA_GEM_CREATE		0x00
+#define DRM_TEGRA_GEM_MMAP		0x01
+#define DRM_TEGRA_SYNCPT_READ		0x02
+#define DRM_TEGRA_SYNCPT_INCR		0x03
+#define DRM_TEGRA_SYNCPT_WAIT		0x04
+#define DRM_TEGRA_OPEN_CHANNEL		0x05
+#define DRM_TEGRA_CLOSE_CHANNEL		0x06
+#define DRM_TEGRA_GET_SYNCPT		0x07
+#define DRM_TEGRA_SUBMIT		0x08
+#define DRM_TEGRA_GET_SYNCPT_BASE	0x09
+#define DRM_TEGRA_GEM_SET_TILING	0x0a
+#define DRM_TEGRA_GEM_GET_TILING	0x0b
+#define DRM_TEGRA_GEM_SET_FLAGS		0x0c
+#define DRM_TEGRA_GEM_GET_FLAGS		0x0d
+
+#define DRM_IOCTL_TEGRA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_CREATE, struct drm_tegra_gem_create)
+#define DRM_IOCTL_TEGRA_GEM_MMAP DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_MMAP, struct drm_tegra_gem_mmap)
+#define DRM_IOCTL_TEGRA_SYNCPT_READ DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_READ, struct drm_tegra_syncpt_read)
+#define DRM_IOCTL_TEGRA_SYNCPT_INCR DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_INCR, struct drm_tegra_syncpt_incr)
+#define DRM_IOCTL_TEGRA_SYNCPT_WAIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_WAIT, struct drm_tegra_syncpt_wait)
+#define DRM_IOCTL_TEGRA_OPEN_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_OPEN_CHANNEL, struct drm_tegra_open_channel)
+#define DRM_IOCTL_TEGRA_CLOSE_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_CLOSE_CHANNEL, struct drm_tegra_open_channel)
+#define DRM_IOCTL_TEGRA_GET_SYNCPT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT, struct drm_tegra_get_syncpt)
+#define DRM_IOCTL_TEGRA_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SUBMIT, struct drm_tegra_submit)
+#define DRM_IOCTL_TEGRA_GET_SYNCPT_BASE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT_BASE, struct drm_tegra_get_syncpt_base)
+#define DRM_IOCTL_TEGRA_GEM_SET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_TILING, struct drm_tegra_gem_set_tiling)
+#define DRM_IOCTL_TEGRA_GEM_GET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_TILING, struct drm_tegra_gem_get_tiling)
+#define DRM_IOCTL_TEGRA_GEM_SET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_FLAGS, struct drm_tegra_gem_set_flags)
+#define DRM_IOCTL_TEGRA_GEM_GET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_FLAGS, struct drm_tegra_gem_get_flags)
+
+#endif
diff --git a/intel/intel_bufmgr_gem.c b/intel/intel_bufmgr_gem.c
index ee69cf8..14e92c9 100644
--- a/intel/intel_bufmgr_gem.c
+++ b/intel/intel_bufmgr_gem.c
@@ -759,15 +759,16 @@ retry:
 		bo_gem->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;
 		bo_gem->stride = 0;
 
+		/* drm_intel_gem_bo_free calls DRMLISTDEL() for an uninitialized
+		   list (vma_list), so better set the list head here */
+		DRMINITLISTHEAD(&bo_gem->name_list);
+		DRMINITLISTHEAD(&bo_gem->vma_list);
 		if (drm_intel_gem_bo_set_tiling_internal(&bo_gem->bo,
 							 tiling_mode,
 							 stride)) {
 		    drm_intel_gem_bo_free(&bo_gem->bo);
 		    return NULL;
 		}
-
-		DRMINITLISTHEAD(&bo_gem->name_list);
-		DRMINITLISTHEAD(&bo_gem->vma_list);
 	}
 
 	bo_gem->name = name;
@@ -1811,6 +1812,14 @@ do_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 	assert(offset <= bo->size - 4);
 	assert((write_domain & (write_domain - 1)) == 0);
 
+	/* An object needing a fence is a tiled buffer, so it won't have
+	 * relocs to other buffers.
+	 */
+	if (need_fence) {
+		assert(target_bo_gem->reloc_count == 0);
+		target_bo_gem->reloc_tree_fences = 1;
+	}
+
 	/* Make sure that we're not adding a reloc to something whose size has
 	 * already been accounted for.
 	 */
@@ -1818,13 +1827,8 @@ do_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 	if (target_bo_gem != bo_gem) {
 		target_bo_gem->used_as_reloc_target = true;
 		bo_gem->reloc_tree_size += target_bo_gem->reloc_tree_size;
+		bo_gem->reloc_tree_fences += target_bo_gem->reloc_tree_fences;
 	}
-	/* An object needing a fence is a tiled buffer, so it won't have
-	 * relocs to other buffers.
-	 */
-	if (need_fence)
-		target_bo_gem->reloc_tree_fences = 1;
-	bo_gem->reloc_tree_fences += target_bo_gem->reloc_tree_fences;
 
 	bo_gem->relocs[bo_gem->reloc_count].offset = offset;
 	bo_gem->relocs[bo_gem->reloc_count].delta = target_offset;
@@ -3478,6 +3482,8 @@ drm_intel_bufmgr_gem_init(int fd, int batch_size)
 		bufmgr_gem->gen = 7;
 	else if (IS_GEN8(bufmgr_gem->pci_device))
 		bufmgr_gem->gen = 8;
+	else if (IS_GEN9(bufmgr_gem->pci_device))
+		bufmgr_gem->gen = 9;
 	else {
 		free(bufmgr_gem);
 		bufmgr_gem = NULL;
diff --git a/intel/intel_chipset.h b/intel/intel_chipset.h
index 6f9bfad..e22a867 100644
--- a/intel/intel_chipset.h
+++ b/intel/intel_chipset.h
@@ -165,6 +165,22 @@
 #define PCI_CHIP_CHERRYVIEW_2		0x22b2
 #define PCI_CHIP_CHERRYVIEW_3		0x22b3
 
+#define PCI_CHIP_SKYLAKE_ULT_GT2	0x1916
+#define PCI_CHIP_SKYLAKE_ULT_GT1	0x1906
+#define PCI_CHIP_SKYLAKE_ULT_GT3	0x1926
+#define PCI_CHIP_SKYLAKE_ULT_GT2F	0x1921
+#define PCI_CHIP_SKYLAKE_ULX_GT1	0x190E
+#define PCI_CHIP_SKYLAKE_ULX_GT2	0x191E
+#define PCI_CHIP_SKYLAKE_DT_GT2		0x1912
+#define PCI_CHIP_SKYLAKE_DT_GT1		0x1902
+#define PCI_CHIP_SKYLAKE_HALO_GT2	0x191B
+#define PCI_CHIP_SKYLAKE_HALO_GT3	0x192B
+#define PCI_CHIP_SKYLAKE_HALO_GT1 	0x190B
+#define PCI_CHIP_SKYLAKE_SRV_GT2	0x191A
+#define PCI_CHIP_SKYLAKE_SRV_GT3	0x192A
+#define PCI_CHIP_SKYLAKE_SRV_GT1	0x190A
+#define PCI_CHIP_SKYLAKE_WKS_GT2 	0x191D
+
 #define IS_MOBILE(devid)	((devid) == PCI_CHIP_I855_GM || \
 				 (devid) == PCI_CHIP_I915_GM || \
 				 (devid) == PCI_CHIP_I945_GM || \
@@ -324,12 +340,37 @@
 #define IS_GEN8(devid)		(IS_BROADWELL(devid) || \
 				 IS_CHERRYVIEW(devid))
 
+#define IS_SKL_GT1(devid)	((devid) == PCI_CHIP_SKYLAKE_ULT_GT1	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_ULX_GT1	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_DT_GT1	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_HALO_GT1	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_SRV_GT1)
+
+#define IS_SKL_GT2(devid)	((devid) == PCI_CHIP_SKYLAKE_ULT_GT2	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_ULT_GT2F	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_ULX_GT2	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_DT_GT2	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_HALO_GT2	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_SRV_GT2	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_WKS_GT2)
+
+#define IS_SKL_GT3(devid)	((devid) == PCI_CHIP_SKYLAKE_ULT_GT3	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_HALO_GT3	|| \
+				 (devid) == PCI_CHIP_SKYLAKE_SRV_GT3)
+
+#define IS_SKYLAKE(devid)	(IS_SKL_GT1(devid) || \
+				 IS_SKL_GT2(devid) || \
+				 IS_SKL_GT3(devid))
+
+#define IS_GEN9(devid)		IS_SKYLAKE(devid)
+
 #define IS_9XX(dev)		(IS_GEN3(dev) || \
 				 IS_GEN4(dev) || \
 				 IS_GEN5(dev) || \
 				 IS_GEN6(dev) || \
 				 IS_GEN7(dev) || \
-				 IS_GEN8(dev))
+				 IS_GEN8(dev) || \
+				 IS_GEN9(dev))
 
 
 #endif /* _INTEL_CHIPSET_H */
diff --git a/intel/intel_decode.c b/intel/intel_decode.c
index a5d6e04..7d5cbe5 100644
--- a/intel/intel_decode.c
+++ b/intel/intel_decode.c
@@ -3829,7 +3829,9 @@ drm_intel_decode_context_alloc(uint32_t devid)
 	ctx->devid = devid;
 	ctx->out = stdout;
 
-	if (IS_GEN8(devid))
+	if (IS_GEN9(devid))
+		ctx->gen = 9;
+	else if (IS_GEN8(devid))
 		ctx->gen = 8;
 	else if (IS_GEN7(devid))
 		ctx->gen = 7;
diff --git a/radeon/radeon_surface.c b/radeon/radeon_surface.c
index 0723425..930017e 100644
--- a/radeon/radeon_surface.c
+++ b/radeon/radeon_surface.c
@@ -595,7 +595,7 @@ static void eg_surf_minify(struct radeon_surface *surf,
     mtile_ps = (mtile_pr * surflevel->nblk_y) / mtileh;
 
     surflevel->offset = offset;
-    surflevel->pitch_bytes = surflevel->nblk_x * bpe * slice_pt;
+    surflevel->pitch_bytes = surflevel->nblk_x * bpe * surf->nsamples;
     surflevel->slice_size = mtile_ps * mtileb * slice_pt;
 
     surf->bo_size = offset + surflevel->slice_size * surflevel->nblk_z * surf->array_size;
@@ -1498,7 +1498,7 @@ static void si_surf_minify_2d(struct radeon_surface *surf,
     /* macro tile per slice */
     mtile_ps = (mtile_pr * surflevel->nblk_y) / yalign;
     surflevel->offset = offset;
-    surflevel->pitch_bytes = surflevel->nblk_x * bpe * slice_pt;
+    surflevel->pitch_bytes = surflevel->nblk_x * bpe * surf->nsamples;
     surflevel->slice_size = mtile_ps * mtileb * slice_pt;
 
     surf->bo_size = offset + surflevel->slice_size * surflevel->nblk_z * surf->array_size;
diff --git a/tegra/.gitignore b/tegra/.gitignore
new file mode 100644
index 0000000..74cfe47
--- /dev/null
+++ b/tegra/.gitignore
@@ -0,0 +1 @@
+libdrm_tegra.pc
diff --git a/tegra/Makefile.am b/tegra/Makefile.am
new file mode 100644
index 0000000..a647487
--- /dev/null
+++ b/tegra/Makefile.am
@@ -0,0 +1,23 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/include/drm
+
+AM_CFLAGS = \
+	@PTHREADSTUBS_CFLAGS@ \
+	$(VISIBILITY_CFLAGS) \
+	$(WARN_CFLAGS)
+
+libdrm_tegra_ladir = $(libdir)
+libdrm_tegra_la_LTLIBRARIES = libdrm_tegra.la
+libdrm_tegra_la_LDFLAGS = -version-number 0:0:0 -no-undefined
+libdrm_tegra_la_LIBADD = ../libdrm.la @PTHREADSTUBS_LIBS@
+
+libdrm_tegra_la_SOURCES = \
+	private.h \
+	tegra.c
+
+libdrm_tegraincludedir = ${includedir}/libdrm
+libdrm_tegrainclude_HEADERS = tegra.h
+
+pkgconfigdir = @pkgconfigdir@
+pkgconfig_DATA = libdrm_tegra.pc
diff --git a/tegra/libdrm_tegra.pc.in b/tegra/libdrm_tegra.pc.in
new file mode 100644
index 0000000..2e06f49
--- /dev/null
+++ b/tegra/libdrm_tegra.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdrm_tegra
+Description: Userspace interface to Tegra kernel DRM services
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -ldrm_tegra
+Cflags: -I${includedir} -I${includedir}/libdrm
+Requires.private: libdrm
diff --git a/tegra/private.h b/tegra/private.h
new file mode 100644
index 0000000..9b6bc93
--- /dev/null
+++ b/tegra/private.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright © 2012, 2013 Thierry Reding
+ * Copyright © 2013 Erik Faye-Lund
+ * Copyright © 2014 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __DRM_TEGRA_PRIVATE_H__
+#define __DRM_TEGRA_PRIVATE_H__ 1
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <libdrm.h>
+#include <xf86atomic.h>
+
+#include "tegra.h"
+
+struct drm_tegra {
+	bool close;
+	int fd;
+};
+
+struct drm_tegra_bo {
+	struct drm_tegra *drm;
+	uint32_t handle;
+	uint32_t offset;
+	uint32_t flags;
+	uint32_t size;
+	atomic_t ref;
+	void *map;
+};
+
+#endif /* __DRM_TEGRA_PRIVATE_H__ */
diff --git a/tegra/tegra.c b/tegra/tegra.c
new file mode 100644
index 0000000..f8d4078
--- /dev/null
+++ b/tegra/tegra.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright © 2012, 2013 Thierry Reding
+ * Copyright © 2013 Erik Faye-Lund
+ * Copyright © 2014 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/mman.h>
+
+#include <xf86drm.h>
+
+#include <tegra_drm.h>
+
+#include "private.h"
+
+static void drm_tegra_bo_free(struct drm_tegra_bo *bo)
+{
+	struct drm_tegra *drm = bo->drm;
+	struct drm_gem_close args;
+
+	if (bo->map)
+		munmap(bo->map, bo->size);
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->handle;
+
+	drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &args);
+
+	free(bo);
+}
+
+static int drm_tegra_wrap(struct drm_tegra **drmp, int fd, bool close)
+{
+	struct drm_tegra *drm;
+
+	if (fd < 0 || !drmp)
+		return -EINVAL;
+
+	drm = calloc(1, sizeof(*drm));
+	if (!drm)
+		return -ENOMEM;
+
+	drm->close = close;
+	drm->fd = fd;
+
+	*drmp = drm;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_new(struct drm_tegra **drmp, int fd)
+{
+	bool supported = false;
+	drmVersionPtr version;
+
+	version = drmGetVersion(fd);
+	if (!version)
+		return -ENOMEM;
+
+	if (!strncmp(version->name, "tegra", version->name_len))
+		supported = true;
+
+	drmFreeVersion(version);
+
+	if (!supported)
+		return -ENOTSUP;
+
+	return drm_tegra_wrap(drmp, fd, false);
+}
+
+drm_public
+void drm_tegra_close(struct drm_tegra *drm)
+{
+	if (!drm)
+		return;
+
+	if (drm->close)
+		close(drm->fd);
+
+	free(drm);
+}
+
+drm_public
+int drm_tegra_bo_new(struct drm_tegra_bo **bop, struct drm_tegra *drm,
+		     uint32_t flags, uint32_t size)
+{
+	struct drm_tegra_gem_create args;
+	struct drm_tegra_bo *bo;
+	int err;
+
+	if (!drm || size == 0 || !bop)
+		return -EINVAL;
+
+	bo = calloc(1, sizeof(*bo));
+	if (!bo)
+		return -ENOMEM;
+
+	atomic_set(&bo->ref, 1);
+	bo->flags = flags;
+	bo->size = size;
+	bo->drm = drm;
+
+	memset(&args, 0, sizeof(args));
+	args.flags = flags;
+	args.size = size;
+
+	err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_CREATE, &args,
+				  sizeof(args));
+	if (err < 0) {
+		err = -errno;
+		free(bo);
+		return err;
+	}
+
+	bo->handle = args.handle;
+
+	*bop = bo;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_wrap(struct drm_tegra_bo **bop, struct drm_tegra *drm,
+		      uint32_t handle, uint32_t flags, uint32_t size)
+{
+	struct drm_tegra_bo *bo;
+
+	if (!drm || !bop)
+		return -EINVAL;
+
+	bo = calloc(1, sizeof(*bo));
+	if (!bo)
+		return -ENOMEM;
+
+	atomic_set(&bo->ref, 1);
+	bo->handle = handle;
+	bo->flags = flags;
+	bo->size = size;
+	bo->drm = drm;
+
+	*bop = bo;
+
+	return 0;
+}
+
+drm_public
+struct drm_tegra_bo *drm_tegra_bo_ref(struct drm_tegra_bo *bo)
+{
+	if (bo)
+		atomic_inc(&bo->ref);
+
+	return bo;
+}
+
+drm_public
+void drm_tegra_bo_unref(struct drm_tegra_bo *bo)
+{
+	if (bo && atomic_dec_and_test(&bo->ref))
+		drm_tegra_bo_free(bo);
+}
+
+drm_public
+int drm_tegra_bo_get_handle(struct drm_tegra_bo *bo, uint32_t *handle)
+{
+	if (!bo || !handle)
+		return -EINVAL;
+
+	*handle = bo->handle;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_map(struct drm_tegra_bo *bo, void **ptr)
+{
+	struct drm_tegra *drm = bo->drm;
+
+	if (!bo->map) {
+		struct drm_tegra_gem_mmap args;
+		int err;
+
+		memset(&args, 0, sizeof(args));
+		args.handle = bo->handle;
+
+		err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_MMAP, &args,
+					  sizeof(args));
+		if (err < 0)
+			return -errno;
+
+		bo->offset = args.offset;
+
+		bo->map = mmap(0, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+			       drm->fd, bo->offset);
+		if (bo->map == MAP_FAILED) {
+			bo->map = NULL;
+			return -errno;
+		}
+	}
+
+	if (ptr)
+		*ptr = bo->map;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_unmap(struct drm_tegra_bo *bo)
+{
+	if (!bo)
+		return -EINVAL;
+
+	if (!bo->map)
+		return 0;
+
+	if (munmap(bo->map, bo->size))
+		return -errno;
+
+	bo->map = NULL;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_get_flags(struct drm_tegra_bo *bo, uint32_t *flags)
+{
+	struct drm_tegra_gem_get_flags args;
+	struct drm_tegra *drm = bo->drm;
+	int err;
+
+	if (!bo)
+		return -EINVAL;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->handle;
+
+	err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_GET_FLAGS, &args,
+				  sizeof(args));
+	if (err < 0)
+		return -errno;
+
+	if (flags)
+		*flags = args.flags;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_set_flags(struct drm_tegra_bo *bo, uint32_t flags)
+{
+	struct drm_tegra_gem_get_flags args;
+	struct drm_tegra *drm = bo->drm;
+	int err;
+
+	if (!bo)
+		return -EINVAL;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->handle;
+	args.flags = flags;
+
+	err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_SET_FLAGS, &args,
+				  sizeof(args));
+	if (err < 0)
+		return -errno;
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_get_tiling(struct drm_tegra_bo *bo,
+			    struct drm_tegra_bo_tiling *tiling)
+{
+	struct drm_tegra_gem_get_tiling args;
+	struct drm_tegra *drm = bo->drm;
+	int err;
+
+	if (!bo)
+		return -EINVAL;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->handle;
+
+	err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_GET_TILING, &args,
+				  sizeof(args));
+	if (err < 0)
+		return -errno;
+
+	if (tiling) {
+		tiling->mode = args.mode;
+		tiling->value = args.value;
+	}
+
+	return 0;
+}
+
+drm_public
+int drm_tegra_bo_set_tiling(struct drm_tegra_bo *bo,
+			    const struct drm_tegra_bo_tiling *tiling)
+{
+	struct drm_tegra_gem_set_tiling args;
+	struct drm_tegra *drm = bo->drm;
+	int err;
+
+	if (!bo)
+		return -EINVAL;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->handle;
+	args.mode = tiling->mode;
+	args.value = tiling->value;
+
+	err = drmCommandWriteRead(drm->fd, DRM_TEGRA_GEM_SET_TILING, &args,
+				  sizeof(args));
+	if (err < 0)
+		return -errno;
+
+	return 0;
+}
diff --git a/tegra/tegra.h b/tegra/tegra.h
new file mode 100644
index 0000000..31b0995
--- /dev/null
+++ b/tegra/tegra.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright © 2012, 2013 Thierry Reding
+ * Copyright © 2013 Erik Faye-Lund
+ * Copyright © 2014 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __DRM_TEGRA_H__
+#define __DRM_TEGRA_H__ 1
+
+#include <stdint.h>
+#include <stdlib.h>
+
+struct drm_tegra_bo;
+struct drm_tegra;
+
+int drm_tegra_new(struct drm_tegra **drmp, int fd);
+void drm_tegra_close(struct drm_tegra *drm);
+
+int drm_tegra_bo_new(struct drm_tegra_bo **bop, struct drm_tegra *drm,
+		     uint32_t flags, uint32_t size);
+int drm_tegra_bo_wrap(struct drm_tegra_bo **bop, struct drm_tegra *drm,
+		      uint32_t handle, uint32_t flags, uint32_t size);
+struct drm_tegra_bo *drm_tegra_bo_ref(struct drm_tegra_bo *bo);
+void drm_tegra_bo_unref(struct drm_tegra_bo *bo);
+int drm_tegra_bo_get_handle(struct drm_tegra_bo *bo, uint32_t *handle);
+int drm_tegra_bo_map(struct drm_tegra_bo *bo, void **ptr);
+int drm_tegra_bo_unmap(struct drm_tegra_bo *bo);
+
+int drm_tegra_bo_get_flags(struct drm_tegra_bo *bo, uint32_t *flags);
+int drm_tegra_bo_set_flags(struct drm_tegra_bo *bo, uint32_t flags);
+
+struct drm_tegra_bo_tiling {
+	uint32_t mode;
+	uint32_t value;
+};
+
+int drm_tegra_bo_get_tiling(struct drm_tegra_bo *bo,
+			    struct drm_tegra_bo_tiling *tiling);
+int drm_tegra_bo_set_tiling(struct drm_tegra_bo *bo,
+			    const struct drm_tegra_bo_tiling *tiling);
+
+#endif /* __DRM_TEGRA_H__ */
diff --git a/tests/Makefile.am b/tests/Makefile.am
index cd11491..e7ec4fa 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -10,7 +10,7 @@ check_PROGRAMS = \
 	dristat \
 	drmstat
 
-SUBDIRS = modeprint
+SUBDIRS = modeprint proptest
 
 if HAVE_LIBKMS
 SUBDIRS += kmstest modetest
@@ -24,6 +24,10 @@ if HAVE_EXYNOS
 SUBDIRS += exynos
 endif
 
+if HAVE_TEGRA
+SUBDIRS += tegra
+endif
+
 if HAVE_LIBUDEV
 
 check_LTLIBRARIES = libdrmtest.la
diff --git a/tests/modetest/Android.mk b/tests/modetest/Android.mk
index 0a32b5f..aee3564 100644
--- a/tests/modetest/Android.mk
+++ b/tests/modetest/Android.mk
@@ -9,6 +9,6 @@ LOCAL_MODULE := modetest
 
 LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/libdrm
 
-LOCAL_SHARED_LIBRARIES := libdrm libkms
+LOCAL_SHARED_LIBRARIES := libdrm
 
 include $(BUILD_EXECUTABLE)
diff --git a/tests/modetest/Makefile.am b/tests/modetest/Makefile.am
index 0a6af01..93820fa 100644
--- a/tests/modetest/Makefile.am
+++ b/tests/modetest/Makefile.am
@@ -4,7 +4,6 @@ AM_CFLAGS = $(filter-out -Wpointer-arith, $(WARN_CFLAGS))
 
 AM_CFLAGS += \
 	-I$(top_srcdir)/include/drm \
-	-I$(top_srcdir)/libkms/ \
 	-I$(top_srcdir)
 
 if HAVE_INSTALL_TESTS
@@ -19,7 +18,7 @@ modetest_SOURCES = $(MODETEST_FILES)
 
 modetest_LDADD = \
 	$(top_builddir)/libdrm.la \
-	$(top_builddir)/libkms/libkms.la
+	-lpthread
 
 if HAVE_CAIRO
 AM_CFLAGS += $(CAIRO_CFLAGS)
diff --git a/tests/modetest/buffers.c b/tests/modetest/buffers.c
index 29b520d..e4e8149 100644
--- a/tests/modetest/buffers.c
+++ b/tests/modetest/buffers.c
@@ -34,9 +34,13 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <string.h>
+#include <sys/ioctl.h>
 
+#include "drm.h"
 #include "drm_fourcc.h"
-#include "libkms.h"
+
+#include "libdrm.h"
+#include "xf86drm.h"
 
 #include "buffers.h"
 
@@ -47,6 +51,16 @@
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
+struct bo
+{
+	int fd;
+	void *ptr;
+	size_t size;
+	size_t offset;
+	size_t pitch;
+	unsigned handle;
+};
+
 /* -----------------------------------------------------------------------------
  * Formats
  */
@@ -854,10 +868,11 @@ fill_tiles_rgb32(const struct format_info *info, unsigned char *mem,
 			div_t d = div(x+y, width);
 			uint32_t rgb32 = 0x00130502 * (d.quot >> 6)
 				       + 0x000a1120 * (d.rem >> 6);
+			uint32_t alpha = ((y < height/2) && (x < width/2)) ? 127 : 255;
 			uint32_t color =
 				MAKE_RGBA(rgb, (rgb32 >> 16) & 0xff,
 					  (rgb32 >> 8) & 0xff, rgb32 & 0xff,
-					  255);
+					  alpha);
 
 			((uint32_t *)mem)[x] = color;
 		}
@@ -1000,48 +1015,82 @@ fill_pattern(unsigned int format, enum fill_pattern pattern, void *planes[3],
  * Buffers management
  */
 
-static struct kms_bo *
-allocate_buffer(struct kms_driver *kms, unsigned int width, unsigned int height,
-		unsigned int *stride)
+static struct bo *
+bo_create_dumb(int fd, unsigned int width, unsigned int height, unsigned int bpp)
 {
-	struct kms_bo *bo;
-	unsigned bo_attribs[] = {
-		KMS_WIDTH,   0,
-		KMS_HEIGHT,  0,
-		KMS_BO_TYPE, KMS_BO_TYPE_SCANOUT_X8R8G8B8,
-		KMS_TERMINATE_PROP_LIST
-	};
+	struct drm_mode_create_dumb arg;
+	struct bo *bo;
 	int ret;
 
-	bo_attribs[1] = width;
-	bo_attribs[3] = height;
-
-	ret = kms_bo_create(kms, bo_attribs, &bo);
-	if (ret) {
-		fprintf(stderr, "failed to alloc buffer: %s\n",
-			strerror(-ret));
+	bo = malloc(sizeof(*bo));
+	if (bo == NULL) {
+		fprintf(stderr, "failed to allocate buffer object\n");
 		return NULL;
 	}
 
-	ret = kms_bo_get_prop(bo, KMS_PITCH, stride);
+	memset(&arg, 0, sizeof(arg));
+	arg.bpp = bpp;
+	arg.width = width;
+	arg.height = height;
+
+	ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &arg);
 	if (ret) {
-		fprintf(stderr, "failed to retreive buffer stride: %s\n",
-			strerror(-ret));
-		kms_bo_destroy(&bo);
+		fprintf(stderr, "failed to create dumb buffer: %s\n",
+			strerror(errno));
+		free(bo);
 		return NULL;
 	}
 
+	bo->fd = fd;
+	bo->handle = arg.handle;
+	bo->size = arg.size;
+	bo->pitch = arg.pitch;
+
 	return bo;
 }
 
-struct kms_bo *
-create_test_buffer(struct kms_driver *kms, unsigned int format,
-		   unsigned int width, unsigned int height,
-		   unsigned int handles[4], unsigned int pitches[4],
-		   unsigned int offsets[4], enum fill_pattern pattern)
+static int bo_map(struct bo *bo, void **out)
+{
+	struct drm_mode_map_dumb arg;
+	void *map;
+	int ret;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.handle = bo->handle;
+
+	ret = drmIoctl(bo->fd, DRM_IOCTL_MODE_MAP_DUMB, &arg);
+	if (ret)
+		return ret;
+
+	map = drm_mmap(0, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+		       bo->fd, arg.offset);
+	if (map == MAP_FAILED)
+		return -EINVAL;
+
+	bo->ptr = map;
+	*out = map;
+
+	return 0;
+}
+
+static void bo_unmap(struct bo *bo)
+{
+	if (!bo->ptr)
+		return;
+
+	drm_munmap(bo->ptr, bo->size);
+	bo->ptr = NULL;
+}
+
+struct bo *
+bo_create(int fd, unsigned int format,
+	  unsigned int width, unsigned int height,
+	  unsigned int handles[4], unsigned int pitches[4],
+	  unsigned int offsets[4], enum fill_pattern pattern)
 {
 	unsigned int virtual_height;
-	struct kms_bo *bo;
+	struct bo *bo;
+	unsigned int bpp;
 	void *planes[3] = { 0, };
 	void *virtual;
 	int ret;
@@ -1049,6 +1098,70 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 	switch (format) {
 	case DRM_FORMAT_NV12:
 	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+		bpp = 8;
+		break;
+
+	case DRM_FORMAT_ARGB4444:
+	case DRM_FORMAT_XRGB4444:
+	case DRM_FORMAT_ABGR4444:
+	case DRM_FORMAT_XBGR4444:
+	case DRM_FORMAT_RGBA4444:
+	case DRM_FORMAT_RGBX4444:
+	case DRM_FORMAT_BGRA4444:
+	case DRM_FORMAT_BGRX4444:
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_XRGB1555:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_XBGR1555:
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_RGBX5551:
+	case DRM_FORMAT_BGRA5551:
+	case DRM_FORMAT_BGRX5551:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_VYUY:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_YVYU:
+		bpp = 16;
+		break;
+
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_RGB888:
+		bpp = 24;
+		break;
+
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_ARGB2101010:
+	case DRM_FORMAT_XRGB2101010:
+	case DRM_FORMAT_ABGR2101010:
+	case DRM_FORMAT_XBGR2101010:
+	case DRM_FORMAT_RGBA1010102:
+	case DRM_FORMAT_RGBX1010102:
+	case DRM_FORMAT_BGRA1010102:
+	case DRM_FORMAT_BGRX1010102:
+		bpp = 32;
+		break;
+
+	default:
+		fprintf(stderr, "unsupported format 0x%08x\n",  format);
+		return NULL;
+	}
+
+	switch (format) {
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV21:
 		virtual_height = height * 3 / 2;
 		break;
 
@@ -1062,15 +1175,15 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 		break;
 	}
 
-	bo = allocate_buffer(kms, width, virtual_height, &pitches[0]);
+	bo = bo_create_dumb(fd, width, virtual_height, bpp);
 	if (!bo)
 		return NULL;
 
-	ret = kms_bo_map(bo, &virtual);
+	ret = bo_map(bo, &virtual);
 	if (ret) {
 		fprintf(stderr, "failed to map buffer: %s\n",
-			strerror(-ret));
-		kms_bo_destroy(&bo);
+			strerror(-errno));
+		bo_destroy(bo);
 		return NULL;
 	}
 
@@ -1083,8 +1196,8 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_YVYU:
 		offsets[0] = 0;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[0]);
-		kms_bo_get_prop(bo, KMS_PITCH, &pitches[0]);
+		handles[0] = bo->handle;
+		pitches[0] = bo->pitch;
 
 		planes[0] = virtual;
 		break;
@@ -1094,11 +1207,11 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 	case DRM_FORMAT_NV16:
 	case DRM_FORMAT_NV61:
 		offsets[0] = 0;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[0]);
-		kms_bo_get_prop(bo, KMS_PITCH, &pitches[0]);
+		handles[0] = bo->handle;
+		pitches[0] = bo->pitch;
 		pitches[1] = pitches[0];
 		offsets[1] = pitches[0] * height;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[1]);
+		handles[1] = bo->handle;
 
 		planes[0] = virtual;
 		planes[1] = virtual + offsets[1];
@@ -1107,14 +1220,14 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 	case DRM_FORMAT_YUV420:
 	case DRM_FORMAT_YVU420:
 		offsets[0] = 0;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[0]);
-		kms_bo_get_prop(bo, KMS_PITCH, &pitches[0]);
+		handles[0] = bo->handle;
+		pitches[0] = bo->pitch;
 		pitches[1] = pitches[0] / 2;
 		offsets[1] = pitches[0] * height;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[1]);
+		handles[1] = bo->handle;
 		pitches[2] = pitches[1];
 		offsets[2] = offsets[1] + pitches[1] * height / 2;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[2]);
+		handles[2] = bo->handle;
 
 		planes[0] = virtual;
 		planes[1] = virtual + offsets[1];
@@ -1158,15 +1271,31 @@ create_test_buffer(struct kms_driver *kms, unsigned int format,
 	case DRM_FORMAT_BGRA1010102:
 	case DRM_FORMAT_BGRX1010102:
 		offsets[0] = 0;
-		kms_bo_get_prop(bo, KMS_HANDLE, &handles[0]);
-		kms_bo_get_prop(bo, KMS_PITCH, &pitches[0]);
+		handles[0] = bo->handle;
+		pitches[0] = bo->pitch;
 
 		planes[0] = virtual;
 		break;
 	}
 
 	fill_pattern(format, pattern, planes, width, height, pitches[0]);
-	kms_bo_unmap(bo);
+	bo_unmap(bo);
 
 	return bo;
 }
+
+void bo_destroy(struct bo *bo)
+{
+	struct drm_mode_destroy_dumb arg;
+	int ret;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.handle = bo->handle;
+
+	ret = drmIoctl(bo->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
+	if (ret)
+		fprintf(stderr, "failed to destroy dumb buffer: %s\n",
+			strerror(errno));
+
+	free(bo);
+}
diff --git a/tests/modetest/buffers.h b/tests/modetest/buffers.h
index e320389..ad73d0e 100644
--- a/tests/modetest/buffers.h
+++ b/tests/modetest/buffers.h
@@ -27,8 +27,7 @@
 #ifndef __BUFFERS_H__
 #define __BUFFERS_H__
 
-struct kms_bo;
-struct kms_driver;
+struct bo;
 
 enum fill_pattern {
 	PATTERN_TILES = 0,
@@ -36,10 +35,11 @@ enum fill_pattern {
 	PATTERN_SMPTE = 2,
 };
 
-struct kms_bo *create_test_buffer(struct kms_driver *kms, unsigned int format,
+struct bo *bo_create(int fd, unsigned int format,
 		   unsigned int width, unsigned int height,
 		   unsigned int handles[4], unsigned int pitches[4],
 		   unsigned int offsets[4], enum fill_pattern pattern);
+void bo_destroy(struct bo *bo);
 
 unsigned int format_fourcc(const char *name);
 
diff --git a/tests/modetest/cursor.c b/tests/modetest/cursor.c
index 60f240a..62a50ef 100644
--- a/tests/modetest/cursor.c
+++ b/tests/modetest/cursor.c
@@ -34,6 +34,8 @@
 #include <string.h>
 #include <signal.h>
 #include <sys/time.h>
+#include <pthread.h>
+#include <unistd.h>
 
 #include "xf86drm.h"
 #include "xf86drmMode.h"
@@ -59,6 +61,9 @@ struct cursor {
 static struct cursor cursors[MAX_CURSORS];
 static int ncursors;
 
+static pthread_t cursor_thread;
+static int cursor_running;
+
 /*
  * Timer driven program loops through these steps to move/enable/disable
  * the cursor
@@ -137,33 +142,29 @@ static struct cursor_step steps[] = {
 		{  set_cursor, 10,   0,  0 },  /* disable */
 };
 
-/*
- * Cursor API:
- */
-
-static void run_step(int sig)
+static void *cursor_thread_func(void *data)
 {
-	struct cursor_step *step = &steps[indx % ARRAY_SIZE(steps)];
-	struct itimerval itimer = {
-			.it_value.tv_usec = 1000 * step->msec,
-	};
-	int i;
-
-	for (i = 0; i < ncursors; i++) {
-		struct cursor *cursor = &cursors[i];
-		step->run(cursor, step);
-	}
-
-	/* iterate to next count/step: */
-	if (count < step->repeat) {
-		count++;
-	} else {
-		count = 0;
-		indx++;
+	while (cursor_running) {
+		struct cursor_step *step = &steps[indx % ARRAY_SIZE(steps)];
+		int i;
+
+		for (i = 0; i < ncursors; i++) {
+			struct cursor *cursor = &cursors[i];
+			step->run(cursor, step);
+		}
+
+		/* iterate to next count/step: */
+		if (count < step->repeat) {
+			count++;
+		} else {
+			count = 0;
+			indx++;
+		}
+
+		usleep(1000 * step->msec);
 	}
 
-	/* and lastly, setup timer for next step */
-	setitimer(ITIMER_REAL, &itimer, NULL);
+	return NULL;
 }
 
 int cursor_init(int fd, uint32_t bo_handle, uint32_t crtc_id,
@@ -194,16 +195,16 @@ int cursor_init(int fd, uint32_t bo_handle, uint32_t crtc_id,
 
 int cursor_start(void)
 {
-	/* setup signal handler to update cursor: */
-	signal(SIGALRM, run_step);
+	cursor_running = 1;
+	pthread_create(&cursor_thread, NULL, cursor_thread_func, NULL);
 	printf("starting cursor\n");
-	run_step(SIGALRM);
 	return 0;
 }
 
 int cursor_stop(void)
 {
-	signal(SIGALRM, NULL);
+	cursor_running = 0;
+	pthread_join(cursor_thread, NULL);
 	printf("cursor stopped\n");
 	return 0;
 }
diff --git a/tests/modetest/modetest.c b/tests/modetest/modetest.c
index 6d06e3f..4b9cf2f 100644
--- a/tests/modetest/modetest.c
+++ b/tests/modetest/modetest.c
@@ -57,7 +57,6 @@
 #include "xf86drm.h"
 #include "xf86drmMode.h"
 #include "drm_fourcc.h"
-#include "libkms.h"
 
 #include "buffers.h"
 #include "cursor.h"
@@ -104,18 +103,21 @@ struct device {
 	int fd;
 
 	struct resources *resources;
-	struct kms_driver *kms;
 
 	struct {
 		unsigned int width;
 		unsigned int height;
 
 		unsigned int fb_id;
-		struct kms_bo *bo;
+		struct bo *bo;
 	} mode;
 };
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+static inline int64_t U642I64(uint64_t val)
+{
+	return (int64_t)*((int64_t *)&val);
+}
 
 struct type_name {
 	int type;
@@ -264,8 +266,10 @@ static void dump_blob(struct device *dev, uint32_t blob_id)
 	drmModePropertyBlobPtr blob;
 
 	blob = drmModeGetPropertyBlob(dev->fd, blob_id);
-	if (!blob)
+	if (!blob) {
+		printf("\n");
 		return;
+	}
 
 	blob_data = blob->data;
 
@@ -294,32 +298,43 @@ static void dump_prop(struct device *dev, drmModePropertyPtr prop,
 	printf("\t\tflags:");
 	if (prop->flags & DRM_MODE_PROP_PENDING)
 		printf(" pending");
-	if (prop->flags & DRM_MODE_PROP_RANGE)
-		printf(" range");
 	if (prop->flags & DRM_MODE_PROP_IMMUTABLE)
 		printf(" immutable");
-	if (prop->flags & DRM_MODE_PROP_ENUM)
+	if (drm_property_type_is(prop, DRM_MODE_PROP_SIGNED_RANGE))
+		printf(" signed range");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_RANGE))
+		printf(" range");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_ENUM))
 		printf(" enum");
-	if (prop->flags & DRM_MODE_PROP_BITMASK)
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BITMASK))
 		printf(" bitmask");
-	if (prop->flags & DRM_MODE_PROP_BLOB)
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB))
 		printf(" blob");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_OBJECT))
+		printf(" object");
 	printf("\n");
 
-	if (prop->flags & DRM_MODE_PROP_RANGE) {
+	if (drm_property_type_is(prop, DRM_MODE_PROP_SIGNED_RANGE)) {
+		printf("\t\tvalues:");
+		for (i = 0; i < prop->count_values; i++)
+			printf(" %"PRId64, U642I64(prop->values[i]));
+		printf("\n");
+	}
+
+	if (drm_property_type_is(prop, DRM_MODE_PROP_RANGE)) {
 		printf("\t\tvalues:");
 		for (i = 0; i < prop->count_values; i++)
 			printf(" %"PRIu64, prop->values[i]);
 		printf("\n");
 	}
 
-	if (prop->flags & DRM_MODE_PROP_ENUM) {
+	if (drm_property_type_is(prop, DRM_MODE_PROP_ENUM)) {
 		printf("\t\tenums:");
 		for (i = 0; i < prop->count_enums; i++)
 			printf(" %s=%llu", prop->enums[i].name,
 			       prop->enums[i].value);
 		printf("\n");
-	} else if (prop->flags & DRM_MODE_PROP_BITMASK) {
+	} else if (drm_property_type_is(prop, DRM_MODE_PROP_BITMASK)) {
 		printf("\t\tvalues:");
 		for (i = 0; i < prop->count_enums; i++)
 			printf(" %s=0x%llx", prop->enums[i].name,
@@ -329,7 +344,7 @@ static void dump_prop(struct device *dev, drmModePropertyPtr prop,
 		assert(prop->count_enums == 0);
 	}
 
-	if (prop->flags & DRM_MODE_PROP_BLOB) {
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB)) {
 		printf("\t\tblobs:\n");
 		for (i = 0; i < prop->count_blobs; i++)
 			dump_blob(dev, prop->blob_ids[i]);
@@ -339,7 +354,7 @@ static void dump_prop(struct device *dev, drmModePropertyPtr prop,
 	}
 
 	printf("\t\tvalue:");
-	if (prop->flags & DRM_MODE_PROP_BLOB)
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB))
 		dump_blob(dev, value);
 	else
 		printf(" %"PRIu64"\n", value);
@@ -545,6 +560,8 @@ static struct resources *get_resources(struct device *dev)
 
 	memset(res, 0, sizeof *res);
 
+	drmSetClientCap(dev->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+
 	res->res = drmModeGetResources(dev->fd);
 	if (!res->res) {
 		fprintf(stderr, "drmModeGetResources failed: %s\n",
@@ -949,7 +966,7 @@ static int set_plane(struct device *dev, struct plane_arg *p)
 	drmModePlane *ovr;
 	uint32_t handles[4], pitches[4], offsets[4] = {0}; /* we only use [0] */
 	uint32_t plane_id = 0;
-	struct kms_bo *plane_bo;
+	struct bo *plane_bo;
 	uint32_t plane_flags = 0;
 	int crtc_x, crtc_y, crtc_w, crtc_h;
 	struct crtc *crtc = NULL;
@@ -990,8 +1007,8 @@ static int set_plane(struct device *dev, struct plane_arg *p)
 	fprintf(stderr, "testing %dx%d@%s overlay plane %u\n",
 		p->w, p->h, p->format_str, plane_id);
 
-	plane_bo = create_test_buffer(dev->kms, p->fourcc, p->w, p->h, handles,
-				      pitches, offsets, PATTERN_TILES);
+	plane_bo = bo_create(dev->fd, p->fourcc, p->w, p->h, handles,
+			     pitches, offsets, PATTERN_TILES);
 	if (plane_bo == NULL)
 		return -1;
 
@@ -1031,7 +1048,7 @@ static void set_mode(struct device *dev, struct pipe_arg *pipes, unsigned int co
 {
 	uint32_t handles[4], pitches[4], offsets[4] = {0}; /* we only use [0] */
 	unsigned int fb_id;
-	struct kms_bo *bo;
+	struct bo *bo;
 	unsigned int i;
 	unsigned int j;
 	int ret, x;
@@ -1051,9 +1068,8 @@ static void set_mode(struct device *dev, struct pipe_arg *pipes, unsigned int co
 			dev->mode.height = pipe->mode->vdisplay;
 	}
 
-	bo = create_test_buffer(dev->kms, pipes[0].fourcc,
-				dev->mode.width, dev->mode.height,
-				handles, pitches, offsets, PATTERN_SMPTE);
+	bo = bo_create(dev->fd, pipes[0].fourcc, dev->mode.width, dev->mode.height,
+		       handles, pitches, offsets, PATTERN_SMPTE);
 	if (bo == NULL)
 		return;
 
@@ -1110,7 +1126,7 @@ static void set_planes(struct device *dev, struct plane_arg *p, unsigned int cou
 static void set_cursors(struct device *dev, struct pipe_arg *pipes, unsigned int count)
 {
 	uint32_t handles[4], pitches[4], offsets[4] = {0}; /* we only use [0] */
-	struct kms_bo *bo;
+	struct bo *bo;
 	unsigned int i;
 	int ret;
 
@@ -1121,8 +1137,8 @@ static void set_cursors(struct device *dev, struct pipe_arg *pipes, unsigned int
 	/* create cursor bo.. just using PATTERN_PLAIN as it has
 	 * translucent alpha
 	 */
-	bo = create_test_buffer(dev->kms, DRM_FORMAT_ARGB8888,
-			cw, ch, handles, pitches, offsets, PATTERN_PLAIN);
+	bo = bo_create(dev->fd, DRM_FORMAT_ARGB8888, cw, ch, handles, pitches,
+		       offsets, PATTERN_PLAIN);
 	if (bo == NULL)
 		return;
 
@@ -1151,14 +1167,14 @@ static void test_page_flip(struct device *dev, struct pipe_arg *pipes, unsigned
 {
 	uint32_t handles[4], pitches[4], offsets[4] = {0}; /* we only use [0] */
 	unsigned int other_fb_id;
-	struct kms_bo *other_bo;
+	struct bo *other_bo;
 	drmEventContext evctx;
 	unsigned int i;
 	int ret;
 
-	other_bo = create_test_buffer(dev->kms, pipes[0].fourcc,
-				      dev->mode.width, dev->mode.height,
-				      handles, pitches, offsets, PATTERN_PLAIN);
+	other_bo = bo_create(dev->fd, pipes[0].fourcc,
+			     dev->mode.width, dev->mode.height,
+			     handles, pitches, offsets, PATTERN_PLAIN);
 	if (other_bo == NULL)
 		return;
 
@@ -1233,7 +1249,7 @@ static void test_page_flip(struct device *dev, struct pipe_arg *pipes, unsigned
 		drmHandleEvent(dev->fd, &evctx);
 	}
 
-	kms_bo_destroy(&other_bo);
+	bo_destroy(other_bo);
 }
 
 #define min(a, b)	((a) < (b) ? (a) : (b))
@@ -1437,7 +1453,7 @@ int main(int argc, char **argv)
 	int drop_master = 0;
 	int test_vsync = 0;
 	int test_cursor = 0;
-	const char *modules[] = { "i915", "radeon", "nouveau", "vmwgfx", "omapdrm", "exynos", "tilcdc", "msm", "sti" };
+	const char *modules[] = { "i915", "radeon", "nouveau", "vmwgfx", "omapdrm", "exynos", "tilcdc", "msm", "sti", "tegra" };
 	char *device = NULL;
 	char *module = NULL;
 	unsigned int i;
@@ -1592,10 +1608,11 @@ int main(int argc, char **argv)
 		set_property(&dev, &prop_args[i]);
 
 	if (count || plane_count) {
-		ret = kms_create(dev.fd, &dev.kms);
-		if (ret) {
-			fprintf(stderr, "failed to create kms driver: %s\n",
-				strerror(-ret));
+		uint64_t cap = 0;
+
+		ret = drmGetCap(dev.fd, DRM_CAP_DUMB_BUFFER, &cap);
+		if (ret || cap == 0) {
+			fprintf(stderr, "driver doesn't support the dumb buffer API\n");
 			return 1;
 		}
 
@@ -1619,8 +1636,7 @@ int main(int argc, char **argv)
 		if (test_cursor)
 			clear_cursors(&dev);
 
-		kms_bo_destroy(&dev.mode.bo);
-		kms_destroy(&dev.kms);
+		bo_destroy(dev.mode.bo);
 	}
 
 	free_resources(dev.resources);
diff --git a/tests/proptest/Makefile.am b/tests/proptest/Makefile.am
new file mode 100644
index 0000000..f81a3c0
--- /dev/null
+++ b/tests/proptest/Makefile.am
@@ -0,0 +1,11 @@
+AM_CFLAGS = \
+	-I$(top_srcdir)/include/drm \
+	-I$(top_srcdir)
+
+noinst_PROGRAMS = \
+	proptest
+
+proptest_SOURCES = \
+	proptest.c
+proptest_LDADD = \
+	$(top_builddir)/libdrm.la
diff --git a/tests/proptest/proptest.c b/tests/proptest/proptest.c
new file mode 100644
index 0000000..7618f63
--- /dev/null
+++ b/tests/proptest/proptest.c
@@ -0,0 +1,343 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Paulo Zanoni <paulo.r.zanoni@intel.com>
+ *
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "xf86drm.h"
+#include "xf86drmMode.h"
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+static inline int64_t U642I64(uint64_t val)
+{
+	return (int64_t)*((int64_t *)&val);
+}
+
+int fd;
+drmModeResPtr res = NULL;
+
+const char *connector_type_str(uint32_t type)
+{
+	switch (type) {
+	case DRM_MODE_CONNECTOR_Unknown:
+		return "Unknown";
+	case DRM_MODE_CONNECTOR_VGA:
+		return "VGA";
+	case DRM_MODE_CONNECTOR_DVII:
+		return "DVI-I";
+	case DRM_MODE_CONNECTOR_DVID:
+		return "DVI-D";
+	case DRM_MODE_CONNECTOR_DVIA:
+		return "DVI-A";
+	case DRM_MODE_CONNECTOR_Composite:
+		return "Composite";
+	case DRM_MODE_CONNECTOR_SVIDEO:
+		return "SVIDEO";
+	case DRM_MODE_CONNECTOR_LVDS:
+		return "LVDS";
+	case DRM_MODE_CONNECTOR_Component:
+		return "Component";
+	case DRM_MODE_CONNECTOR_9PinDIN:
+		return "9PinDin";
+	case DRM_MODE_CONNECTOR_DisplayPort:
+		return "DisplayPort";
+	case DRM_MODE_CONNECTOR_HDMIA:
+		return "HDMI-A";
+	case DRM_MODE_CONNECTOR_HDMIB:
+		return "HDMI-B";
+	case DRM_MODE_CONNECTOR_TV:
+		return "TV";
+	case DRM_MODE_CONNECTOR_eDP:
+		return "eDP";
+	default:
+		return "Invalid";
+	}
+}
+
+/* dump_blob and dump_prop shamelessly copied from ../modetest/modetest.c */
+static void
+dump_blob(uint32_t blob_id)
+{
+	uint32_t i;
+	unsigned char *blob_data;
+	drmModePropertyBlobPtr blob;
+
+	blob = drmModeGetPropertyBlob(fd, blob_id);
+	if (!blob) {
+		printf("\n");
+		return;
+	}
+
+	blob_data = blob->data;
+
+	for (i = 0; i < blob->length; i++) {
+		if (i % 16 == 0)
+			printf("\n\t\t\t");
+		printf("%.2hhx", blob_data[i]);
+	}
+	printf("\n");
+
+	drmModeFreePropertyBlob(blob);
+}
+
+static void
+dump_prop(uint32_t prop_id, uint64_t value)
+{
+	int i;
+	drmModePropertyPtr prop;
+
+	prop = drmModeGetProperty(fd, prop_id);
+
+	printf("\t%d", prop_id);
+	if (!prop) {
+		printf("\n");
+		return;
+	}
+
+	printf(" %s:\n", prop->name);
+
+	printf("\t\tflags:");
+	if (prop->flags & DRM_MODE_PROP_PENDING)
+		printf(" pending");
+	if (prop->flags & DRM_MODE_PROP_IMMUTABLE)
+		printf(" immutable");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_SIGNED_RANGE))
+		printf(" signed range");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_RANGE))
+		printf(" range");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_ENUM))
+		printf(" enum");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BITMASK))
+		printf(" bitmask");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB))
+		printf(" blob");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_OBJECT))
+		printf(" object");
+	printf("\n");
+
+
+	if (drm_property_type_is(prop, DRM_MODE_PROP_SIGNED_RANGE)) {
+		printf("\t\tvalues:");
+		for (i = 0; i < prop->count_values; i++)
+			printf(" %"PRId64, U642I64(prop->values[i]));
+		printf("\n");
+	}
+
+	if (drm_property_type_is(prop, DRM_MODE_PROP_RANGE)) {
+		printf("\t\tvalues:");
+		for (i = 0; i < prop->count_values; i++)
+			printf(" %"PRIu64, prop->values[i]);
+		printf("\n");
+	}
+
+	if (drm_property_type_is(prop, DRM_MODE_PROP_ENUM)) {
+		printf("\t\tenums:");
+		for (i = 0; i < prop->count_enums; i++)
+			printf(" %s=%llu", prop->enums[i].name,
+			       prop->enums[i].value);
+		printf("\n");
+	} else if (drm_property_type_is(prop, DRM_MODE_PROP_BITMASK)) {
+		printf("\t\tvalues:");
+		for (i = 0; i < prop->count_enums; i++)
+			printf(" %s=0x%llx", prop->enums[i].name,
+			       (1LL << prop->enums[i].value));
+		printf("\n");
+	} else {
+		assert(prop->count_enums == 0);
+	}
+
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB)) {
+		printf("\t\tblobs:\n");
+		for (i = 0; i < prop->count_blobs; i++)
+			dump_blob(prop->blob_ids[i]);
+		printf("\n");
+	} else {
+		assert(prop->count_blobs == 0);
+	}
+
+	printf("\t\tvalue:");
+	if (drm_property_type_is(prop, DRM_MODE_PROP_BLOB))
+		dump_blob(value);
+	else
+		printf(" %"PRIu64"\n", value);
+
+	drmModeFreeProperty(prop);
+}
+
+static void listObjectProperties(uint32_t id, uint32_t type)
+{
+	unsigned int i;
+	drmModeObjectPropertiesPtr props;
+
+	props = drmModeObjectGetProperties(fd, id, type);
+
+	if (!props) {
+		printf("\tNo properties: %s.\n", strerror(errno));
+		return;
+	}
+
+	for (i = 0; i < props->count_props; i++)
+		dump_prop(props->props[i], props->prop_values[i]);
+
+	drmModeFreeObjectProperties(props);
+}
+
+static void listConnectorProperties(void)
+{
+	int i;
+	drmModeConnectorPtr c;
+
+	for (i = 0; i < res->count_connectors; i++) {
+		c = drmModeGetConnector(fd, res->connectors[i]);
+
+		if (!c) {
+			fprintf(stderr, "Could not get connector %u: %s\n",
+				res->connectors[i], strerror(errno));
+			continue;
+		}
+
+		printf("Connector %u (%s-%u)\n", c->connector_id,
+		       connector_type_str(c->connector_type),
+		       c->connector_type_id);
+
+		listObjectProperties(c->connector_id,
+				     DRM_MODE_OBJECT_CONNECTOR);
+
+		drmModeFreeConnector(c);
+	}
+}
+
+static void listCrtcProperties(void)
+{
+	int i;
+	drmModeCrtcPtr c;
+
+	for (i = 0; i < res->count_crtcs; i++) {
+		c = drmModeGetCrtc(fd, res->crtcs[i]);
+
+		if (!c) {
+			fprintf(stderr, "Could not get crtc %u: %s\n",
+				res->crtcs[i], strerror(errno));
+			continue;
+		}
+
+		printf("CRTC %u\n", c->crtc_id);
+
+		listObjectProperties(c->crtc_id, DRM_MODE_OBJECT_CRTC);
+
+		drmModeFreeCrtc(c);
+	}
+}
+
+static void listAllProperties(void)
+{
+	listConnectorProperties();
+	listCrtcProperties();
+}
+
+static int setProperty(char *argv[])
+{
+	uint32_t obj_id, obj_type, prop_id;
+	uint64_t value;
+
+	obj_id = atoi(argv[1]);
+
+	if (!strcmp(argv[2], "connector")) {
+		obj_type = DRM_MODE_OBJECT_CONNECTOR;
+	} else if (!strcmp(argv[2], "crtc")) {
+		obj_type = DRM_MODE_OBJECT_CRTC;
+	} else {
+		fprintf(stderr, "Invalid object type.\n");
+		return 1;
+	}
+
+	prop_id = atoi(argv[3]);
+	value = atoll(argv[4]);
+
+	return drmModeObjectSetProperty(fd, obj_id, obj_type, prop_id, value);
+}
+
+static void printUsage(void)
+{
+	printf("Usage:\n"
+"  proptest\n"
+"  proptest [obj id] [obj type] [prop id] [value]\n"
+"\n"
+"The first form just prints all the existing properties. The second one is\n"
+"used to set the value of a specified property. The object type can be one of\n"
+"the following strings:\n"
+"  connector crtc\n"
+"\n"
+"Example:\n"
+"  proptest 7 connector 2 1\n"
+"will set property 2 of connector 7 to 1\n");
+}
+
+int main(int argc, char *argv[])
+{
+	char *modules[] = { "i915", "radeon", "nouveau", "vmwgfx", "omapdrm", "msm" };
+	unsigned int i, ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(modules); i++){
+		fd = drmOpen(modules[i], NULL);
+		if (fd >= 0) {
+			printf("Module %s loaded.\n", modules[i]);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(modules)) {
+		fprintf(stderr, "Failed to load drm modules.\n");
+		return 1;
+	}
+
+	res = drmModeGetResources(fd);
+	if (!res) {
+		fprintf(stderr, "Failed to get resources: %s\n",
+			strerror(errno));
+		ret = 1;
+		goto done;
+	}
+
+	if (argc < 2) {
+		listAllProperties();
+	} else if (argc == 5) {
+		ret = setProperty(argv);
+	} else {
+		printUsage();
+		ret = 1;
+	}
+
+	drmModeFreeResources(res);
+done:
+	drmClose(fd);
+	return ret;
+}
diff --git a/tests/tegra/.gitignore b/tests/tegra/.gitignore
new file mode 100644
index 0000000..5c5216c
--- /dev/null
+++ b/tests/tegra/.gitignore
@@ -0,0 +1 @@
+openclose
diff --git a/tests/tegra/Makefile.am b/tests/tegra/Makefile.am
new file mode 100644
index 0000000..ca63d92
--- /dev/null
+++ b/tests/tegra/Makefile.am
@@ -0,0 +1,13 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/include/drm \
+	-I$(top_srcdir)/tegra \
+	-I$(top_srcdir)
+
+AM_CFLAGS = -Wall -Werror
+
+LDADD = \
+	../../tegra/libdrm_tegra.la \
+	../../libdrm.la
+
+noinst_PROGRAMS = \
+	openclose
diff --git a/tests/tegra/openclose.c b/tests/tegra/openclose.c
new file mode 100644
index 0000000..881d8aa
--- /dev/null
+++ b/tests/tegra/openclose.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright © 2014 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "xf86drm.h"
+#include "tegra.h"
+
+static const char default_device[] = "/dev/dri/card0";
+
+int main(int argc, char *argv[])
+{
+	struct drm_tegra *tegra;
+	drmVersionPtr version;
+	const char *device;
+	int err, fd;
+
+	if (argc < 2)
+		device = default_device;
+	else
+		device = argv[1];
+
+	fd = open(device, O_RDWR);
+	if (fd < 0)
+		return 1;
+
+	version = drmGetVersion(fd);
+	if (version) {
+		printf("Version: %d.%d.%d\n", version->version_major,
+		       version->version_minor, version->version_patchlevel);
+		printf("  Name: %s\n", version->name);
+		printf("  Date: %s\n", version->date);
+		printf("  Description: %s\n", version->desc);
+
+		drmFreeVersion(version);
+	}
+
+	err = drm_tegra_new(&tegra, fd);
+	if (err < 0)
+		return 1;
+
+	drm_tegra_close(tegra);
+	close(fd);
+
+	return 0;
+}
diff --git a/tests/vbltest/vbltest.c b/tests/vbltest/vbltest.c
index 50e29dc..cdc1ef6 100644
--- a/tests/vbltest/vbltest.c
+++ b/tests/vbltest/vbltest.c
@@ -105,7 +105,7 @@ static void usage(char *name)
 int main(int argc, char **argv)
 {
 	int i, c, fd, ret;
-	char *modules[] = { "i915", "radeon", "nouveau", "vmwgfx", "exynos", "omapdrm", "tilcdc", "msm" };
+	char *modules[] = { "i915", "radeon", "nouveau", "vmwgfx", "exynos", "omapdrm", "tilcdc", "msm", "tegra" };
 	drmVBlank vbl;
 	drmEventContext evctx;
 	struct vbl_info handler_info;
diff --git a/xf86drmMode.h b/xf86drmMode.h
index b260af7..856a6bb 100644
--- a/xf86drmMode.h
+++ b/xf86drmMode.h
@@ -240,6 +240,15 @@ typedef struct _drmModeProperty {
 	uint32_t *blob_ids; /* store the blob IDs */
 } drmModePropertyRes, *drmModePropertyPtr;
 
+static inline int drm_property_type_is(drmModePropertyPtr property,
+		uint32_t type)
+{
+	/* instanceof for props.. handles extended type vs original types: */
+	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
+		return (property->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
+	return property->flags & type;
+}
+
 typedef struct _drmModeCrtc {
 	uint32_t crtc_id;
 	uint32_t buffer_id; /**< FB id to connect to 0 = disconnect */
